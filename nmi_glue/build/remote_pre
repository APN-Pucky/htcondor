#!/usr/bin/env perl

######################################################################
# $Id: remote_pre,v 1.8 2007-10-10 20:07:20 matt Exp $
# script to setup the Condor build
######################################################################

use Cwd;

use Getopt::Long;
use vars qw/ $opt_use_externals_cache $opt_clear_externals_cache /;
GetOptions(
            'use_externals_cache' => \$opt_use_externals_cache,
            'clear_externals_cache' => \$opt_clear_externals_cache,
);


my $BaseDir = getcwd();
my $SrcDir = "$BaseDir/src";
my $vers_file = "CONDOR-VERSION";

# autoflush our STDOUT
$| = 1;

print "------------------------- ENV DUMP ------------------------\n";
if ($ENV{NMI_PLATFORM} =~ /winnt/) {
    system("set");
} else {
    system("env");
}
print "------------------------- ENV DUMP ------------------------\n";

######################################################################
# grab the Condor version out of the version file so we can unpack our 
# source tarball and get everything ready for the other steps.
######################################################################

print "Finding version of Condor\n";
open( VERS, "$vers_file" ) || die "Can't open $vers_file: $!\n";
while( <VERS> ) {
    chomp;
    $vers = $_;
}
close( VERS );
if( ! $vers ) {
    die "Can't find Condor version in $vers_file!\n";
}
print "Condor version: $vers\n";
$src_file = "condor-$vers.tar.gz";
-f $src_file || die "$src_file does not exist!\n";

print "**************************************************\n";
print "Untarring Condor source tarball\n";
print "**************************************************\n";
open( TAR, "tar -zxvf $src_file|" ) ||
    die "Can't open(tar -zxvf $src_file): $!\n";
while( <TAR> ) {
    print $_;
}
close( TAR );
print "**************************************************\n";
if( $? ) {
    die "Tar failed with status $?\n";
}
print "Tar completed successfully, moving contents to base directory\n";

system( "mv condor-$vers/* $BaseDir" );
if( $? ) {
    die "moving condor-$vers/* to $BaseDir failed with status $?\n";
}
print "Move completed successfully\n";


### EXIT POINT FOR WINDOWS ### 

if ($ENV{NMI_PLATFORM} =~ /winnt/) {
    print "SKIPPING external caching and configure step for windows\n";
    exit 0;
}

###
# Update the external cache
#
# - matt 9 oct 2007
###

# Problems:
#  Multiple writers? Two builds on the same system when the cache
#  either does not exist or has stale data could try to update the
#  cache at the same time. Is the multiple writer situation likely?
#   Solution: Put a lock on the cache and retry + fail over to no
#    cache.
#   Problems: Stale locks? A stale lock would have to be manually
#    removed.
#  External changes? A workspace/branch build that changes an external
#  without changing its version could change the externals seen by an
#  already running build on the same system.
#   Solution: Do not change externals without changing their version.

$old = "/scratch/externals"; # the cache, likely /scratch/externals
$new = "$BaseDir/externals"; # the new version. likely ./externals

# People need to be somewhat careful if they are going to use the
# externals cache. At a minimum they need to make sure they are not
# updating an external without changing its version, all the externals
# they are building should succeed, and they should not remove their
# build jobs while an external is building.
print "use_externals_cache: $opt_use_externals_cache\n";
if (!defined($opt_use_externals_cache)) {
    goto bail;
}

print "Updating externals in '$old' with externals from '$new'...\n";

#
# Perform sanity checks to get a good idea if we can properly access
# the cache
#

# Permissions...
(! -r "$old" || ! -w "$old") &&
    print "No permissions to write '$old'" &&
    goto bail;

# Actually a directory...
(-e "$old" && ! -d "$old") &&
    print "'$old' is a file, not a directory" &&
    goto bail;

# If we want to clear the cache or if the script used to build
# externals changes we better clear the cache
if (defined($opt_clear_externals_cache) ||
    system("diff $old/build_external $new/build_external 2>&1/dev/null")) {
    print "Clearing cache " .
	"(clear_externals_cache: $opt_clear_externals_cache)...\n";
    system("rm -r $old") &&
	print "Failed to remove cache" &&
	goto bail;
}

#
# Start updating the cache, or creating it
#
# If the old (cache) directory does not exist we will just create
# it from the new directory
if (! -d "$old") {
    print "'$old' does not exist, initializing from '$new'...\n";
    system("mkdir -p $old") &&
	print "Failed to create '$old'" && 
	goto bail;
    system("cp -r $new/* $old") &&
	print "Failed to initialize '$old'" &&
	goto bail;

# Update the cache
} else {
    # This might not be closed
    opendir(BUNDLES, "$new/bundles") ||
	print "Could not open '$new/bundles'" &&
	goto bail;
    while (defined($bundle = readdir(BUNDLES))) {
	# This might not be closed
	opendir(VERSIONS, "$new/bundles/$bundle") ||
	    print "Can't get a list of $new/bundles/$bundle versions" &&
	    goto bail;
	while (defined($version = readdir(VERSIONS))) {
	    # We only care if there is any difference, not what
	    # the difference is
	    if (system("diff -r $old/bundles/$bundle/$version " .
		       "$new/bundles/$bundle/$version 2>&1/dev/nul")) {
		print "Updating $bundle $version...\n";
		# Make sure the destination exists, which is
		# important to catch the case of new externals
		system("mkdir -p $old/bundles/$bundle/$version") &&
		    print "Failed to ensure cache location exists" &&
		    goto bail;
		# To be completely safe we want to just blow away
		# the old version before copying the new into
		# place
		system("rm -r $old/bundles/$bundle/$version") &&
		    print "Failed to remove old cache version" &&
		    goto bail;
		system("cp -r $new/bundles/$bundle/$version " .
		       "$old/bundles/$bundle") &&
		       print "Failed to populate cache" &&
		       goto bail;
		# Make sure future builds can access this
		# external, even for deletion
		system("chmod -R a+rwX $old/bundles/$bundle/$version") &&
		    print "Failed to change permissions on cache" &&
		    goto bail;
		# Remove the fact that we have built this external
		# in the past. This will result in the external
		# being rebuilt
		(-e "$old/triggers/$bundle-$version") &&
		    unlink "$old/triggers/$bundle-$version" &&
		    print "Failed to remove cached trigger" &&
		    goto bail;
		(-d "$old/install/$bundle-$version") &&
		    system("rm -r $old/install/$bundle-$version") &&
		    print "Failed to remove cached external install" &&
		    goto bail;
	    } else {
		print "$bundle $version is up to date...\n";
	    }
	}
	close(VERSIONS);
    }
    close(BUNDLES);
}

success:
{
    # We want to always make sure that the cache directory is
    # maximally permissive, this also cleans up cases where
    # permissions were too restrictive in the past
    system("chmod -f -R a+rwX $old");
    $externals = $old;
    goto configure; # skip bail label
}

bail:
{
    print "...skipping cache...\n";
    $externals = $new;
}

configure:
######################################################################
# run configure on the source tree
######################################################################

chdir( $SrcDir ) || die "Can't chdir($SrcDir): $!\n";
print "running CONFIGURE ...\n"; 
open( CONFIG,
      "./configure " .
      " --with-soft-is-hard " .
      " --with-externals=$externals 2>&1 |") ||
    die "Can't open configure as a pipe: $!\n";
while ( <CONFIG> ) {
  print $_;
}
close( CONFIG );
$configstat = $?;
print "CONFIGURE returned a code of $configstat\n"; 
($configstat == 0) || die "CONFIGURE failed, aborting build\n";  

