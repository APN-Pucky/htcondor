#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use JSON;
use Data::Dumper;

#
# Argument handling.
#

my( $stackName, $size, $duration, $keypairName, $centralManager, $passwordFile, $passwordURL, $help );

GetOptions(
	'stack-name=s'		=> \$stackName,
	'size=s'			=> \$size,
	'duration=s'		=> \$duration,
	'keypair=s'			=> \$keypairName,
	'central-manager=s'	=> \$centralManager,
	'password-file=s'	=> \$passwordFile,
	'password-url=s'	=> \$passwordURL,
	'help'				=> \$help
	);

if( defined( $help ) ) {
	print( "FIXME\n" );
	exit( 0 );
}

if(! defined( $keypairName ) ) {
	print( "You must specify --keypair.\n" );
	exit( 1 );
}

if(! defined( $duration ) ) {
	$duration = 24 * 60;
	print( "Lease duration will be one day.\n" );
} else {
	unless( $duration =~ /\d+/ ) {
		die( "Duration must be a whole number of minutes.\n" );
	}
}

if(! defined( $size ) ) {
	$size = 100;
	print( "Adding 100 nodes.\n" );
} else {
	unless( $size =~ /\d+/ ) {
		die( "Size must be a positive integer.\n" );
	}
}

if(! defined( $centralManager ) ) {
	$centralManager = `condor_config_val COLLECTOR_HOST`;
	chomp( $centralManager );
	print( "Bloviated startds will report to '${centralManager}'.\n" );
}

my $safeCM = $centralManager;
$safeCM =~ s/:.*$//g;
$safeCM =~ s/\./-/g;

if(! defined( $stackName ) ) {
	$stackName = "condor-bloviate-${safeCM}";
	print( "The stack will be named '${stackName}'.\n" );
} else {
	unless( $stackName =~ /[a-zA-Z][-a-zA-Z0-9]+/ ) {
		die( "The stack's name must start with an alphabetic character and contain only alphanumeric characters and hypens.\n" );
	}
}

# FIXME: S3 bucket names are globally unique?!
my $s3Bucket = "condor-bloviate";
if(! defined( $passwordURL ) ) {
	if(! defined( $passwordFile ) ) {
		$passwordFile = `condor_config_val SEC_PASSWORD_FILE`;
		chomp( $passwordFile );
		if( ! defined( $passwordFile ) || $passwordFile eq '' ) {
			die( "Your pool must be configured to use a pool password.\n" );
		}
		print( "Using password file '${passwordFile}'.\n" );
	}

	unless( -e $passwordFile ) {
			die( "The specified password file (${passwordFile}) does not exist.\n" );
	}

	# Securely upload the password file to S3, then set $passwordURL
	# accordingly.
	my @s3BucketCommand = ( 'aws', 's3api', 'create-bucket',
		'--acl', 'private',
		'--bucket', $s3Bucket );
	my $rv = system( @s3BucketCommand );
	if( $rv != 0 ) {
		print( "Unable to create (private) S3 bucket $s3Bucket ($rv), aborting.\n" );
		exit( 2 );
	}

	$passwordURL = "s3://${s3Bucket}/brussel-sprouts";
	my @s3CopyCommand = ( 'aws', 's3', 'cp',
		$passwordFile, $passwordURL );
	$rv = system( @s3CopyCommand );

	if( $rv != 0 ) {
		print( "Unable to copy password file to private S3 bucket ($rv), aborting.\n" );
		$rv = system( 'aws', 's3api', 'delete-bucket', '--bucket', $s3Bucket );
		if( $rv != 0 ) {
			print( "Unable to delete (private) S3 bucket $s3Bucket ($rv)!  Sorry, you'll have to clean up after us.\n" );
		}
		exit( 3 );
	}
}


#
# Create the specified stack.
#

my @command = (
	'aws', 'cloudformation', 'create-stack',
	'--template-url', 'https://s3.amazonaws.com/htcondor-leased-autoscalinggroup/template-1',
	'--stack-name', $stackName,
    '--capabilities', 'CAPABILITY_IAM',
	'--parameters', '[
        {
            "ParameterKey" : "CentralManager",
            "ParameterValue" : "' . $centralManager . '"
        },
        {
            "ParameterKey" : "SSHKeypairName",
            "ParameterValue" : "' . $keypairName . '"
        },
        {
            "ParameterKey" : "LeaseDuration",
            "ParameterValue" : "' . $duration . '"
        },
        {
            "ParameterKey" : "Size",
            "ParameterValue" : "' . $size . '"
        },
        {
            "ParameterKey" : "S3PoolPassword",
            "ParameterValue" : "' . $passwordURL . '"
        }
    ]' );

my $rv = system( @command );
if( $rv != 0 ) {
	print( "Unable to create CloudFormation stack ($rv), aborting.\n" );
	exit( 1 );
}


#
# Wait for the pool to grow by the specified size.
#
print( "Waiting for pool to bloviate...\n" );

while( 1 ) {
	#
	# Wait until the auto-scaling group exists and is in CREATE_COMPLETE state.
	#

	my @describeStackCommand = ( 'aws', 'cloudformation', 'describe-stack-resources',
		'--stack-name', $stackName );

	my $childFD;
	my $childPID = open( $childFD, '-|', @describeStackCommand );
	if( $childPID == 0 ) {
		# FIXME: We should try to clean up the S3 bucket here; a LAST block?
		print( "Unable to execute '" . join( ' ', @describeStackCommand ) . "', aborting.\n" );
		exit( 6 );
	}

	my $size = 0;
	my $output = undef;
	my $read = 0;
	while( ($read = read( $childFD, $output, 1024, $size )) != 0 ) { $size += $read; }

	waitpid( $childPID, 0 );
	if( $? != 0 ) {
		# FIXME: We should try to clean up the S3 bucket here; a LAST block?
		print( "Failed to describe the stack ($rv), aborting.\n" );
		exit( 7 );
	}
	close( $childFD );

	my $asgName = undef;
	my $reply = decode_json( $output );
	my $stackResources = $reply->{ 'StackResources' };
	foreach my $resource (@{$stackResources}) {
		if( $resource->{ 'ResourceType' } eq "AWS::AutoScaling::AutoScalingGroup" ) {
			if( $resource->{ 'ResourceStatus' } eq "CREATE_COMPLETE" ) {
				$asgName = $resource->{ 'PhysicalResourceId' };
				last;
			}
		}
	}

	if( defined( $asgName ) ) {
		print( "... auto-scaling group created.\n" );
	} else {
		print( "Waiting five seconds for auto-scaling group to be created...\n" );
		sleep( 5 );
		next;
	}


	#
	# Does the extant ASG have all the instances it should?  Use the returned
	# value of DesiredCapacity rather than $size in case it changes during
	# the wait for some reason.  (Print out both at the end.)
	#
	my @describeASGCommand = ( 'aws', 'autoscaling', 'describe-auto-scaling-groups',
		'--auto-scaling-group-names', $asgName );

	$childPID = open( $childFD, '-|', @describeASGCommand );
	if( $childPID == 0 ) {
		# FIXME: We should try to clean up the S3 bucket here; a LAST block?
		print( "Unable to execute '" . join( ' ', @describeASGCommand ) . "', aborting.\n" );
		exit( 7 );
	}

	$size = 0;
	$output = undef;
	$read = 0;
	while( ($read = read( $childFD, $output, 1024, $size )) != 0 ) { $size += $read; }

	waitpid( $childPID, 0 );
	if( $? != 0 ) {
		# FIXME: We should try to clean up the S3 bucket here; a LAST block?
		print( "Failed to describe the auto-scaling group ($rv), aborting.\n" );
		exit( 8 );
	}
	close( $childFD );

	my $instanceCount = undef;
	my $desiredCapacity = undef;
	$reply = decode_json( $output );
	my $autoScalingGroups = $reply->{ 'AutoScalingGroups' };
	foreach my $autoScalingGroup (@{$autoScalingGroups}) {
		if( $autoScalingGroup->{ 'AutoScalingGroupName' } eq $asgName ) {
			$desiredCapacity = $autoScalingGroup->{ 'DesiredCapacity' };
			my $instances = $autoScalingGroup->{ 'Instances' };
			$instanceCount = scalar( @{$instances} );
			last;
		}
	}

	if( $instanceCount == $desiredCapacity ) {
		print( "... pool bloviated with $instanceCount out of $desiredCapacity instances.\n" );
		last;
	}

	print( "... only $instanceCount out of $desiredCapacity instances.\n" );
	sleep( 5 );
}

#
# FIXME: After all the auto-scaling group's instances have been created,
# check to make sure they've actually joined the pool.  NOTE: we'll probably
# need to pass more "user data" to the instances so they can identify
# themselves as coming from this bloviation.
#

#
# Delete the file we uploaded and the bucket we created.
#
my @s3DeleteKeyCommand = ( 'aws', 's3', 'rm', $passwordURL );
$rv = system( @s3DeleteKeyCommand );
if( $rv != 0 ) {
	print( "Failed to delete password file ($passwordURL) from S3 ($rv).  Sorry, you'll have to clean up after us.\n" );
	exit( 4 );
}

$rv = system( 'aws', 's3api', 'delete-bucket', '--bucket', $s3Bucket );
if( $rv != 0 ) {
	print( "Unable to delete (private) S3 bucket $s3Bucket ($rv)!  Sorry, you'll have to clean up after us.\n" );
	exit( 5 );
}

exit( 0 );
