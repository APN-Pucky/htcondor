#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Script for building and pushing the HTCondor Docker containers"""
import locale
import re
import subprocess
import sys
import argparse
import time
import random
from typing import Dict, List

# mypy: no-strict-optional


# fmt:off
SUPPORTED_DISTROS = [
         "el7",
         "el8",
    "ubu18.04",
    "ubu20.04",
]
SUPPORTED_DAILY_DISTROS = [
    "el7",
    "el8",
]
# fmt:on


IMAGES = ["execute", "submit", "cm"]
LATEST_SERIES = "8.9"
# ^^ TODO Gotta be a better way of doing this


REPO = "dockerreg.chtc.wisc.edu"
# ^^ TODO default repo should be dockerhub


def today():
    return time.strftime("%Y%m%d", time.localtime())


def parse_condor_version_str(condor_version_str: str) -> Dict[str, str]:
    """Extract the various information from CondorVersion
    (as returned by get_condor_version_and_condor_platform()).
    The date is converted to YYYYMMDD format (used in tags)

    >>> parse_condor_version_str('8.9.8 Jun 30 2020 BuildID: 508520 PackageID: 8.9.8-0.508520')
    {'version': '8.9.8', 'date': '20200630', 'build_id': '508520', 'package_id': '8.9.8-0.508520'}

    """
    match = re.match(
        r"""
                     (?P<version>[0-9]+[.][0-9]+[.][0-9]+) \s+
                     (?P<date>\w+\s+\d+\s+\d+) \s+
                     BuildID:\s+(?P<build_id>\S+) \s+
                     PackageID:\s+(?P<package_id>[^\n]+)
                     $""",
        condor_version_str,
        re.X,
    )
    if match:
        parsed = dict(match.groupdict())
        parsed["date"] = time.strftime(
            "%Y%m%d", time.strptime(parsed["date"], "%b %d %Y")
        )
        return parsed
    else:
        raise RuntimeError("Can't parse CondorVersion: %s" % condor_version_str)


class VersionInfo:
    def __init__(self, condor_version_str, condor_platform_str):
        self.condor_version_str = condor_version_str
        self.condor_platform_str = condor_platform_str
        condor_version_dict = parse_condor_version_str(condor_version_str)
        self.date = condor_version_dict["date"]
        self.version = condor_version_dict["version"]
        self.build_id = condor_version_dict["build_id"]
        self.package_id = condor_version_dict["package_id"]


class Builder:
    def __init__(self, executable, series, version):
        self.executable = executable
        if series == "latest":
            self.want_latest_series = True
            self.series = LATEST_SERIES
        else:
            self.want_latest_series = False
            self.series = series

        self.version = version
        self.want_latest_version = version == "latest"
        self.want_daily = version == "daily"
        if version not in ["latest", "daily"]:  # exact version -- ignore series
            self.series = ""
            self.want_latest_series = False

    def docker(self, *args, **kwargs):
        return subprocess.run([self.executable] + list(args), **kwargs)

    def docker_tag(self, old_name, *new_names):
        if isinstance(new_names[0], (tuple, list)):
            new_names = new_names[0]
        for new_name in new_names:
            print(f"Tagging {old_name} as {new_name}")
            self.docker("tag", old_name, new_name)

    def get_condor_version_info(self, image_name: str) -> VersionInfo:
        """Get the version information out of CondorVersion and CondorPlatform from a container by running `condor_version`.
        The output of `condor_version` looks like:

            $CondorVersion: 8.9.8 Jun 30 2020 BuildID: 508520 PackageID: 8.9.8-0.508520 $
            $CondorPlatform: x86_64_Fedora32 $

        """
        ret = subprocess.run(
            [self.executable, "run", "--rm", image_name, "condor_version"],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            check=True,
        )
        try:
            condor_version_str = (
                re.search(
                    rb"^[$]CondorVersion:\s*([^\n]+)[$]$", ret.stdout, re.MULTILINE
                )
                .group(1)
                .rstrip()
                .decode("latin-1")
            )
            condor_platform_str = (
                re.search(
                    rb"^[$]CondorPlatform:\s*([^\n]+)[$]$", ret.stdout, re.MULTILINE
                )
                .group(1)
                .rstrip()
                .decode("latin-1")
            )
        except AttributeError:
            raise RuntimeError(
                "Couldn't find CondorVersion or CondorPlatform in condor_version output"
            )
        return VersionInfo(condor_version_str, condor_platform_str)

    def add_htcondor_labels(self, image_name: str, version_info: VersionInfo):
        dockerfile = """\
FROM %s
LABEL \
org.htcondor.condor-version="%s" \
org.htcondor.condor-platform="%s" \
org.htcondor.build-date="%s" \
org.htcondor.build-id="%s" \
org.htcondor.package-id="%s" \
org.htcondor.version="%s"
""" % (
            image_name,
            version_info.condor_version_str,
            version_info.condor_platform_str,
            version_info.date,
            version_info.build_id,
            version_info.package_id,
            version_info.version,
        )
        subprocess.run(
            [self.executable, "build", "-t", image_name, "-f", "-", "."],
            input=dockerfile.encode(),
            check=True,
        )

    def dockerfile_name(self, distro: str) -> str:
        if distro.startswith("el"):
            if self.want_daily:
                return "Dockerfile-daily-el"
            else:
                return "Dockerfile-el"
        elif distro.startswith("ubu"):
            if self.want_daily:
                return "Dockerfile-daily-ubu"
            else:
                return "Dockerfile-ubu"
        else:
            assert False, "not one of the supported distros -- should have been caught"

    def build_base(self, distro: str) -> List[str]:
        args = [f"--build-arg=BUILDDATE={today()}"]
        if self.want_latest_version or self.want_daily:
            args.append(f"--build-arg=SERIES={self.series}")
        else:
            args.append(f"--build-arg=VERSION={self.version}")

        if distro.startswith("el"):
            args.append(f"--build-arg=EL={distro[2:]}")
        elif distro.startswith("ubu"):
            args.append(f"--build-arg=UBU={distro[3:]}")
        else:
            assert False, "not one of the supported distros -- should have been caught"
        dockerfile = self.dockerfile_name(distro)
        tmp_image_name = f"htcondor/base:tmp{random.randint(10000,99999)}"
        args.extend(["-t", tmp_image_name, "-f", f"base/{dockerfile}", "."])

        self.docker("build", *args, stdin=subprocess.DEVNULL, check=True)

        try:
            version_info = self.get_condor_version_info(tmp_image_name)
            self.add_htcondor_labels(tmp_image_name, version_info)
            real_version = version_info.version
            real_series = ".".join(real_version.split(".")[0:2])

            if self.want_daily:
                real_image_names = [f"htcondor/base:{self.series}-daily-{distro}"]
                if self.want_latest_series:
                    real_image_names.append(f"htcondor/base:daily-{distro}")
            else:
                real_image_names = [f"htcondor/base:{real_version}-{distro}"]
                if self.want_latest_version:
                    real_image_names.append(f"htcondor/base:{real_series}-{distro}")
                    if self.want_latest_series:
                        real_image_names.append(f"htcondor/base:{distro}")
                else:
                    if real_version != self.version:
                        raise RuntimeError(
                            f"condor_version version {real_version} does not match requested version {self.version}"
                        )

            self.docker_tag(tmp_image_name, *real_image_names)

            return real_image_names
        finally:
            self.docker("rmi", tmp_image_name, check=False)

    def build_derived(
        self, image: str, baseimages: List[str], distro: str
    ) -> List[str]:
        basetags = []
        for img in baseimages:
            if ":" in img:
                basetags.append(img.split(":", 1)[1])
            else:
                basetags.append(img)

        args = [
            f"--build-arg=BASETAG={basetags[0]}",
            f"--build-arg=BUILDDATE={today()}",
        ]
        dockerfile = self.dockerfile_name(distro)

        for basetag in basetags:
            args.extend(["-t", f"htcondor/{image}:{basetag}"])
        args.extend(["-f", f"{image}/{dockerfile}", "."])

        self.docker("build", *args, stdin=subprocess.DEVNULL, check=True)

        return [f"htcondor/{image}:{basetag}" for basetag in basetags]

    def push_image(self, image, repository):
        image_with_repo = f"{repository}/{image}"

        self.docker("tag", image, image_with_repo, check=True)
        self.docker("push", image_with_repo, check=True)
        self.docker("rmi", image_with_repo, check=False)


def main(argv) -> int:
    locale.setlocale(locale.LC_ALL, "C")  # no parsing surprises please
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "version",
        help="Version of HTCondor to install.  Can be an exact version (e.g. '8.9.9'), 'daily', or 'latest'",
    )
    parser.add_argument(
        "--distro",
        help="Distribution to build/push for (default %(default)s)",
        choices=SUPPORTED_DISTROS + ["all"],
        default="el7",
    )
    parser.add_argument(
        "--series",
        help="The release series for daily or latest builds (default %(default)s). "
        "Only used if version is 'daily' or 'latest'.",
        default="latest",
    )
    parser.add_argument(
        "--push", action="store_true", dest="push", help="Push resulting builds"
    )
    # parser.add_argument("--nopush", action="store_false", dest="push", help="Do not push resulting builds")
    parser.add_argument(
        "--mini", action="store_true", dest="mini", help="Build minicondor"
    )
    # parser.add_argument("--nomini", action="store_false", dest="mini", help="Do not build minicondor")
    parser.add_argument("--podman", action="store_true", help="Use podman")
    parser.add_argument(
        "--base-only", action="store_true", help="Build htcondor/base only"
    )
    args = parser.parse_args(argv[1:])

    if not (
        args.version in ["daily", "latest"]
        or re.match(r"[0-9]+[.][0-9]+[.][0-9]+", args.version)
    ):
        parser.error(
            "Bad version '{args.version}' -- should be like '8.9.9', 'daily', or 'latest'"
        )

    images = IMAGES
    if args.mini:
        images += ["mini"]

    if args.distro == "all":
        if args.version == "daily":
            distros = SUPPORTED_DAILY_DISTROS
        else:
            distros = SUPPORTED_DISTROS
    else:
        assert args.distro in SUPPORTED_DISTROS, "Should have been caught"
        if args.version == "daily":
            if args.distro not in SUPPORTED_DAILY_DISTROS:
                raise RuntimeError("Daily builds aren't available for this distro")
        distros = [args.distro]

    executable = "podman" if args.podman else "docker"

    builder = Builder(executable=executable, series=args.series, version=args.version)

    images_to_push = []
    for distro in distros:
        baseimages = builder.build_base(distro)
        images_to_push.extend(baseimages)
        if not args.base_only:
            for image in images:
                images_to_push.extend(
                    builder.build_derived(
                        distro=distro, baseimages=baseimages, image=image
                    )
                )

    if args.push:
        for img in images_to_push:
            builder.push_image(image=img, repository=REPO)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
