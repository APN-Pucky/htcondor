#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Script for building and pushing the HTCondor Docker containers.


Example usage:


    Build the latest version of the latest series for all supported distros:
        %(prog)s --distro=all latest


    Build the latest daily build for the default distribution and push to the
    default registry:
        %(prog)s --push daily


    Build version 8.9.11 for Ubuntu 18.04 and push to the CHTC registry:
        %(prog)s --distro=ubu18.04 --push --registry=chtc 8.9.11

"""
import locale
import re
import subprocess
import sys
import argparse
import time
import random
from typing import Dict, List

# mypy: no-strict-optional


# fmt:off
SUPPORTED_DISTROS = [
         "el7",
         "el8",
    "ubu18.04",
    "ubu20.04",
]
SUPPORTED_DAILY_DISTROS = [
    "el7",
    "el8",
]
# fmt:on


IMAGES = ["execute", "submit", "cm", "mini"]
LATEST_SERIES = "8.9"
# ^^ TODO Gotta be a better way of doing this


DEFAULT_REGISTRY = "docker.io"


def today() -> str:
    """Current date in YYYYMMDD format (used in tags)"""
    return time.strftime("%Y%m%d", time.localtime())


def parse_condor_version_str(condor_version_str: str) -> Dict[str, str]:
    """Extract various information from CondorVersion
    (as returned by get_condor_version_and_condor_platform()).
    The date is converted to YYYY-MM-DD format.

    >>> parse_condor_version_str('8.9.8 Jun 30 2020 BuildID: 508520 PackageID: 8.9.8-0.508520')
    {'version': '8.9.8', 'date': '2020-06-30', 'build_id': '508520', 'package_id': '8.9.8-0.508520'}

    """
    match = re.match(
        r"""
                     (?P<version>[0-9]+[.][0-9]+[.][0-9]+) \s+
                     (?P<date>\w+\s+\d+\s+\d+) \s+
                     BuildID:\s+(?P<build_id>\S+) \s+
                     PackageID:\s+(?P<package_id>[^\n]+)
                     $""",
        condor_version_str,
        re.X,
    )
    if match:
        parsed = dict(match.groupdict())
        parsed["date"] = time.strftime(
            "%Y-%m-%d", time.strptime(parsed["date"], "%b %d %Y")
        )
        return parsed
    else:
        raise RuntimeError("Can't parse CondorVersion: %s" % condor_version_str)


class VersionInfo:
    def __init__(self, condor_version_str, condor_platform_str):
        self.condor_version_str = condor_version_str
        self.condor_platform_str = condor_platform_str
        condor_version_dict = parse_condor_version_str(condor_version_str)
        self.date = condor_version_dict["date"]
        self.version = condor_version_dict["version"]
        self.build_id = condor_version_dict["build_id"]
        self.package_id = condor_version_dict["package_id"]


class Builder:
    def __init__(self, executable, series, version, prefix):
        self.executable = executable
        if series == "latest":
            self.want_latest_series = True
            self.series = LATEST_SERIES
        else:
            self.want_latest_series = False
            self.series = series

        self.prefix = prefix
        self.version = version
        self.want_latest_version = version == "latest"
        self.want_daily = version == "daily"
        if version not in ["latest", "daily"]:  # exact version -- ignore series
            self.series = ""
            self.want_latest_series = False

    def docker(self, *args, **kwargs):
        return subprocess.run([self.executable] + list(args), **kwargs)

    def docker_tag(self, old_name, *new_names):
        if isinstance(new_names[0], (tuple, list)):
            new_names = new_names[0]
        for new_name in new_names:
            print(f"Tagging {old_name} as {new_name}")
            self.docker("tag", old_name, new_name)

    def get_condor_version_info(self, image_name: str) -> VersionInfo:
        """Get the version information out of CondorVersion and CondorPlatform from a container by running `condor_version`.
        The output of `condor_version` looks like:

            $CondorVersion: 8.9.8 Jun 30 2020 BuildID: 508520 PackageID: 8.9.8-0.508520 $
            $CondorPlatform: x86_64_Fedora32 $

        """
        ret = subprocess.run(
            [self.executable, "run", "--rm", image_name, "condor_version"],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            check=True,
        )
        try:
            condor_version_str = (
                re.search(
                    rb"^[$]CondorVersion:\s*([^\n]+)[$]$", ret.stdout, re.MULTILINE
                )
                .group(1)
                .rstrip()
                .decode("latin-1")
            )
            condor_platform_str = (
                re.search(
                    rb"^[$]CondorPlatform:\s*([^\n]+)[$]$", ret.stdout, re.MULTILINE
                )
                .group(1)
                .rstrip()
                .decode("latin-1")
            )
        except AttributeError:
            raise RuntimeError(
                "Couldn't find CondorVersion or CondorPlatform in condor_version output"
            )
        return VersionInfo(condor_version_str, condor_platform_str)

    def add_htcondor_labels(self, image_name: str, version_info: VersionInfo):
        dockerfile = """\
FROM %s
LABEL \
org.htcondor.condor-version="%s" \
org.htcondor.condor-platform="%s" \
org.htcondor.build-date="%s" \
org.htcondor.build-id="%s" \
org.htcondor.package-id="%s" \
org.htcondor.version="%s"
""" % (
            image_name,
            version_info.condor_version_str,
            version_info.condor_platform_str,
            version_info.date,
            version_info.build_id,
            version_info.package_id,
            version_info.version,
        )
        subprocess.run(
            [self.executable, "build", "-t", image_name, "-f", "-", "."],
            input=dockerfile.encode(),
            check=True,
        )

    def build_base(self, distro: str) -> List[str]:
        args = []
        if self.want_latest_version:
            args.extend([f"--build-arg=SERIES={self.series}", "--build-arg=VERSION=latest"])
        elif self.want_daily:
            args.extend([f"--build-arg=SERIES={self.series}", "--build-arg=VERSION=daily"])
        else:
            args.append(f"--build-arg=VERSION={self.version}")

        if distro.startswith("el"):
            args.append(f"--build-arg=BASE_IMAGE=centos:{distro[2:]}")
        elif distro.startswith("ubu"):
            args.append(f"--build-arg=BASE_IMAGE=ubuntu:{distro[3:]}")
        else:
            assert False, "not one of the supported distros -- should have been caught"
        tmp_image_name = f"{self.prefix}base:tmp{random.randint(10000,99999)}"
        args.extend(["-t", tmp_image_name, "-f", f"base/Dockerfile", "base"])

        self.docker("build", *args, stdin=subprocess.DEVNULL, check=True)

        try:
            version_info = self.get_condor_version_info(tmp_image_name)
            self.add_htcondor_labels(tmp_image_name, version_info)
            real_version = version_info.version
            real_series = ".".join(real_version.split(".")[0:2])

            if self.want_daily:
                real_image_names = [f"{self.prefix}base:{self.series}-daily-{distro}"]
                if self.want_latest_series:
                    real_image_names.append(f"{self.prefix}base:daily-{distro}")
            else:
                real_image_names = [f"{self.prefix}base:{real_version}-{distro}"]
                if self.want_latest_version:
                    real_image_names.append(f"{self.prefix}base:{real_series}-{distro}")
                    if self.want_latest_series:
                        real_image_names.append(f"{self.prefix}base:{distro}")
                else:
                    if real_version != self.version:
                        raise RuntimeError(
                            f"condor_version version {real_version} does not match requested version {self.version}"
                        )

            self.docker_tag(tmp_image_name, *real_image_names)

            return real_image_names
        finally:
            self.docker("rmi", tmp_image_name, check=False)

    def build_derived(
        self, image: str, baseimages: List[str], distro: str
    ) -> List[str]:
        new_tags = [re.sub(r"base:", image + ":", x) for x in baseimages]

        args = [f"--build-arg=BASE_IMAGE={baseimages[0]}"]
        if image == "execute":
            args.append(f"--build-arg=PACKAGE_LIST=packagelist-{distro}.txt")

        for new_tag in new_tags:
            args.extend(["-t", new_tag])
        args.extend(["-f", f"{image}/Dockerfile", image])

        self.docker("build", *args, stdin=subprocess.DEVNULL, check=True)

        return new_tags

    def push_image(self, image, registry):
        if self.executable == "podman" or registry != "docker.io":
            image_with_registry = f"{registry}/{image}"
            self.docker("tag", image, image_with_registry, check=True)
            self.docker("push", image_with_registry, check=True)
            self.docker("rmi", image_with_registry, check=False)
        else:
            # When it's real docker pushing to dockerhub: the tag/push/rmi
            # sequence will cause the original build to be deleted as well
            self.docker("push", image, check=True)


def main(argv) -> int:
    locale.setlocale(locale.LC_ALL, "C")  # no parsing surprises please
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "version",
        help="Version of HTCondor to install.  Can be an exact version (e.g. '8.9.9'), 'daily', or 'latest'",
    )
    parser.add_argument(
        "--distro",
        help="Distribution to build/push for (default %(default)s)",
        choices=SUPPORTED_DISTROS + ["all"],
        default="el7",
    )
    parser.add_argument(
        "--series",
        help="The release series for daily or latest builds (default %(default)s). "
        "Either numeric (e.g. '8.9') or 'latest'. "
        "Only used if version is 'daily' or 'latest'.",
        default="latest",
    )
    parser.add_argument(
        "--push", action="store_true", dest="push", help="Push resulting builds"
    )
    # parser.add_argument("--no-push", action="store_false", dest="push", help="Do not push resulting builds")
    parser.add_argument(
        "--registry",
        help="Registry to push to (default %(default)s). Enter HOST:PORT (port is "
        "optional) or 'dockerhub' for Docker Hub or 'chtc' for the CHTC registry.",
        default=DEFAULT_REGISTRY,
    )
    # parser.add_argument(
    #     "--mini", action="store_true", dest="mini", help="Build minicondor"
    # )
    parser.add_argument(
        "--no-mini", action="store_false", dest="mini", help="Do not build minicondor"
    )
    parser.add_argument("--podman", action="store_true", help="Use podman")
    parser.add_argument(
        "--base-only", action="store_true", help="Build htcondor/base only"
    )
    parser.add_argument(
        "--prefix",
        help="Prefix to use for the container names. Must include a '/' and must not "
        "include a ':'.  Default: '%(default)s'; use something like "
        "'myusername/htcondor-' to push images named 'htcondor-base', etc. "
        "to your own docker account.",
        default="htcondor/",
    )
    args = parser.parse_args(argv[1:])

    if not (
        args.version in ["daily", "latest"]
        or re.match(r"[0-9]+[.][0-9]+[.][0-9]+", args.version)
    ):
        parser.error(
            f"Bad version '{args.version}' -- should be like '8.9.9', 'daily', or 'latest'"
        )

    if not re.fullmatch(r"[0-9a-z][.0-9a-z-]*/[.0-9a-z-]*", args.prefix):
        parser.error(f"Invalid prefix '{args.prefix}'")

    images = IMAGES
    if not args.mini:
        images.remove("mini")

    if args.distro == "all":
        if args.version == "daily":
            distros = SUPPORTED_DAILY_DISTROS
        else:
            distros = SUPPORTED_DISTROS
    else:
        assert args.distro in SUPPORTED_DISTROS, "Should have been caught"
        if args.version == "daily":
            if args.distro not in SUPPORTED_DAILY_DISTROS:
                raise RuntimeError("Daily builds aren't available for this distro")
        distros = [args.distro]

    if args.registry.lower() == "dockerhub":
        args.registry = "docker.io"
    elif args.registry.lower() == "chtc":
        args.registry = "dockerreg.chtc.wisc.edu:443"

    executable = "podman" if args.podman else "docker"

    builder = Builder(
        executable=executable,
        series=args.series,
        version=args.version,
        prefix=args.prefix,
    )

    images_to_push = []
    for distro in distros:
        baseimages = builder.build_base(distro)
        images_to_push.extend(baseimages)
        if not args.base_only:
            for image in images:
                images_to_push.extend(
                    builder.build_derived(
                        distro=distro, baseimages=baseimages, image=image
                    )
                )

    if args.push:
        for img in images_to_push:
            builder.push_image(image=img, registry=args.registry)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
