OVERVIEW

	We use a CloudFormation template to help track all the moving parts
(and clean them up when we're done).  The moving parts include:

* The AutoScaling Group itself, which defines a particular bloviation.
* A custom metric for that AutoScaling group, whose namespace includes
	the ASG's name.
* A CloudWatch alarm which triggers when the custom metric becomes 0 or
	misses enough updates.  The triggered action is the Lambda function.
	This alarm is identical in all bloviations, but since it watches
	a different metric in each, it must be distinctly instantiated.
* An SNS topic, which names the channel between the alarm(s) and the Lambda
	function.  This topic may be shared between different bloviations.
* A Lambda function, the same for all bloviations, which when triggered
	by the alarm deletes the AutoScaling Group specified in the namespace
	thereof.
* A Lambda function, the same for all bloviations, invoked as a custom
    resource, that adjusts the permissions on the previous Lambda function
    so that the SNS topic can invoke it when the alarm triggers and calls it.
* A Lambda function, the same for all bloviations, invoked as a custom
    resource, that inserts a data point into the lease metric.  (The alarm
    will otherwise never leave its initial INSUFFICIENT (data) state.)
* A Security Group for the instances we create, the same for all bloviations.
* A Launch Configuration for the AutoScaling Group.
* Three IAM roles, one for each Lambda function.  Each IAM role is the same
  for all bloviations.

LAUNCH CONFIGURATION

Amazon does some things that make it very difficult to to automatically
generate launch configurations:

* Some instance types don't exist in some availability zones.
* Some instance types may require VPC.  You'd think we could work around this,
  but we need subnet IDs... and a subnet is availability-zone specific.  Of
  course, we don't know the names of the availability zones -- or even the
  count -- since they vary from region to region.  We could create mappings,
  but how do we create loops?  The subnet resource doesn't allow a list in the
  availability zone parameter.  Could we create another custom resource whose
  Lambda function creates a subnet in each AZ for the region it runs in?  Even
  if we could, how would we create the launch group(s)?
* AMIs vary by availability zone.  This can be worked around using mappings --
  see Amazon's standard example templates -- but it makes everything harder.

In the glorious future, when we have our own AMIs, we can use the Amazon trick
to choose one, but it's wildly unclear how to deal with the VPC subnet
requirements and launch group variability.

	Note that the "DependsOn" attributes exit to force the LeaseFunctionRole
to be deleted last, because once it's deleted, CloudFormation no longer has
the permissions to delete anything else.

FIXME

[] Pass the password file's S3 URL along to the instance, along with an IAM
role that permits the instance to read the password file.

FEATURE REQUESTS

* When creating an AWS::SNS::Topic resource with a Lamba-protocol subscription,
  automatically add permissions on the referenced function to allow that topic
  to Invoke([.*]?) it.
* The Cloud Formation web console should check parameter validity earlier
  and write out constraint failure messages next to the corresponding parameter.
* Add an intrinsic function to refer to arbitrary parameters in other resources.
* An AWS::Lambda::Function should be able to specify the duration of its logs.
  It's really hard to do this right now, because the log won't actually exist
  until the Lambda function runs, which could happen at any time.  This may
  actually be a feature request for CloudWatch -- I'd like to set the default
  retention policy for a log group based on its name (and/or source).
* Delete generate subscriptions with the rest of the stack.
* Access to the ARN of a security group.  (Using Fn::Join is awkward.)
* Deletion order dependency.  In particular, if I create an IAM role for a
  Lambda function, it has to be the last thing deleted, because otherwise
  CloudFormation loses the privileges to finish the deletion.  However, that
  IAM role should have its resources restricted based on resources created
  for the stack...

NOTES

* I could possibly use code to create the log group each Lambda function
  will by convention create, and set the retention policy there?
* I could probably delete subscriptions in code.
* I would like to narrow the resource permissions granted to the IAM roles,
  but some actions don't support that, and others cause circular dependency
  problems -- see above.
