#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use JSON;
use Data::Dumper;
use POSIX;

use constant TRUE => 1;
use constant FALSE => 0;

#
# At some point, we may want to split the template into two pieces, one for
# the pool's administrator with higher privileges, and one for the project
# which has very limited privileges.  In particular, the Lambda functions
# and the IAM roles should be shared (with the exception of the S3 reader).
#

#
# Argument handling.
#

my( $projectID, $stackName, $setSize, $expiry, $keypairName, $centralManager, $passwordFile, $passwordLocation, $vpc, $subnets, $help );

GetOptions(
    'project-id=s'		=> \$projectID,
	'stack-name=s'		=> \$stackName,
	'set-size=s'		=> \$setSize,
	'expiry=s'			=> \$expiry,
	'keypair=s'			=> \$keypairName,
	'central-manager=s'	=> \$centralManager,
	'password-file=s'	=> \$passwordFile,
	'password-url=s'	=> \$passwordLocation,
	'vpc=s'				=> \$vpc,
	'subnets=s'			=> \$subnets,
	'help'				=> \$help
	);

if( defined( $help ) ) {
	print( "Usage: $0 --set-size <size> [options]\n" );
	print( "\n" );
	print( "Adjusts the size of an annex, creating it if necessary.  " );
	print( "It returns when the annex has reached the specified size.  " );
	print( "To create an annex, you must specify a keypair.  " );
	print( "\n" );
	print( "Required flags:\n" );
	print( "\t--project-id		 To whom will this annex belong?\n" );
	print( "Use one or more of the following flags:\n" );
	print( "\t--set-size         How big (instances) should the annex be?\n" );
	print( "\t--expiry           When (YYYY-MM-DD HH:MM [+/-hhmm]) the annex should shut itself down.\n" );
	print( "Options:\n" );
	print( "\t--keypair          Which keypair to use (same for all instances).\n" );
	print( "\t--help             Print this help.\n" );
	print( "Expert options:\n" );
	print( "\t--password-url     An S3 URL pointing to the pool password file.\n" );
	print( "\t--password-file    Specify the pool password file.\n" );
	print( "\t--central-manager  Specify the annex's central manager.\n" );
	print( "\t--stack-name       Name the stack (annex).\n" );
	print( "\t--vpc              The VPC to launch instances in.\n" );
	print( "\t--subnets          Comma-separated list of subnets to use.  Determines which AZs you use.\n" );
	exit( 0 );
}

if(! defined( $projectID )) {
	die( "You must specify --project-id.\n" );
}

if((! defined( $setSize )) && (! defined( $expiry ))) {
	die( "You must specify at least one of --set-size and --expiry.\n" );
}

if( defined( $setSize ) ) {
	unless( $setSize =~ /\d+/ ) {
		die( "Size must be a positive integer.\n" );
	}
}

# We implement leases based on duration, not expiration.
# The default duration is six minutes less than one day,
# because Amazon hates all of you.
my $duration = 1434;
if( defined( $expiry ) ) {
	my( $date, $time, $zone ) = split( ' ', $expiry );
	my( $year, $month, $day ) = split( '-', $date );
	my( $hour, $minute ) = split( ':', $time );

	my $epoch = mktime( 0, $minute, $hour, $day, $month - 1, $year - 1900 );
	$duration = $epoch - time();
	if( $duration < 0 ) {
		print( "You must specify an expiration in the future.\n" );
		exit( 1 );
	}
	if( $duration >= (24 * 60 * 60) ) {
		print( "You must specify an expiration less than 24 hours from now.\n" );
		exit( 1 );
	}

	$duration = $duration - ($duration % 60);
	$duration = $duration / 60;
}

#
# We need to know if the stack exists before we can correctly parse the
# rest of the command-line options.  We need the name of the central
# manager to determine the name of the stack, if it wasn't given.
#

if(! defined( $centralManager ) ) {
	$centralManager = `condor_config_val COLLECTOR_HOST`;
	chomp( $centralManager );
	print( "The annex will report to '${centralManager}'.\n" );
}

my $safeCM = $centralManager;
$safeCM =~ s/:.*$//g;
$safeCM =~ s/\./-/g;

if(! defined( $stackName )) {
	$stackName = "htcondor-annex-${safeCM}-${projectID}";
	print( "The annex (stack) will be named '${stackName}'.\n" );
} else {
	unless( $stackName =~ /[a-zA-Z][-a-zA-Z0-9]+/ ) {
		die( "The annex's name must start with an alphabetic character and contain only alphanumeric characters and hypens.\n" );
	}
}

print( "Checking to see if annex already exists..." );
my $stackExists = stackExists( $stackName );
if( $stackExists ) { print( " yes.\n" ); }
else{ print( " no.\n" ); }

# Parse the rest of the command-line options.
if((! $stackExists) && (! defined( $keypairName )) ) {
	print( "You must specify --keypair when creating a new stack.\n" );
	exit( 1 );
}

if( $stackExists && defined( $vpc ) ) {
	print( "Ignoring VPC specified after stack creation.\n" );
}

if( (! $stackExists) && (! defined( $vpc )) ) {
	print( "Attempting to determine which VPC to use..." );

	my @command = (
		'aws', 'ec2', 'describe-vpcs',
		'--filters', 'Name=tag:Name,Values=HTCondorAnnex'
	);

	my( $rv, $output ) = capture( @command );
	if( $rv != 0 ) {
		print( $output );
		print( "\n" );
		print( " failed ($rv), aborting.  You must specify --vpc.\n" );
		exit( 1 );
	}

	my $reply = decode_json( $output );
	my $vpcs = $reply->{ "Vpcs" };
	if( scalar( @{$vpcs} ) == 0 ) {
		print( " done.  Found no VPCs, aborting.  You must specify --vpc.\n" );
		exit( 1 );
	}
	if( scalar( @{$vpcs} ) > 1 ) {
		print( "  ... picking the first of many..." );
	}
	$vpc = $vpcs->[0]->{ "VpcId" };
	print( " done.  Found VPC '$vpc'.\n" );
}

if( $stackExists && defined( $subnets ) ) {
	print( "Ignoring subnets specified after stack creation.\n" );
}

if( (! $stackExists) && (! defined( $subnets )) ) {
	print( "Attempting to determine which subnets to use..." );

	my @command = (
		'aws', 'ec2', 'describe-subnets',
		'--filters', 'Name=tag:Name,Values=HTCondorAnnex', 'Name=vpc-id,Values=' . $vpc
	);

	my ( $rv, $output ) = capture( @command );
	if( $rv != 0 ) {
		print( $output );
		print( "\n" );
		print( " failed ($rv), aborting.  You must specify --subnets.\n" );
		exit( 1 );
	}

	my $reply = decode_json( $output );
	my $subnetList = $reply->{ "Subnets" };
	if( scalar( @{$subnetList} ) == 0 ) {
		print( " done.  Found no subnets, aborting.  You must specify --subnets.\n" );
		exit( 1 );
	}
	my @subnetIDs;
	foreach my $subnet (@{$subnetList}) {
		push( @subnetIDs, $subnet->{ "SubnetId" } );
	}

	$subnets = join( ", ", @subnetIDs );
	print( " done.  Found subnets '$subnets'.\n" );
}


# Globals for the END block and signal traps.
# $passwordLocation was already declared.
my $createdS3Bucket = FALSE;
my $uploadedPasswordFile = FALSE;
my $s3Bucket = "htcondor-annex-${safeCM}-${projectID}";
END { s3Cleanup(); }
$SIG{ 'INT' } = \&s3CleanupAndExit;

if( ! $stackExists ) {
	# The pool password file and the stack have the same lifetime.  Once
	# we've uploaded the pool password file, we're only responsible for
	# deleting it until the stack exists, at which point it takes over.
	if(! defined( $passwordLocation )) {
		if(! defined( $passwordFile )) {
			$passwordFile = `condor_config_val SEC_PASSWORD_FILE`;
			chomp( $passwordFile );
			if( (! defined( $passwordFile )) || $passwordFile eq '' ) {
				die( "Your pool must be configured to use a pool password.\n" );
			}
			# print( "Using password file '${passwordFile}'.\n" );
		}

		unless( -e $passwordFile ) {
				die( "The specified password file (${passwordFile}) does not exist.\n" );
		}

		# Securely upload the password file to S3, then set $passwordLocation
		# accordingly.
		print( "Creating private S3 bucket to store pool password..." );
		my @s3BucketCommand = ( 'aws', 's3api', 'create-bucket',
			'--acl', 'private',
			'--bucket', $s3Bucket );
		my( $rv, $log ) = capture( @s3BucketCommand );
		if( $rv != 0 ) {
			print( $log );
			print( "\n" );
			print( "Unable to create (private) S3 bucket $s3Bucket ($rv), aborting.\n" );
			exit( 2 );
		}
		$createdS3Bucket = TRUE;
		print( " done.\n" );

		$passwordLocation = "${s3Bucket}/brussel-sprouts";
		my @s3CopyCommand = ( 'aws', 's3', 'cp',
			$passwordFile, "s3://${passwordLocation}" );
		print( "Uploading pool password file..." );
		($rv, $log) = capture( @s3CopyCommand );

		if( $rv != 0 ) {
			print( $log );
			print( "\n" );
			print( "Unable to copy password file to private S3 bucket ($rv), aborting.\n" );
			$rv = system( 'aws', 's3api', 'delete-bucket', '--bucket', $s3Bucket );
			if( $rv != 0 ) {
				print( "Unable to delete (private) S3 bucket $s3Bucket ($rv)!  Sorry, you'll have to clean up after us.\n" );
			}
			exit( 3 );
		}
		$uploadedPasswordFile = TRUE;
		print( " done.\n" );
	}

	print( "Creating annex (stack)..." );
	createStack( $stackName, $centralManager, $keypairName, $duration, $setSize, $passwordLocation, $vpc, $subnets );
	print( " done.\n" );

	$createdS3Bucket = FALSE;
	$uploadedPasswordFile = FALSE;
}

# If the stack already exists and we're not changing its size, don't
# wait for the AutoScaling group.  Even if the stack already exists, we
# still need to wait for its AutoScaling Group to be created so we can
# obtain its name before we can adjust its size.
my $asgName = undef;
unless( $stackExists && (! defined( $setSize )) ) {
	print( "Waiting for annex's autoscaling group..." );
	$asgName = waitForAutoScalingGroupCreation( $stackName );
	print( " done.\n" );
}

# Set the stack size if we didn't just create the annex.
if( $stackExists && defined( $setSize ) ) {
	print( "Setting annex's desired size..." );
	setAutoScalingGroupDesiredSize( $asgName, $setSize );
	print( " done.\n" );
}

# Set the lease duration if we didn't just create the annex.
if( $stackExists && defined( $expiry ) ) {
	print( "Waiting for annex construction to finish..." );
	waitForStackComplete( $stackName );
	print( " done.\n" );

	print( "Setting annex's expiration..." );
	setAnnexLeaseDuration( $stackName, $duration );
	print( " done.\n" );
}

# Wait for the ASG's size to change.
if( defined( $setSize ) ) {
	print( "Waiting for annex to become size $setSize..." );
	my $asgSize = waitForAutoScalingGroupSize( $asgName );
	print( " done.\n" );
	if( $asgSize != $setSize ) {
		print( "Annex's desired size not the size you set.  Not sure what's going on here.\n" );
	}

	# Wait for the ASG nodes to show up in the pool.
	print( "Waiting for count of annex instances in pool to become $asgSize..." );
	waitForNodesInPool( $projectID, $asgSize );
	print( " done.\n" );
}

exit( 0 );

# -----------------------------------------------------------------------------

sub capture {
	my @command = @_;

	my $childFD;
	my $childPID = open( $childFD, "-|" );
	if(! defined( $childFD )) {
		print( "Unable to execute fork to execute '" . join( ' ', @command ) . "'.\n" );
		return ( -1, undef );
	}

	if( $childPID ) {
		my $size = 0;
		my $log = undef;
		my $read = 0;
		while( ($read = read( $childFD, $log, 1024, $size )) != 0 ) { $size += $read; }

		waitpid( $childPID, 0 );
		my $rv = $?;

		return ($rv, $log);
	} else {
		open( STDERR, '>&STDOUT' );
		exec( @command );
	}
}

sub captureCommand {
	my @command = @_;

	my $childFD;
	my $childPID = open( $childFD, '-|', @command );
	if( $childPID == 0 ) {
		print( "Unable to execute '" . join( ' ', @command ) . "', aborting.\n" );
		exit( 6 );
	}

	my $size = 0;
	my $output = undef;
	my $read = 0;
	while( ($read = read( $childFD, $output, 1024, $size )) != 0 ) { $size += $read; }

	waitpid( $childPID, 0 );
	if( $? != 0 ) {
		print( "Command '" . join( ' ', @command ) . "' failed ($?), aborting.\n" );
		exit( 7 );
	}
	close( $childFD );

	return $output;
}

sub stackExists {
	my( $stackName ) = @_;

	my @command = ( 'aws', 'cloudformation', 'describe-stacks' );
	my $output = captureCommand( @command );
	my $reply = decode_json( $output );

	my $stacks = $reply->{ 'Stacks' };
	foreach my $stack (@{$stacks}) {
		if( $stackName eq $stack->{ 'StackName' } ) { return TRUE; }
	}

	return FALSE;
}

sub createStack {
	my( $stackName, $centralManager, $keypairName, $duration, $size, $passwordLocation, $vpc, $subnets ) = @_;

	my @command = (
		'aws', 'cloudformation', 'create-stack',
		'--template-url', 'https://s3.amazonaws.com/htcondor-leased-autoscalinggroup/template-1',
		'--stack-name', $stackName,
    	'--capabilities', 'CAPABILITY_IAM',
		'--parameters', '[
            {
                "ParameterKey" : "CentralManager",
                "ParameterValue" : "' . $centralManager . '"
            },
            {
                "ParameterKey" : "SSHKeypairName",
                "ParameterValue" : "' . $keypairName . '"
            },
            {
                "ParameterKey" : "LeaseDuration",
                "ParameterValue" : "' . $duration . '"
            },
            {
                "ParameterKey" : "Size",
                "ParameterValue" : "' . $size . '"
            },
            {
            "ParameterKey" : "S3PoolPassword",
            "ParameterValue" : "' . $passwordLocation . '"
            },
            {
            "ParameterKey" : "ProjectID",
            "ParameterValue" : "' . $projectID . '"
			},
			{
			"ParameterKey" : "VPC",
			"ParameterValue" : "' . $vpc . '"
			},
			{
			"ParameterKey" : "VPCSubnets",
			"ParameterValue" : "' . $subnets . '"
			}
        ]' );

	my( $rv, $log ) = capture( @command );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to create CloudFormation stack ($rv), aborting.\n" );
		exit( 1 );
	}
}

sub waitForAutoScalingGroupCreation {
	my( $stackName ) = @_;

	my $asgName = undef;
	while( 1 ) {
		my @command = ( 'aws', 'cloudformation', 'describe-stack-resources',
			'--stack-name', $stackName );

		my $output = captureCommand( @command );

		my $reply = decode_json( $output );
		my $stackResources = $reply->{ 'StackResources' };
		foreach my $resource (@{$stackResources}) {
			if( $resource->{ 'ResourceType' } eq "AWS::AutoScaling::AutoScalingGroup" ) {
				if( $resource->{ 'ResourceStatus' } eq "CREATE_COMPLETE" || $resource->{ 'ResourceStatus' } eq "UPDATE_COMPLETE" ) {
					$asgName = $resource->{ 'PhysicalResourceId' };
					last;
				}
			}
		}

		if( defined( $asgName ) ) {
			last;
		} else {
			print( "." );
			sleep( 5 );
			next;
		}
	}

	return $asgName;
}

# Note that we update the size of the ASG directly, rather than going
# through the stack parameter 'size'.  We'll see if a user ever cares.
sub setAutoScalingGroupDesiredSize {
	my( $asgName, $size ) = @_;

	my @command = ( 'aws', 'autoscaling', 'update-auto-scaling-group',
		'--auto-scaling-group-name', $asgName,
		'--max-size', $size,
		'--desired-capacity', $size );
	my( $rv, $log ) = capture( @command );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to set annex to requested size, aborting.\n" );
		exit( 9 );
	}
}

sub waitForAutoScalingGroupSize {
	my( $asgName ) = @_;

	my $instanceCount = undef;
	my $lastInstanceCount = -1;

	while( 1 ) {
		# Does the extant ASG have all the instances it should?  Use the returned
		# value of DesiredCapacity rather than $size in case it changes during
		# the wait for some reason.  (Print out both at the end.)
		my @describeASGCommand = ( 'aws', 'autoscaling', 'describe-auto-scaling-groups',
			'--auto-scaling-group-names', $asgName );

		my $childFD;
		my $childPID = open( $childFD, '-|', @describeASGCommand );
		if( $childPID == 0 ) {
			print( "Unable to execute '" . join( ' ', @describeASGCommand ) . "', aborting.\n" );
			exit( 7 );
		}

		my $size = 0;
		my $output = undef;
		my $read = 0;
		while( ($read = read( $childFD, $output, 1024, $size )) != 0 ) { $size += $read; }

		waitpid( $childPID, 0 );
		if( $? != 0 ) {
			print( "Failed to describe the auto-scaling group ($?), aborting.\n" );
			exit( 8 );
		}
		close( $childFD );

		my $desiredCapacity = undef;
		my $reply = decode_json( $output );
		my $autoScalingGroups = $reply->{ 'AutoScalingGroups' };
		foreach my $autoScalingGroup (@{$autoScalingGroups}) {
			if( $autoScalingGroup->{ 'AutoScalingGroupName' } eq $asgName ) {
				$desiredCapacity = $autoScalingGroup->{ 'DesiredCapacity' };
				my $instances = $autoScalingGroup->{ 'Instances' };
				$instanceCount = scalar( @{$instances} );
				last;
			}
		}

		if( $instanceCount == $desiredCapacity ) {
			last;
		}

		if( $instanceCount != $lastInstanceCount ) {
			$lastInstanceCount = $instanceCount;
			print( " currently ${instanceCount}" );
		}

		print( "." );
		sleep( 5 );
	}

	return $instanceCount;
}

sub s3CleanupAndExit {
	print( "\n" );
	s3Cleanup();
	exit( 1 );
}

sub s3Cleanup {
	# $uploadedPasswordFile and $passwordLocation are globals.

	if( $uploadedPasswordFile ) {
		print( "Removing password file from S3 before exiting..." );
		my @s3DeleteKeyCommand = ( 'aws', 's3', 'rm', "s3://${passwordLocation}" );
		my( $rv, $log ) = capture( @s3DeleteKeyCommand );
		if( $rv != 0 ) {
			print( $log );
			print( "\n" );
			print( "Failed to delete password file (s3://${passwordLocation}) from S3 ($rv).  Sorry, you'll have to clean up after us.\n" );
			exit( 4 );
		}
		$uploadedPasswordFile = FALSE;
		print( " done.\n" );
	}

	# $createdS3Bucket and $passwordLocation are globals.
	if( $createdS3Bucket ) {
		print( "Deleting private S3 bucket before exiting..." );
		my ($rv, $log) = capture( 'aws', 's3api', 'delete-bucket', '--bucket', $s3Bucket );
		if( $rv != 0 ) {
			print( $log );
			print( "\n" );
			print( "Unable to delete (private) S3 bucket $s3Bucket ($rv)!  Sorry, you'll have to clean up after us.\n" );
			exit( 5 );
		}
		$createdS3Bucket = FALSE;
		print( " done.\n" );
	}
}

sub waitForNodesInPool {
	my( $projectID, $targetSize ) = @_;

	my $lastTotal = -1;
	while( 1 ) {
		my @statusCommand = (	'condor_status', '-const',
								'ProjectID == "' . $projectID . '"',
								'-af', 'Machine' );
		my( $rv, $log ) = capture( @statusCommand );
		if( $rv != 0 ) {
			print( "Unable to look for annex instances in the pool:\n" );
			print( $log . "\n" );
			print( "Aborting.\n" );
			exit( 1 );
		}

		my $total = undef;
		if( (! defined( $log )) || $log eq "" ) {
			$total = 0;
		} else {
			my %machines;
			my @lines = split( "\n", $log );
			foreach my $line (@lines) {
				$machines{ $line } = 1;
			}
			$total = scalar(keys %machines);
		}

		if( $total == $targetSize ) {
			last;
		}

		if( $total != $lastTotal ) {
			$lastTotal = $total;
			print( " currently ${total}" );
		}

		print( "." );
		sleep( 5 );
	}
}

# We don't poll until the stack has finished updating, although maybe we should.
sub setAnnexLeaseDuration {
	my( $stackName, $duration ) = @_;

	my @command = ( 'aws', 'cloudformation', 'update-stack',
		'--stack-name', $stackName,
		'--use-previous-template',
    	'--capabilities', 'CAPABILITY_IAM',
		'--parameters',
			'ParameterKey=Size,UsePreviousValue=true',
			'ParameterKey=CentralManager,UsePreviousValue=true',
			"ParameterKey=LeaseDuration,ParameterValue=${duration}",
			'ParameterKey=SSHKeypairName,UsePreviousValue=true',
			'ParameterKey=S3PoolPassword,UsePreviousValue=true',
			'ParameterKey=ProjectID,UsePreviousValue=true',
			'ParameterKey=VPC,UsePreviousValue=true',
			'ParameterKey=VPCSubnets,UsePreviousValue=true'
		);
	my( $rv, $log ) = capture( @command );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to set annex expiration, aborting.\n" );
		exit( 11 );
	}
}

sub waitForStackComplete {
	my( $stackName ) = @_;

	while( 1 ) {
		my @command = ( 'aws', 'cloudformation', 'describe-stacks', '--stack-name', $stackName );
		my $output = captureCommand( @command );
		my $reply = decode_json( $output );

		my $stacks = $reply->{ 'Stacks' };
		foreach my $stack (@{$stacks}) {
			if( $stackName eq $stack->{ 'StackName' } ) {
				my $status = $stack->{ 'StackStatus' };
				if( $status eq "CREATE_COMPLETE" || $status eq "UPDATE_COMPLETE" ) {
					return;
				}
			}
		}

		print( "." );
		sleep( 5 );
	}
}
