SRC_DIR = $(SRC_TREE)/condor_classad.V6

C_PLUS_FLAGS = -Wall -I./ $(STD_C_PLUS_FLAGS) -fno-implicit-templates
CFLAGS = -Wall $(STD_C_FLAGS)

SRC = lexer.C source.C operators.C attrrefs.C fnCall.C literals.C exprTree.C \
		classad.C exprList.C value.C instantiations.C sink.C domain.C \
		condorClassad.C

OBJ = lexer.o source.o operators.o attrrefs.o fnCall.o literals.o exprTree.o \
		classad.o exprList.o value.o instantiations.o sink.o domain.o \
		condorClassad.o

LIB =  ./libclassad.a ../condor_c++_util/cplus_lib.a \
      ../condor_util_lib/util_lib.a ../condor_io/libcondor.a \
      RpcLib SocketLib


# These are the objects required when compiling for stand alone classads
S_OBJ = $(S_UTL_OBJ) $(S_CPP_OBJ) $(S_LCL_OBJ) $(S_CDR_OBJ)
#if !HAS_FLOCK
S_UTL_OBJ = except.o dprintf.o uids.o condor_errlst.o escapes.o flock.o
#else
S_UTL_OBJ = except.o dprintf.o uids.o condor_errlst.o escapes.o 
#endif
S_CPP_OBJ = stringSpace.o instantiate.o 						
S_LCL_OBJ = stand_alone.o										
S_CDR_OBJ = buffers.o open_flags.o reli_sock.o sig_num.o fcntl_cmd.o \
	safe_sock.o sock.o stream.o


# condor classads
all_target(libclassad.a)
library_target(libclassad.a,$(OBJ))


# the classads expression interpreter
c_plus_target (cxi, cxi.o, $(LIB))
pure_c_plus_target(cxi.pure, cxi.o, $(LIB))


# standalone classads
standalone: libcasa.a
library_target(libcasa.a,$(OBJ) $(S_OBJ))


clean::
	rm -f *.o 


IMPORT_LINKS = ../../config/import_links
import( ../condor_util_lib/ , $(S_UTL_OBJ) )
import( ../condor_c++_util/ , $(S_CPP_OBJ) )
import( ../condor_io/ , $(S_CDR_OBJ) )
