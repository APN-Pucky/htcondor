/**@name ClassAd Distribution Documentation
The ClassAd Distribution consists of two components.
\begin{description}
	\item[The ClassAd Library.] The ClassAd Library defines objects and methods 
		for creating classads, parsing and unparsing classad expressions and 
		evaluating expressions.  The ClassAd Library is at a lower level of 
		abstraction than the Collection Library, and may be used independently.
	\item[The ClassAd Collection Library.] The ClassAd Collection Library 
		defines objects and methods for managing collections of classads.  Most 
		non-trivial application which use classads will find this library 
		useful.
\end{enumerate}

Please contact \URL[condor-admin]{mailto:condor-admin@cs.wisc.edu} for support.
*/
//@{
	/**@name ClassAd Library Classes
	The ClassAd Library consists of several classes.  The library user will
	find some classes more relevant than others.  To ease navigation
	of the documentation, we have divided the library classes into
	three categories, ranked on relevance to the user. 
	*/
	//@{
		/**@name Primary ClassAd Library Classes 
		These classes form the ``base'' level interface to the classad 
		library, and are therefore of primary importance for library users. */
		//@{
			//@Include: source.h
			//@Include: sink.h
			//@Include: classad.h
			//@Include: exprTree.h
			//@Include: value.h
			//@Include: matchClassad.h
		//@}

		/**@name Secondary ClassAd Library Classes 
		The following classes can be useful in some situations.
		*/
		//@{
			//@Include: exprList.h
			//@Include: classadItor.h
			//@Include: formatOptions.h
			//@Include: classad_io.h
		//@}

		/**@name Auxillary ClassAd Library Classes 
		The following classes are mostly unimportant to users.  There
		are some fairly esoteric situations when knowledge of these classes
		can be useful, but the documentation is included mostly for 
		completeness.
		*/
		//@{
			//@Include: attrrefs.h
			//@Include: fnCall.h
			//@Include: literals.h
			//@Include: operators.h
		//@}

		/**@name Enumerations of Interest
		*/
		//@{
			//@Include: common.h
		//@}

	//@}

	/**@name ClassAd Collection Classes
	All collection oriented operations (except iteration) are controlled
	through the ClassAdCollection class.  The class provides methods for
	creating and destroying various kinds of collections, ordering collections 
	through rank expressions and maintaining persistent classads with a 
	transactional model.  Iteration over collections is performed with 
	iterator objects.  
	*/
	//@{
		/**@name ClassAd Collection Class 
		ClassAd collections provide a powerful method for managing large
		numbers of classads.  The ClassAdCollection class may be thought of
		as a persistent ``bag'' of classads under which various kinds of 
		views (sub-collections) can be defined.

		Each ClassAdCollection object has a pre-defined collection with ID zero.
		This collection with ID zero is called the ``root'' collection.  New
		collections may be defined only as children of pre-existing collections.
		Thus, the collections defined in a ClassAdCollection object form a tree,
		and are directly or indirectly children of the root collection.  
		
		A child collection only defines a {\em view} over the parent collection,
		so the set of ads contained in a child collection is always a subset 
		of the ads contained in the parent collection.  Each collection has an
		associated rank expression (which is an expression from the classad
		language).  The rank expression is used to order classads in the 
		collection, so that iterating over the collection yeilds classads in
		ascending rank order.

		Two kinds of child collections may be defined from a parent.
		\begin{description}
			\item[Constraint Collections] Constraint collections define a 
			view over the parent collection by means of a predicate:  if a
			classad in the parent collection satisfies the predicate (i.e., the
			predicate evaluates to true), the classad will appear in the child
			collection.

			\item[Partition Collections] Partition collections are used to
			separate classads from the parent collection into distinct child
			collections.  Partitions are defined by specifying a vector of
			attribute names so that classads which share the same attributes 
			values over this vector are grouped into the same partition.  For
			example, if a partition is created over the vector <a> and
			classads [a=1; b=2], [a=2; b="blarch"], [a=1; b=-5] and [a="fuzz"]
			are inserted into the parent partition collection, three 
			child partitions will be created corresponding to the value 
			vectors <1>, <2> and <"fuzz"> respectively.  Child partitions are 
			dynamically created to accomodate new value vectors from new 
			classads.
			
			The partition ID of a particular child partition may be obtained by 
			calling the FindPartition method with the ID of the parent
			collection, and passing in a classad that can be used as a
			``representative'' of the child partition of interest.  I.e., the
			child partition corresponding to the value vector of the 
			representative classad is returned.
		\end{description}

		*/
		//@{
			//@Include: classad_collection.h
		//@}

		/**@name Iterator Classes 
		There are two kinds of iterator objects:  
		\begin{enumerate}
			\item {\bf collection child iterators}, which iterate over the 
				child collections of a collection, and 
			\item {\bf collection content iterators}, which iterate over the 
				classads present in a collection.
		\end{enumerate}

		ClassAd Collection iterators have a slightly complex iterator model
		to accomodate the dynamic bahavior of collections.  For example, 
		changing the attribute of a classad may cause the classad to reposition 
		itself in a collection (if the attribute is referred to in the Rank 
		expression of the collection), or even leave its current collection 
		altogether (if the attribute is being partitioned on).  It is very 
		difficult to know if an attribute change will affect a classad {\em a 
		priori}.
		
		The following iterator model has been developed so that iteration over 
		a collection can continue correctly in most cases even if a collection 
		changes when iterators over the collection are active.  Furthermore, 
		if there is a possibility that iteration cannot be correctly resumed, 
		the iterator sets warning flags which can be used to infer the reason 
		for the warning.  The iterator thus has a well-defined behavior in all 
		situations.  
		
		To allow successful iteration over such dynamic collections, each 
		iterator has some state associated it.  The state describes if the 
		iterator is OK (i.e., has been initialized and is currently pointing to 
		an item that can be accessed through the iterator) or if the iterator 
		is invalid (i.e., not initialized, or if the list/set being iterated 
		over was removed during iteration).  Additional flags associated with 
		the state indicate if items were added or removed from the set/list 
		being iterated over.  
		
		Changes to a collection with active iterators cause notifications to be
		sent to the iterators, which set flags, change state or even move
		depending on the situation.  If items are added or deleted to/from the
		collection, the appropriate warning flags are set in all active 
		iterators.  Furthermore, if the item being removed from the collection
		is being referred to by one or more active iterators, the iterators are
		moved to the next item to maintain their validity, and an additional 
		"iterator moved" flag will be set in each iterator.  The flags 
		associated with an iterator are reset when an accessor method of the 
		iterator is called.

		Although this method seems clumsy and complex, it provides an
		up-to-date view of the collection being iterated over, and does not
		sacrifice simplicity for the common case.

		For example, if the underlying collection does not change
		\begin{verbatim}
			ClassAdCollection 	coll;
			CollContentIterator itor;
			...
			if( !coll.InitializeIterator( CoID, itor ) ) {
				// error
			}
			while( itor.!itor.AtEnd( ) ) {
				// do something with itor.CurrentAdXXX functions
				...
				itor.Next( );
			}
		\end{verbatim}

		For a more involved example in which we check if the iterator has moved
		due to the dynamic nature of the collection, check the htb.C program 
		included in the examples directory of the distribution.

		*/
		//@{
		//@Include: classad_collection_types.h
		//@}
	//@}

//@}
