/************************************************************************
  Include settings/rules shared across all test Imakefile's
************************************************************************/
#include "Imakefile.common"

/* 
   If we're just doing "make all", the first thing we should do is
   build all the various lists we need (dealing with test classes,
   compiler subdirectories, etc), and do so in all the compiler  
   subdirectories.  This way, we can catch errors right away, and we
   get all that stuff out of the way early in the build.
*/
all_lists:: compiler_list
	@for X in `cat compiler_list` ; do \
	    make $$X/Makefile; \
	    cd $$X; make all_lists; cd ..; \
	done


/************************************************************************
   Shared settings/rules used by all tests in the top-level directory,
   and that deal with the testing build framework itself.
************************************************************************/

LD_DIR = -condor_ld_dir ../condor_scripts
LIB_DIR = -condor_lib ../condor_syscall_lib
INCLUDE_FLAGS = -I../condor_includes -I../h -I../condor_c++_util
BUILD_FLAGS = $(TESTSUITE_FLAGS_GCC)
CC = gcc
CPlusPlus = g++
CFLAGS  = $(BUILD_FLAGS) $(INCLUDE_FLAGS) -g 
C_PLUS_FLAGS  = $(CFLAGS)

/* the perl infrastructure for running tests lives in another
   directory, so we have to add sylinks for those */
all_symlink_target(../condor_scripts/Condor.pm,Condor.pm)
all_symlink_target(../condor_scripts/CondorTest.pm,CondorTest.pm)
all_symlink_target(../condor_scripts/CondorPersonal.pm,CondorPersonal.pm)
all_symlink_target(../condor_scripts/safe_append.pl,safe_append.pl)
all_symlink_target(../condor_scripts/batch_test.pl,batch_test.pl)

BUILD_DEP($(CC),x_return-n,c,x_waste_second.o)
BUILD($(CC),x_dumpcore,c)
BUILD($(CC),x_trapsig,c)

/************************************************************************
   Rules for all the single-compiler (or no compiler) tests
************************************************************************/

/* Library tests */

/* Chirp */

/* turn off until building/linking in NWO and workspace resolved
BUILD_DEP($(CC),lib_chirpio,c,../release_dir/lib/libchirp_client.a)
DESC(lib_chirpio_van,"Exercise the chirp I/O library using the C client library")
RUN(lib_chirpio_van)
TESTCLASS(lib_chirpio_van,lib)
*/

/* User log and log reader used by dagman tests */

/* NOTE: since we're linking these with external libraries, we need
the BUILD_DEP_LIB() rule, which provides maximum flexibility.  but, in
this case, we only need to specify libs, not dependent .o files, so we
leave the 4th argument empty...
*/

BUILD_DEP_LIB($(CPlusPlus),x_read_joblog,C,,../release_dir/lib/libcondorapi.a -ldl)
BUILD_DEP_LIB($(CPlusPlus),x_write_joblog,C,,../release_dir/lib/libcondorapi.a -ldl)

/* turn off until building/linking in NWO and workspace resolved
DESC(lib_userlog,"Exercise the userlog interface write and read all events");
RUN(lib_userlog)
TESTCLASS(lib_userlog,lib)
*/

/* Condor-C Tests */
/*
** Turn off till in v6_7-branch with Condor-C
**
**DESC(job_condorc_ab_van,"Condor-C AB test")
**RUN(job_condorc_ab_van)
**TESTCLASS(job_condorc_ab_van,condorc)
**
**DESC(job_condorc_abc_van,"Condor-C ABC test")
**RUN(job_condorc_abc_van)
**TESTCLASS(job_condorc_abc_van,condorc)
**
**DESC(job_core_streamout,"Vanilla: test for streaming of output when both stream_output is true and false")
**RUN(job_core_streamout_van)
**TESTCLASS(job_core_streamout_van,core)
**
*/

/* Tests I am challenged on.... */

/*
**
**DESC(job_core_killsignal_van,"Vanilla: Verify the specified input file is used")
**RUN(job_core_killsignal_van)
**TESTCLASS(job_core_killsignal_van,core)
**
**DESC(job_core_corefiles_van,"Vanillla limit of core file size - FAILS!")
**RUN(job_core_corefiles_van)
**TESTCLASS(job_core_corefiles_van,core)
**
**DESC(job_core_corefiles_sched,"Scheduler limit of core file size - FAILS!")
**RUN(job_core_corefiles_sched)
**TESTCLASS(job_core_corefiles_sched,core)
**
*/

/* Likely Bugs in Policy matters scheduler Universe */

/*
** 
** Leave Off for now
**
**DESC(job_core_onexitrem_sched,"Scheduler: Verify true and false triggers of on_exit_remove")
**RUN(job_core_onexitrem_sched)
**TESTCLASS(job_core_onexitrem_sched,core)
**
**DESC(job_core_perremove_sched,"Scheduler: test true/false variations of periodic remove")
**RUN(job_core_perremove_sched)
**TESTCLASS(job_core_perremove_sched,core)
**
**DESC(job_core_onexithold_sched,"Scheduler: Verify true and false triggers of on_exit_hold")
**RUN(job_core_onexithold_sched)
**TESTCLASS(job_core_onexithold_sched,core)
**
*/

/* Likely either test or condor is wrong */

/*
** 
** Leave Off for now
**
**DESC(job_core_args_van,"Vanilla: Did specify args from submit file reach the job?")
**RUN(job_core_args_van)
**TESTCLASS(job_core_args_van,core)
**
**DESC(job_core_args_sched,"scheduler: Did specify args from submit file reach the job?")
**RUN(job_core_args_sched)
**TESTCLASS(job_core_args_sched,core)
**
*/

/* Tests which fail in reliability */

/*
** These tests fail reliabably on Solaris 2.8 and 2.9
** because the transfer_output file(s) do not exist, and thus
** Condor tries to rerun the job forever.  Why it works on other
** platforms but always fails (in the NWO) on Solaris platforms
** is a mystery that Bill needs to solve.  :)
** 
** DESC(job_filexfer_basic_van,"Vanilla: send a file and get it back")
** RUN(job_filexfer_basic_van)
** TESTCLASS(job_filexfer_basic_van,filexfer)
** 
** DESC(job_filexfer_minus1_van,"Vanilla: extra specified output file creates shadow exception to rerun to produce missing output")
** RUN(job_filexfer_minus1_van)
** TESTCLASS(job_filexfer_minus1_van,filexfer)
** 
** DESC(job_filexfer_output-withvacate_van,"Vanilla: 3 files created before vacate - verify their return")
** RUN(job_filexfer_output-withvacate_van)
** TESTCLASS(job_filexfer_output-withvacate_van,filexfer)
** 
** DESC(job_filexfer_trans-nodflts_van,"Vanilla: all transfers explicitely off - complains...")
** RUN(job_filexfer_trans-nodflts_van)
** TESTCLASS(job_filexfer_trans-nodflts_van,filexfer)
** 
*/


/*
** 
** Leave Off for now
**
**DESC(job_macros-dollardollar_van,"Vanilla: Did dollar dollar macros work?")
**RUN(job_macros-dollardollar_van)
**TESTCLASS(job_macros-dollardollar_van,core)
**
**DESC(job_core_plus_sched,"Scheduler: Verify +entries go to job ad")
**RUN(job_core_plus_sched)
**TESTCLASS(job_core_plus_sched,core)
**
*/

/* Tests which fail in groups but run singly reliably */

/*
** 
** Leave Off for now
**
**DESC(job_core_rmkillsig_sched,"Scheduler: Verify the  remove_kill_sig")
**RUN(job_core_rmkillsig_sched)
**TESTCLASS(job_core_rmkillsig_sched,core)
**
**DESC(job_core_killsignal_sched,"Scheduler: Verify the specified input file is used")
**RUN(job_core_killsignal_sched)
**TESTCLASS(job_core_killsignal_sched,core)
**
**DESC(job_core_perhold_van,"Vanilla: verify true and false triggers for periodic hold")
**RUN(job_core_perhold_van)
**TESTCLASS(job_core_perhold_van,core)
**
**DESC(job_core_holdrelease_sched,"Scheduler: Test state changes from running to hold to release.")
**RUN(job_core_holdrelease_sched)
**TESTCLASS(job_core_holdrelease_sched,core)
**
**DESC(job_core_onexithold_van,"Vanilla: Verify true and false triggers of on_exit_hold")
**RUN(job_core_onexithold_van)
**TESTCLASS(job_core_onexithold_van,core)
**
**DESC(job_core_holdkillsig_sched,"Scheduler: Verify ability to control signal for holds and kills")
**RUN(job_core_holdkillsig_sched)
**TESTCLASS(job_core_holdkillsig_sched,core)
**
**DESC(job_core_matchlist_van,"Vanilla: test that match_list_length is storing and rotating matches")
**RUN(job_core_matchlist_van)
**TESTCLASS(job_core_matchlist_van,core)
**
**DESC(job_core_priority_van,"Vanilla: Verify respect for job priority")
**RUN(job_core_priority_van)
**TESTCLASS(job_core_priority_van,core)
**
**DESC(job_core_leaveinqueue_van,"Vanilla: verify true and false classads do leave_in_queue right")
**RUN(job_core_leaveinqueue_van)
**TESTCLASS(job_core_leaveinqueue_van,core)
**
**DESC(job_core_niceuser_van,"Vanilla: Ensure non nice_user job completes before nice_user job") 
**RUN(job_core_niceuser_van)
**TESTCLASS(job_core_niceuser_van,core)
**
*/


/* runable core coverage tests */

#if ! IS_CLIPPED
CBUILD($(CC),job_core_compressfiles,c)
DESC(job_core_compressfiles_std,"Do we handle compressed files made by standard jobs?")
DEPS(job_core_compressfiles_std,job_core_compressfiles.cndr.exe)
RUN(job_core_compressfiles_std)
TESTCLASS(job_core_compressfiles_std,core)
#endif /* ! IS_CLIPPED */

/* Test needs work as there seems to be a timing influence
** and first size of streaming file is not smaller as it should be
DESC(job_core_streamerr_van,"Vanilla: test for streaming of error when both stream_error is true and false")
RUN(job_core_streamerr_van)
TESTCLASS(job_core_streamerr_van,core)
*/

DESC(job_core_copytospool_van,"Vanilla: test that spooled executable is same via md5 checksum of both files")
RUN(job_core_copytospool_van)
TESTCLASS(job_core_copytospool_van,core)

DESC(job_core_getenv_van,"Vanilla: job which tests getenv both on and off")
RUN(job_core_getenv_van)
TESTCLASS(job_core_getenv_van,core)

DESC(job_core_doublejeopardy_van,"Vanilla: make sure condor does not generate an abort AND the expected abnormal termination.")
RUN(job_core_doublejeopardy_van)
TESTCLASS(job_core_doublejeopardy_van,core)

DESC(job_core_doublejeopardy_sched,"Scheduler: make sure condor does not generate an abort AND the expected abnormal termination.")
RUN(job_core_doublejeopardy_sched)
TESTCLASS(job_core_doublejeopardy_sched,core)

DESC(job_core_env_sched,"Scheduler: Does environment get to the job")
RUN(job_core_env_sched)
TESTCLASS(job_core_env_sched,core)

DESC(job_core_env_van,"Vanilla: Does environment get to the job")
RUN(job_core_env_van)
TESTCLASS(job_core_env_van,core)

DESC(job_core_err_sched,"Scheduler: Does requested error file get used?")
RUN(job_core_err_sched)
TESTCLASS(job_core_err_sched,core)

DESC(job_core_err_van,"Vanilla: Does requested error file get used?")
RUN(job_core_err_van)
TESTCLASS(job_core_err_van,core)

DESC(job_core_hold_sched,"Scheduler: job is told to begin on hold. So we test for that state when we get the submitted event")
RUN(job_core_hold_sched)
TESTCLASS(job_core_hold_sched,core)

DESC(job_core_hold_van,"Vanilla: job is told to begin on hold. So we test for that state when we get the submitted event")
RUN(job_core_hold_van)
TESTCLASS(job_core_hold_van,core)

DESC(job_core_holdrelease_van,"Vanilla: Test state changes from running to hold to release.")
RUN(job_core_holdrelease_van)
TESTCLASS(job_core_holdrelease_van,core)

DESC(job_core_initialdir_sched,"Scheduler: We change the initialdir and assure log and stuff goes there")
RUN(job_core_initialdir_sched)
TESTCLASS(job_core_initialdir_sched,core)

DESC(job_core_initialdir_van,"Vanilla: We change the initialdir and assure log and stuff goes there")
RUN(job_core_initialdir_van)
TESTCLASS(job_core_initialdir_van,core)

DESC(job_core_input_sched,"Scheduler: Verify the specified input file is used")
RUN(job_core_input_sched)
TESTCLASS(job_core_input_sched,core)

DESC(job_core_input_van,"Vanilla: Verify the specified input file is used")
RUN(job_core_input_van)
TESTCLASS(job_core_input_van,core)

DESC(job_core_leaveinqueue_sched,"Scheduler: verify true and false classads do leave_in_queue right")
RUN(job_core_leaveinqueue_sched)
TESTCLASS(job_core_leaveinqueue_sched,core)

DESC(job_core_macros_sched,"Scheduler: a number of macros get passed in as args") 
RUN(job_core_macros_sched)
TESTCLASS(job_core_macros_sched,core)

DESC(job_core_onexitrem_van,"Vanilla: Verify true and false triggers of on_exit_remove")
RUN(job_core_onexitrem_van)
TESTCLASS(job_core_onexitrem_van,core)

DESC(job_core_output_sched,"Scheduler: Verify trivially simple output from an input file")
RUN(job_core_output_sched)
TESTCLASS(job_core_output_sched,core)

DESC(job_core_output_van,"Vanilla: Verify trivially simple output from an input file")
RUN(job_core_output_van)
TESTCLASS(job_core_output_van,core)

/* manual says we do not support this for scheduler universe
** yet it seemed to have run and worked on rh8 but fail on rh 7.2 & 9.0
DESC(job_core_perhold_sched,"Scheduler: verify true and false triggers for periodic hold")
RUN(job_core_perhold_sched)
TESTCLASS(job_core_perhold_sched,core)
*/

DESC(job_core_perrelease_sched,"Scheduler: verify a policy of true/false for periodic release does the right thing")
RUN(job_core_perrelease_sched)
TESTCLASS(job_core_perrelease_sched,core)

DESC(job_core_perrelease_van,"Vanilla: verify a policy of true/false for periodic release does the right thing")
RUN(job_core_perrelease_van)
TESTCLASS(job_core_perrelease_van,core)

DESC(job_core_perremove_van,"Vanilla: test true/false variations of periodic remove")
RUN(job_core_perremove_van)
TESTCLASS(job_core_perremove_van,core)

DESC(job_core_plus_van,"Vanilla: Verify +entries go to job ad")
RUN(job_core_plus_van)
TESTCLASS(job_core_plus_van,core)

DESC(job_core_priority_sched,"Scheduler: Verify respect for job priority")
RUN(job_core_priority_sched)
TESTCLASS(job_core_priority_sched,core)

DESC(job_core_queue_sched,"Scheduler: Verify the  queue command")
RUN(job_core_queue_sched)
TESTCLASS(job_core_queue_sched,core)

/* File Transfer Tests */

DESC(job_filexfer_base-input1_van,"Vanilla: Tests input file does not make it with filetransfer off")
RUN(job_filexfer_base-input1_van)
TESTCLASS(job_filexfer_base-input1_van,filexfer)

DESC(job_filexfer_base-input4_van,"Vanilla: Verifies submit fails with input list and with filetransfer off")
RUN(job_filexfer_base-input4_van)
TESTCLASS(job_filexfer_base-input4_van,filexfer)

DESC(job_filexfer_base_van,"Vanilla: Is executable moved correctly to initialdir/sandbox?")
RUN(job_filexfer_base_van)
TESTCLASS(job_filexfer_base_van,filexfer)

/* On solaris we run into /bin/cp not having and arg 0 which matches
** solaris expectation so it fails...
**DESC(job_filexfer_basic_sched,"Scheduler: exercise of file transfer via cp in to out")
**RUN(job_filexfer_basic_sched)
**TESTCLASS(job_filexfer_basic_sched,filexfer)
*/

DESC(job_filexfer_input-onegone_van,"Vanilla: test for failure when specified input file is missing")
RUN(job_filexfer_input-onegone_van)
TESTCLASS(job_filexfer_input-onegone_van,filexfer)

DESC(job_filexfer_limitback_van,"Vanilla: ask for exactly 2 files returned")
RUN(job_filexfer_limitback_van)
TESTCLASS(job_filexfer_limitback_van,filexfer)

DESC(job_filexfer_trans-excut-true_van,"Vanilla: explicitely set transfer_executable... test complains")
RUN(job_filexfer_trans-excut-true_van)
TESTCLASS(job_filexfer_trans-excut-true_van,filexfer)

DESC(job_filexfer_whento-base_van,"Vanilla: Inputless test of a job running with transfer files enabled.")
RUN(job_filexfer_whento-base_van)
TESTCLASS(job_filexfer_whento-base_van,filexfer)

DESC(job_filexfer_whento-simpleinput_van,"Vanilla: job runs with input file requested")
RUN(job_filexfer_whento-simpleinput_van)
TESTCLASS(job_filexfer_whento-simpleinput_van,filexfer)

DESC(job_filexfer_whento-withinput_van,"Vanilla: Multiple input files arrive ok")
RUN(job_filexfer_whento-withinput_van)
TESTCLASS(job_filexfer_whento-withinput_van,filexfer)

DESC(job_filexfer_output_van,"Vanilla: Are 6 output files returned")
RUN(job_filexfer_output_van)
TESTCLASS(job_filexfer_output_van,filexfer)

DESC(job_filexfer_md5_van,"Vanilla: Can we move 200 megs and not impact md5 checksum?")
RUN(job_filexfer_md5_van)
TESTCLASS(job_filexfer_md5_van,filexfer)

/* Dagman Tests */

DESC(job_dagman_comlog,"Run a dag with multiple nodes sharing a common log")
DEPS(job_dagman_comlog,x_read_joblog.exe)
RUN(job_dagman_comlog)
TESTCLASS(job_dagman_comlog,dagman)

DESC(job_dagman_fullremove,"Ensure a removed dag is completely removed")
DEPS(job_dagman_fullremove,x_read_joblog.exe)
RUN(job_dagman_fullremove)
TESTCLASS(job_dagman_fullremove,dagman)

DESC(job_dagman_basic,"Basic one node dag")
RUN(job_dagman_basic)
TESTCLASS(job_dagman_basic,dagman)

DESC(job_dagman_maxpostscripts,"Check that throttling by post scripts works")
RUN(job_dagman_maxpostscripts)
TESTCLASS(job_dagman_maxpostscripts,dagman)

DESC(job_dagman_maxprescripts,"Check that throttling by pre scripts works")
RUN(job_dagman_maxprescripts)
TESTCLASS(job_dagman_maxprescripts,dagman)

DESC(job_dagman_prepost,"Run a dag and verify each nodes pre and post scripts ran")
RUN(job_dagman_prepost)
TESTCLASS(job_dagman_prepost,dagman)

DESC(job_dagman_retry,"Make sure a retry dag runs correctly.")
DEPS(job_dagman_retry,x_read_joblog.exe)
RUN(job_dagman_retry)
TESTCLASS(job_dagman_retry,dagman)

DESC(job_dagman_throttle,"Test Dagman throttling ability")
DEPS(job_dagman_throttle,x_read_joblog.exe)
RUN(job_dagman_throttle)
TESTCLASS(job_dagman_throttle,dagman)

DESC(job_dagman_uncomlog,"Test Dagmans ability to have sepaarate job log files")
DEPS(job_dagman_uncomlog,x_read_joblog.exe)
RUN(job_dagman_uncomlog)
TESTCLASS(job_dagman_uncomlog,dagman)

/* Valid starting v6_7 branch......
DESC(job_dagman_unlessexit,"Test that the retries can be stopped with particular exit values from node.")
DEPS(job_dagman_unlessexit,x_read_joblog.exe)
RUN(job_dagman_unlessexit)
TESTCLASS(job_dagman_unlessexit,dagman)
*/

DESC(job_dagman_xmlcomlog,"Look at Dagmans ability to handle a common XML based log file")
RUN(job_dagman_xmlcomlog)
TESTCLASS(job_dagman_xmlcomlog,dagman)

DESC(job_dagman_xmluncomlog,"Look at Dagmans ability to handle uncommon XML based log files")
RUN(job_dagman_xmluncomlog)
TESTCLASS(job_dagman_xmluncomlog,dagman)

/* Sample performance tests */

/*
** Turn off for now.
**
**DESC(perf_busy_lynn_100_100_500_sched,"Generated cpu loading performance test\n");
**RUN(perf_busy_lynn_100_100_500_sched)
**TESTCLASS(perf_busy_lynn_100_100_500_sched,performance)
**TESTCLASS(perf_busy_lynn_100_100_500_sched,long)
**
**DESC(perf_jobs_sue_10_10_30_van,"Generated jobs performance test\n");
**RUN(perf_jobs_sue_10_10_30_van)
**TESTCLASS(perf_jobs_sue_10_10_30_van,performance)
**TESTCLASS(perf_jobs_sue_10_10_30_van,long)
**
**DESC(perf_xfer_deb_10_10_30_van,"Generated transfer performance test\n");
**RUN(perf_xfer_deb_10_10_30_van)
**TESTCLASS(perf_xfer_deb_10_10_30_van,performance)
**TESTCLASS(perf_xfer_deb_10_10_30_van,long)
**
*/

/* Initial top level tests */

DESC(job_filexfer_sandbox-empty_van,"Are job sandboxes with bad permissions cleaned up?")
RUN(job_filexfer_sandbox-empty_van)
TESTCLASS(job_filexfer_sandbox-empty_van,quick)

DESC(job_core_sh-loop_van,"Simple vanilla job that loops for N seconds")
RUN(job_core_sh-loop_van)
TESTCLASS(job_core_sh-loop_van,quick)

BUILD($(CC),job_core_bigenv,c)
DESC(job_core_bigenv_van,"Vanilla test for enormous environment")
DEPS(job_core_bigenv_van,job_core_bigenv.exe)
RUN(job_core_bigenv_van)
TESTCLASS(job_core_bigenv_van,env)
TESTCLASS(job_core_bigenv_van,quick)

DESC(job_core_bigenv_sched,"Scheduler test for enormous environment")
DEPS(job_core_bigenv_sched,job_core_bigenv.exe)
RUN(job_core_bigenv_sched)
TESTCLASS(job_core_bigenv_sched,env)

/* NOTE: we want this test in the top-level, even though we're linking
   it for standard universe, since we really don't care about
   different compilers for this one... we just need to see how the
   starter/shadow behave when we drop a core file
*/
CBUILD($(CC),job_core_coredump,c)
#if ! IS_CLIPPED
DESC(job_core_coredump_std,"Do we handle core files made by standard jobs?")
DEPS(job_core_coredump_std,job_core_coredump.cndr.exe)
RUN(job_core_coredump_std)
TESTCLASS(job_core_coredump_std,quick)
#endif /* ! IS_CLIPPED */
/* This test fails constantly and is off for now
**DESC(job_core_coredump_van,"Do we handle core files made by vanilla jobs?")
**DEPS(job_core_coredump_van,job_core_coredump.exe)
**RUN(job_core_coredump_van)
**TESTCLASS(job_core_coredump_van,quick)
*/


/************************************************************************
   Settings specific to compiler-specific subdirectories
************************************************************************/

#if ! IS_CLIPPED 

all:: compiler_list

#if HAS_FORTRAN

#if HAS_GNU_G77
/* g77 never has recursion */
F_COMPILER_TARGET(g77,$(GNU_G77),TESTSUITE_FLAGS_G77,0)
#endif

#if HAS_VENDOR_F77
#if FORTRAN_HAS_RECURSION
F_COMPILER_TARGET(f77,$(VENDOR_F77),TESTSUITE_FLAGS_F77,1)
#else 
F_COMPILER_TARGET(f77,$(VENDOR_F77),TESTSUITE_FLAGS_F77,0)
#endif /* FORTRAN_HAS_RECURSION */
#endif /* HAS_VENDOR_F77 */

#if HAS_VENDOR_F90
F_COMPILER_TARGET(f90,$(VENDOR_F90),TESTSUITE_FLAGS_F77,0)
#endif

#endif /* HAS_FORTRAN */

/* We always want to build the test suite with gcc and g++ */
C_COMPILER_TARGET(gcc,gcc,TESTSUITE_FLAGS_GCC)

CPP_COMPILER_TARGET(g++,g++,TESTSUITE_FLAGS_GPP)

/* now, let's see if we've got any vendor compilers */
#if HAS_VENDOR_CC
C_COMPILER_TARGET(cc,$(VENDOR_CC),TESTSUITE_FLAGS_CC)
#endif

#if HAS_VENDOR_CPLUS
CPP_COMPILER_TARGET($(VENDOR_CPLUS_NAME),$(VENDOR_CPLUS),TESTSUITE_FLAGS_CPP)
#endif

#else /* IS_CLIPPED */

compiler_list:
	touch compiler_list

#endif /* ! IS_CLIPPED */


/***********************************************************************
   Empty rules to make our top-level Imakefile happy
************************************************************************/

html:
release::
stripped::
static::
clean::

