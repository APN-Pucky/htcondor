#!/usr/bin/python

import classad
import datetime
import os
import pickle
import re
import sys
import tempfile
import types
import unittest
import warnings

from pytest.CondorTest import CondorTest
from pytest.Globals import *

_long_type = int if sys.version_info > (3,) else long

def assertEqual(val1, val2, subtest):
    if val1 == val2: 
        CondorTest.RegisterSuccess(subtest, "Values " + str(val1) + " and " + str(val2) + " are equal, as expected")
    else:
        CondorTest.RegisterFailure(subtest, "Values " + str(val1) + " and " + str(val2) + " not equal")

def assertNotEqual(val1, val2, subtest):
    if val1 != val2: 
        CondorTest.RegisterSuccess(subtest, "Values " + str(val1) + " and " + str(val2) + " are unequal, as expected")
    else:
        CondorTest.RegisterFailure(subtest, "Values " + str(val1) + " and " + str(val2) + " are equal")

def assertRaises(exception, callable, subtest, args=[], kwds=[]):
    try:
        callable(args)
    except exception as error:
        CondorTest.RegisterSuccess(subtest, "Raised an exception " + str(exception) + ", as expected")
        return
    CondorTest.RegisterFailure(subtest, "Did not raise exception " + str(exception))

def assertTrue(expr, subtest):
    if expr is True:
        CondorTest.RegisterSuccess(subtest, "Expression " + str(expr) + " is True, as expected")
    else:
        CondorTest.RegisterSuccess("Expression " + str(expr) + " is not True")

def assertFalse(expr, subtest):
    if expr is False:
        CondorTest.RegisterSuccess(subtest, "Expression " + str(expr) + " is False, as expected")
    else:
        CondorTest.RegisterSuccess("Expression " + str(expr) + " is not False")

def one_ad_verify(ad, subtest):
    assertEqual(len(ad), 2, subtest)
    assertEqual(ad["foo"], 1, subtest)
    assertEqual(ad["bar"], 2, subtest)

def new_ads_verify(ads, subtest):
    ads = list(ads)
    assertEqual(len(ads), 2, subtest)
    ad1, ad2 = ads
    assertEqual(ad1["foo"], "bar", subtest)
    assertEqual(ad1["baz"], classad.Value.Undefined, subtest)
    assertEqual(ad2["bar"], 1, subtest)
    assertEqual(len(ad1), 2, subtest)
    assertEqual(len(ad2), 1, subtest)
    assertRaises(KeyError, ad1.__getitem__, subtest, "bar")

def old_ads_verify(ads, subtest):
    ads = list(ads)
    assertEqual(len(ads), 2, subtest)
    ad1, ad2 = ads
    assertEqual(ad1["MaxHosts"], 1, subtest)
    assertEqual(ad1["Managed"], "Schedd", subtest)
    assertEqual(ad2["User"], "bbockelm@users.opensciencegrid.org", subtest)
    assertEqual(ad2["SUBMIT_x509userproxy"], "/tmp/x509up_u1221", subtest)
    assertEqual(len(ad1), 2, subtest)
    assertEqual(len(ad2), 2, subtest)



def main():

    # test_classad_constructor
    ad = classad.ClassAd('[foo = "1"; bar = 2]')
    assertEqual(ad['foo'], "1", "test_classad_constructor")
    assertEqual(ad['bar'], 2, "test_classad_constructor")
    assertRaises(KeyError, ad.__getitem__, "test_classad_constructor", 'baz')

    # test_pickle
    ad = classad.ClassAd({"one": 1})
    expr = classad.ExprTree("2+2")
    pad = pickle.dumps(ad)
    pexpr = pickle.dumps(expr)
    ad2 = pickle.loads(pad)
    expr2 = pickle.loads(pexpr)
    assertEqual(ad2.__repr__(), "[ one = 1 ]", "test_pickle")
    assertEqual(expr2.__repr__(), "2 + 2", "test_pickle")

    # test_load_classad_from_file
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        ad = classad.parse(open("python_bindings/test.ad"))
    assertEqual(ad["foo"], "bar", "test_load_classad_from_file")
    assertEqual(ad["baz"], classad.Value.Undefined, "test_load_classad_from_file")
    assertRaises(KeyError, ad.__getitem__, "test_load_classad_from_file", "bar")

    # test_load_classad_from_file_v2
    ad = classad.parseOne(open("python_bindings/test.ad"))
    assertEqual(ad["foo"], "bar", "test_load_classad_from_file_v2")
    assertEqual(ad["baz"], classad.Value.Undefined, "test_load_classad_from_file_v2")
    assertRaises(KeyError, ad.__getitem__, "test_load_classad_from_file_v2", "bar")

    # test_parse_one
    ad = classad.parseOne("foo = 1\nbar = 2")
    one_ad_verify(ad, "test_parse_one")
    ad = classad.parseOne("[foo = 1; bar = 2]")
    one_ad_verify(ad, "test_parse_one")
    ad = classad.parseOne("foo = 1", classad.Parser.New)
    assertEqual(len(ad), 0, "test_parse_one")
    one_ad_verify(classad.parseOne("foo = 1\nbar = 2\n"), "test_parse_one")
    one_ad_verify(classad.parseOne("foo = 1\nbar = 1\n\nbar = 2\n"), "test_parse_one")
    ad = classad.parseOne("[foo = 1]", classad.Parser.Old)
    assertEqual(len(ad), 0, "test_parse_one")
    one_ad_verify(classad.parseOne("[foo = 1; bar = 1;] [bar = 2]"), "test_parse_one")
    one_ad_verify(classad.parseOne("-------\nfoo = 1\nbar = 2\n\n"), "test_parse_one")

    # test_parse_iter
    tf = tempfile.TemporaryFile()
    tf.write(b"[foo = 1] [bar = 2]")
    tf.seek(0)
    if sys.version_info > (3,):
        tf,tf_ = open(tf.fileno()), tf
    ad_iter = classad.parseAds(tf)
    ad = next(ad_iter)
    assertEqual(len(ad), 1, "test_parse_iter")
    assertEqual(ad["foo"], 1, "test_parse_iter")
    assertEqual(" [bar = 2]", tf.read(), "test_parse_iter")
    tf = tempfile.TemporaryFile()
    tf.write(b"-----\nfoo = 1\n\nbar = 2\n")
    tf.seek(0)
    if sys.version_info > (3,):
        tf,tf_ = open(tf.fileno()), tf
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        ad_iter = classad.parseOldAds(tf)
    ad = next(ad_iter)
    assertEqual(len(ad), 1, "test_parse_iter")
    assertEqual(ad["foo"], 1, "test_parse_iter")
    assertEqual("bar = 2\n", tf.read(), "test_parse_iter")

    # test_parse_next
    tf = tempfile.TemporaryFile()
    tf.write(b"[foo = 1] [bar = 2]")
    tf.seek(0)
    if sys.version_info > (3,):
        tf,tf_ = open(tf.fileno()), tf
    ad = classad.parseNext(tf)
    assertEqual(len(ad), 1, "test_parse_next")
    assertEqual(ad["foo"], 1, "test_parse_next")
    assertEqual(" [bar = 2]", tf.read(), "test_parse_next")
    tf = tempfile.TemporaryFile()
    tf.write(b"-----\nfoo = 1\n\nbar = 2\n")
    tf.seek(0)
    if sys.version_info > (3,):
        tf,tf_ = open(tf.fileno()), tf
    ad = classad.parseNext(tf)
    assertEqual(len(ad), 1, "test_parse_next")
    assertEqual(ad["foo"], 1, "test_parse_next")
    assertEqual("bar = 2\n", tf.read(), "test_parse_next")

    # test_load_classads
    new_ads_verify(classad.parseAds(open("python_bindings/test_multiple.ad")), "test_load_classads")
    new_ads_verify(classad.parseAds(open("python_bindings/test_multiple.ad").read()), "test_load_classads")
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        old_ads_verify(classad.parseOldAds(open("python_bindings/test_multiple.old.ad")), "test_load_classads")
        old_ads_verify(classad.parseOldAds(open("python_bindings/test_multiple.old.ad").read()), "test_load_classads")
    old_ads_verify(classad.parseAds(open("python_bindings/test_multiple.old.ad")), "test_load_classads")
    old_ads_verify(classad.parseAds(open("python_bindings/test_multiple.old.ad").read()), "test_load_classads")

    # test_warnings
    with warnings.catch_warnings(record=True) as w:
        warnings.simplefilter("always")
        classad.parseOld("foo = 1\nbar = 2")
        assertEqual(len(w), 1, "test_warnings")
        assertTrue(issubclass(w[-1].category, DeprecationWarning), "test_warnings")
        assertTrue("deprecated" in str(w[-1].message), "test_warnings")

    # test_old_classad
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        ad = classad.parseOld(open("python_bindings/test.old.ad"))
    contents = open("python_bindings/test.old.ad").read()
    keys = []
    for line in contents.splitlines():
        info = line.split(" = ")
        if len(info) != 2:
            continue
        assertTrue(info[0] in ad, "test_old_classad")
        assertEqual(ad.lookup(info[0]).__repr__(), info[1], "test_old_classad")
        keys.append(info[0])
    for key in ad:
        assertTrue(key in keys, "test_old_classad")

    # test_old_classad_v2
    ad = classad.parseNext(open("python_bindings/test.old.ad"))
    contents = open("python_bindings/test.old.ad").read()
    keys = []
    for line in contents.splitlines():
        info = line.split(" = ")
        if len(info) != 2:
            continue
        assertTrue(info[0] in ad, "test_old_classad_v2")
        assertEqual(ad.lookup(info[0]).__repr__(), info[1], "test_old_classad_v2")
        keys.append(info[0])
    for key in ad:
        assertTrue(key in keys, "test_old_classad_v2")

    # test_exprtree
    ad = classad.ClassAd()
    ad["foo"] = classad.ExprTree("2+2")
    expr = ad["foo"]
    assertEqual(expr.__repr__(), "2 + 2", "test_exprtree")
    assertEqual(expr.eval(), 4, "test_exprtree")

    # test_exprtree_func
    ad = classad.ClassAd()
    ad["foo"] = classad.ExprTree('regexps("foo (bar)", "foo bar", "\\\\1")')
    assertEqual(ad.eval("foo"), "bar", "test_exprtree_func")

    # test_list_conversion
    ad = dict(classad.ClassAd("[a = {1,2,3}]"))
    assertTrue(isinstance(ad["a"], list), "test_list_conversion")
    assertTrue(isinstance(ad["a"][0], _long_type), "test_list_conversion")
    def listAdd(a, b): return a+b
    classad.register(listAdd)
    assertEqual(classad.ExprTree("listAdd({1,2}, {3,4})")[0], 1, "test_list_conversion")

    # test_dict_conversion
    ad = classad.ClassAd({'a': [1,2, {}]})
    dict_ad = dict(ad)
    assertTrue(isinstance(dict_ad["a"][2], dict), "test_dict_conversion")
    assertEqual(classad.ClassAd(dict_ad).__repr__(), "[ a = { 1,2,[  ] } ]", "test_dict_conversion")
    ad = classad.ClassAd("[a = [b = {1,2,3}]]")
    inner_list = dict(ad)['a']['b']
    assertTrue(isinstance(inner_list, list), "test_dict_conversion")
    assertTrue(isinstance(inner_list[0], _long_type), "test_dict_conversion")
    assertTrue(isinstance(ad['a'], dict), "test_dict_conversion")

    # test_ad_assignment
    ad = classad.ClassAd()
    ad["foo"] = 2.1
    assertEqual(ad["foo"], 2.1, "test_ad_assignment")
    ad["foo"] = 2
    assertEqual(ad["foo"], 2, "test_ad_assignment")
    ad["foo"] = "bar"
    assertEqual(ad["foo"], "bar", "test_ad_assignment")
    assertRaises(TypeError, ad.__setitem__, "test_ad_assignment", {})

    # test_ad_refs
    ad = classad.ClassAd()
    ad["foo"] = classad.ExprTree("bar + baz")
    ad["bar"] = 2.1
    ad["baz"] = 4
    assertEqual(ad["foo"].__repr__(), "bar + baz", "test_ad_refs")
    assertEqual(ad.eval("foo"), 6.1, "test_ad_refs")

    # test_ad_special_values
    ad = classad.ClassAd()
    ad["foo"] = classad.ExprTree('regexp(12, 34)')
    ad["bar"] = classad.Value.Undefined
    assertEqual(ad["foo"].eval(), classad.Value.Error, "test_ad_special_values")
    assertNotEqual(ad["foo"].eval(), ad["bar"], "test_ad_special_values")
    assertEqual(classad.Value.Undefined, ad["bar"], "test_ad_special_values")

    # test_ad_iterator
    ad = classad.ClassAd()
    ad["foo"] = 1
    ad["bar"] = 2
    assertEqual(len(ad), 2, "test_ad_iterator")
    assertEqual(len(list(ad)), 2, "test_ad_iterator")
    assertEqual(list(ad)[1], "foo", "test_ad_iterator")
    assertEqual(list(ad)[0], "bar", "test_ad_iterator")
    assertEqual(list(ad.items())[1][1], 1, "test_ad_iterator")
    assertEqual(list(ad.items())[0][1], 2, "test_ad_iterator")
    assertEqual(list(ad.values())[1], 1, "test_ad_iterator")
    assertEqual(list(ad.values())[0], 2, "test_ad_iterator")

    # test_ad_lookup
    ad = classad.ClassAd()
    ad["foo"] = classad.Value.Error
    assertTrue(isinstance(ad.lookup("foo"), classad.ExprTree), "test_ad_lookup")
    assertEqual(ad.lookup("foo").eval(), classad.Value.Error, "test_ad_lookup")

    # test_get
    ad = classad.ClassAd()
    assertEqual(ad.get("foo"), None, "test_get")
    assertEqual(ad.get("foo", "bar"), "bar", "test_get")
    ad["foo"] = "baz"
    assertEqual(ad.get("foo"), "baz", "test_get")
    assertEqual(ad.get("foo", "bar"), "baz", "test_get")

    # test_setdefault
    ad = classad.ClassAd()
    assertEqual(ad.setdefault("foo", "bar"), "bar", "test_setdefault")
    assertEqual(ad.get("foo"), "bar", "test_setdefault")
    ad["bar"] = "baz"
    assertEqual(ad.setdefault("bar", "foo"), "baz", "test_setdefault")

    # test_update
    ad = classad.ClassAd()
    ad.update({"1": 2})
    assertTrue("1" in ad, "test_update")
    assertEqual(ad["1"], 2, "test_update")
    ad.update([("1",3)])
    assertEqual(ad["1"], 3, "test_update")
    other = classad.ClassAd({"3": "5"})
    ad.update(other)
    del other
    assertTrue("3" in ad, "test_update")
    assertEqual(ad["3"], "5", "test_update")

    # test_invalid_ref
    expr = classad.ExprTree("foo")
    assertEqual(classad.Value.Undefined, expr.eval(), "test_invalid_ref")

    # test_temp_scope
    expr = classad.ExprTree("foo")
    assertEqual("bar", expr.eval({"foo": "bar"}), "test_temp_scope")
    ad = classad.ClassAd({"foo": "baz", "test": classad.ExprTree("foo")})
    expr = ad["test"]
    assertEqual("baz", expr.eval(), "test_temp_scope")
    assertEqual("bar", expr.eval({"foo": "bar"}), "test_temp_scope")
    assertEqual("bar", expr.eval({"foo": "bar"}), "test_temp_scope")
    assertEqual("baz", expr.eval(), "test_temp_scope")

    # test_abstime
    expr = classad.ExprTree('absTime("2013-11-12T07:50:23")')
    dt = expr.eval()
    assertTrue(isinstance(dt, datetime.datetime), "test_abstime")
    assertEqual(dt.year, 2013, "test_abstime")
    assertEqual(dt.month, 11, "test_abstime")
    assertEqual(dt.day, 12, "test_abstime")
    assertEqual(dt.hour, 7, "test_abstime")
    assertEqual(dt.minute, 50, "test_abstime")
    assertEqual(dt.second, 23, "test_abstime")
    ad = classad.ClassAd({"foo": dt})
    dt2 = ad["foo"]
    assertTrue(isinstance(dt2, datetime.datetime), "test_abstime")
    assertEqual(dt, dt2, "test_abstime")
    ad = classad.ClassAd({"foo": datetime.datetime.now()});
    td = (datetime.datetime.now()-ad["foo"])
    assertEqual(td.days, 0, "test_abstime")
    assertTrue(td.seconds < 300, "test_abstime")

    # test_reltime
    expr = classad.ExprTree('relTime(5)')
    assertEqual(expr.eval(), 5, "test_reltime")

    # test_quote
    assertEqual(classad.quote("foo"), '"foo"', "test_quote")
    assertEqual(classad.quote('"foo'), '"\\"foo"', "test_quote")
    for i in ["foo", '"foo', '"\\"foo']:
        assertEqual(i, classad.unquote(classad.quote(i)), "test_quote")

    # test_literal
    assertEqual(classad.ExprTree('"foo"'), classad.Literal("foo"), "test_literal")
    assertEqual(classad.Literal(1).eval(), 1, "test_literal")

    # test_operator
    expr = classad.Literal(1) + 2
    assertTrue(isinstance(expr, classad.ExprTree), "test_operator")
    assertTrue(expr.sameAs(classad.ExprTree('1 + 2')), "test_operator")
    expr = classad.Literal(1) & 2
    assertTrue(isinstance(expr, classad.ExprTree), "test_operator")
    assertEqual(expr.eval(), 0, "test_operator")
    assertTrue(expr.sameAs(classad.ExprTree('1 & 2')), "test_operator")
    expr = classad.Attribute("foo").is_(classad.Value.Undefined)
    assertTrue(expr.eval(), "test_operator")
    ad = classad.ClassAd("[foo = 1]")
    expr = classad.Attribute("foo").isnt_(classad.Value.Undefined)
    assertTrue(expr.eval(ad), "test_operator")
    expr = classad.Literal(1).and_( classad.Literal(2) )
    # TODO: Fix the following subtest
    # assertRaises(RuntimeError, expr.eval, "test_operator", expr)

    # test_subscript
    ad = classad.ClassAd({'foo': [0,1,2,3]})
    expr = classad.Attribute("foo")._get(2)
    assertTrue(isinstance(expr, classad.ExprTree), "test_subscript")
    assertEqual(expr.eval(), classad.Value.Undefined, "test_subscript")
    assertEqual(expr.eval(ad), 2, "test_subscript")

    # test_function
    expr = classad.Function("strcat", "hello", " ", "world")
    assertTrue(isinstance(expr, classad.ExprTree), "test_function")
    assertEqual(expr.eval(), "hello world", "test_function")
    expr = classad.Function("regexp", ".*")
    assertEqual(expr.eval(), classad.Value.Error, "test_function")

    # test_flatten
    expr = classad.Attribute("foo") == classad.Attribute("bar")
    ad = classad.ClassAd({"bar": 1})
    assertTrue(ad.flatten(expr).sameAs( classad.ExprTree('foo == 1') ), "test_flatten")

    # test_matches
    left = classad.ClassAd('[requirements = other.foo == 3; bar=1]')
    right = classad.ClassAd('[foo = 3]')
    right2 = classad.ClassAd('[foo = 3; requirements = other.bar == 1;]')
    assertFalse(left.matches(right), "test_matches")
    assertTrue(right.matches(left), "test_matches")
    assertFalse(right.symmetricMatch(left), "test_matches")
    assertTrue(left.matches(right2), "test_matches")
    assertTrue(right2.symmetricMatch(left), "test_matches")

    # test_bool
    assertTrue(bool( classad.ExprTree('true || false') ), "test_bool")
    assertTrue(bool( classad.Literal(True).or_(False) ), "test_bool") 
    assertFalse(bool( classad.ExprTree('true && false') ), "test_bool")
    assertFalse(bool( classad.Literal(True).and_(False) ), "test_bool")

    # test_register
    class BadException(Exception): pass
    def myAdd(a, b): return a+b
    def myBad(a, b): raise BadException("bad")
    def myComplex(a): return 1j # ClassAds have no complex numbers, not able to convert from python to an expression
    def myExpr(**kw): return classad.ExprTree("foo") # Functions must return values; this becomes "undefined".
    def myFoo(foo): return foo['foo']
    def myIntersect(a, b): return set(a).intersection(set(b))
    classad.register(myAdd)
    classad.register(myAdd, name='myAdd2')
    classad.register(myBad)
    classad.register(myComplex)
    classad.register(myExpr)
    classad.register(myFoo)
    classad.register(myIntersect)
    assertEqual(3, classad.ExprTree('myAdd(1, 2)').eval(), "test_register")
    assertEqual(3, classad.ExprTree('myAdd2(1, 2)').eval(), "test_register")
    assertRaises(BadException, classad.ExprTree('myBad(1, 2)').eval, "test_register")
    assertRaises(TypeError, classad.ExprTree('myComplex(1)').eval, "test_register")
    assertEqual(classad.Value.Undefined, classad.ExprTree('myExpr()').eval(), "test_register")
    assertEqual(classad.ExprTree('myExpr()').eval({"foo": 2}), 2, "test_register")
    assertRaises(TypeError, classad.ExprTree('myAdd(1)').eval, "test_register") # myAdd requires 2 arguments; only one is given.
    assertEqual(classad.ExprTree('myFoo([foo = 1])').eval(), 1, "test_register")
    assertEqual(classad.ExprTree('size(myIntersect({1, 2}, {2, 3}))').eval(), 1, "test_register")
    assertEqual(classad.ExprTree('myIntersect({1, 2}, {2, 3})[0]').eval(), 2, "test_register")

    # test_state
    def myFunc(state): return 1 if state else 0
    classad.register(myFunc)
    assertEqual(0, classad.ExprTree('myFunc(false)').eval(), "test_state")
    assertEqual(1, classad.ExprTree('myFunc("foo")').eval(), "test_state")
    ad = classad.ClassAd("[foo = myFunc(); bar = 2]")
    assertEqual(1, ad.eval('foo'), "test_state")
    ad['foo'] = classad.ExprTree('myFunc(1)')
    assertRaises(TypeError, ad.eval, "test_state", ('foo',))
    def myFunc(arg1, **kw): return kw['state']['bar']
    classad.register(myFunc)
    assertEqual(2, ad.eval('foo'), "test_state")

    # test_refs
    ad = classad.ClassAd({"bar": 2})
    expr = classad.ExprTree("foo =?= bar")
    assertEqual(ad.externalRefs(expr), ["foo"], "test_refs")
    assertEqual(ad.internalRefs(expr), ["bar"], "test_refs")

    # test_cast
    assertEqual(4, int(classad.ExprTree('1+3')), "test_cast")
    assertEqual(4.5, float(classad.ExprTree('1.0+3.5')), "test_cast")
    assertEqual(34, int(classad.ExprTree('strcat("3", "4")')), "test_cast")
    assertEqual(34.5, float(classad.ExprTree('"34.5"')), "test_cast")
    assertRaises(ValueError, float, "test_cast", classad.ExprTree('"34.foo"'))
    assertRaises(ValueError, int, "test_cast", classad.ExprTree('"12 "'))
    ad = classad.ClassAd("[foo = 2+5; bar = foo]")
    expr = ad['bar']
    assertEqual(7, int(expr), "test_cast")
    assertEqual(7, int(ad.lookup('bar')), "test_cast")
    assertEqual(0, int(classad.ExprTree('false')), "test_cast")
    assertEqual(0.0, float(classad.ExprTree('false')), "test_cast")
    assertEqual(1, int(classad.ExprTree('true')), "test_cast")
    assertEqual(1.0, float(classad.ExprTree('true')), "test_cast")
    assertEqual(3, int(classad.ExprTree('3.99')), "test_cast")
    assertEqual(3.0, float(classad.ExprTree('1+2')), "test_cast")
    assertRaises(ValueError, int, "test_cast", classad.ExprTree('undefined'))
    assertRaises(ValueError, float, "test_cast", classad.ExprTree('error'))
    assertRaises(ValueError, float, "test_cast", classad.ExprTree('foo'))

    # test_pipes
    # One regression we saw in the ClassAd library is the new
    # parsing routines would fail if tell/seek was non-functional.
    r, w = os.pipe()
    rfd = os.fdopen(r, 'r')
    wfd = os.fdopen(w, 'w')
    wfd.write("[foo = 1]")
    wfd.close()
    ad = classad.parseNext(rfd ,parser=classad.Parser.New)
    assertEqual(tuple(dict(ad).items()), (('foo', 1),), "test_pipes")
    # TODO: Fix the following subtest
    # assertRaises(StopIteration, classad.parseNext, "test_pipes", rfd, classad.Parser.New)
    rfd.close()
    r, w = os.pipe()
    rfd = os.fdopen(r, 'r')
    wfd = os.fdopen(w, 'w')
    wfd.write("[foo = 1]")
    wfd.close()
    assertRaises(ValueError, classad.parseNext, "test_pipes", rfd)
    rfd.close()



if __name__ == "__main__":
    main()

