#!/usr/bin/env python

import os
import sys

from pytest.CondorJob import CondorJob
from pytest.CondorTest import CondorTest
from pytest.Globals import *
from pytest.PersonalCondor import PersonalCondor
from pytest.Utils import Utils

#
# Test to see if startd job policies function properly during retirement.
#
# First, we'll test to make sure the the job policy in question functions
# during normal operations.
#
# Then we'll test the job policy when draining.  (We assume for now that the
# START expression has no effect on job policy, so we'll test with
# backfill active.)  Then we'll test to see if the job policy functions
# on jobs which were accepted while draining.
#
# Because we expect all of this to work, we'll start off with just two
# separate test runs.  If this test ever fails, we may need to split the
# component tests out for easier diagnosis.
#
# The first test run will configure a personal condor with retirement time
# and the HOLD_IF_MEMORY_EXCEEDED policy.  It will (1) submit a job, (2) wait
# for the job to start, and then (5) signal the job to misbehave and (6) wait
# for the job to go on hold.  [Steps 3 and 4 only runs in the next test.]
#
# The job in question will be like cmd_drain_scavenging's, in that it will
# poll for a 'killfile'; however, this job will start consuming a large
# of memory, instead.
#
# The second test run will use the same personal condor.  In step (1) and (2),
# it will submit two jobs.  Then it (3) will signal the startd to drain and
# (4) wait for the startd to change state appropriately.  After steps (5) and
# (6), this test will also (7) check to make sure that the other job is still
# running.  If it is, the test will (8) submit a third copy of the same job,
# (9) verify that it's running and (10) signal it to misbehave.  The test will
# then check (11) that the job went on hold and (12) the first job is still
# running.  At this point, we've completed our twelve-step program and our
# livers thank us.
#
# To test job policies during a peaceful shut-down, a third test run
# would be cleanest.  We can do steps (1) and (2) as per the second test
# run, and then instead of (3), tell the startd to peacefully shut down
# and instead of (4), wait for the startd to start doing so.  We can
# then do steps (5), (6), and (7).  I don't think we need to do steps (8)
# (9), (10), (11), and (12), but I guess it won't hurt.  (On the other hand,
# we may need to split this test off into its own .run file to make
# this test doesn't take too long.)
#

def RunningCallback():
    Utils.TLog( "FIXME" )

def main():
    params = None # FIXME
    test = CondorTest( "cmd_drain_policies", params )
    personalCondor = test.StartPersonalCondor()
    if personalCondor is -1:
        Utils.TLog( "Failed to start a personal condor, aborting.\n" );
        sys.exit( TEST_FAILURE )

    jobArgs = None # FIXME
    firstTestJob = CondorJob( jobArgs )
    firstTestJob.RegisterRunning( RunningCallback )

    firstTestJob.submit()
    result = firstTestJob.WaitForFinish()

    # FIXME: ...

if __name__ == "__main__":
    main()
