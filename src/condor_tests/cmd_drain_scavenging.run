#!/usr/bin/env perl

##**************************************************************
##
## Copyright (C) 1990-2018, Condor Team, Computer Sciences Department,
## University of Wisconsin-Madison, WI.
##
## Licensed under the Apache License, Version 2.0 (the "License"); you
## may not use this file except in compliance with the License.  You may
## obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
##**************************************************************

use strict;
use warnings;

use Cwd;

use CondorTest;
use CondorUtils;
use CustomMachineResource;

#testreq: personal
my $config = <<CONDOR_TESTREQ_CONFIG;
use feature : PartitionableSlot
NEGOTIATOR_INTERVAL = 5
MaxJobRetirementTime = 120
MachineMaxVacateTime = 5
NUM_CPUS = 3
CONDOR_TESTREQ_CONFIG
#endtestreq

my $testName = 'cmd_drain_scavenging';
my $testDescription = 'Test scavenging.';

#
# We'll submit three long jobs and two short jobs, in that order.  After the
# three long jobs have started, we'll begin draining
# with a start expression of 'TARGET.MaxJobRetirementTime == 0'.  Then we'll
# verify that the slots have all changed state & activity, and that the new
# START expression is being advertised.  Then we'll terminate two of the
# long jobs and call condor_reschedule.  Within $(NEGOTIATOR_INTERVAL) seconds,
# only and only one should match; well wait twenty seconds for it to actually
# start.  Then we'll verify the new slot's state & activity.  Then we'll
# terminate the last long job and verify that the running short job is
# immediately evicted.  (Wait twenty seconds?)  When it is, we'll wait
# (no more than twenty seconds) until the machine is fully drained.  Then
# we'll cancel the draining, at which point we'll verify the old START
# expression, and then wait for the last (short) job to start, at which
# point we'll terminate it and the test.
#

my $jobFile = cwd() . '/condition-sleep.pl';
my $jobContents = '#!/usr/bin/env perl

use strict;
use warnings;

my $killFile = $ARGV[0];
my $maxSleep = $ARGV[1];

for( my $i = 0; $i < $maxSleep; ++$i ) {
	if( -e $killFile ) { exit( 0 ); }
	sleep( 1 );
}

exit( 0 );
';
CondorTest::WriteFileOrDie( $jobFile, $jobContents );
chmod( 0755, $jobFile ) || die( "Failed to make ${jobFile} executable, aborting.\n" );

my $killFile = cwd() . "/killfile";
my $submitBody = "

executable				= ${jobFile}
transfer_executable		= false
should_transfer_files	= true
universe				= vanilla
arguments				= ${killFile}.\$(CLUSTER).\$(PROCESS) 3600

log						= cmd_drain_scavenging.log

queue 3

arguments				= ${killFile}.\$(CLUSTER).\$(PROCESS) 60
MaxJobRetirementTime	= 0

queue 1

arguments				= ${killFile}.\$(CLUSTER).\$(PROCESS) 60
MaxJobRetirementTime	= 60

queue 1

";

my $clusterID;
my $setClusterID = sub {
	my( $cID ) = @_;
	$clusterID = $cID;
};

my $hostName = `condor_config_val full_hostname`;
CondorUtils::fullchomp( $hostName );

my $testingPhase = 0;
my $longJobsRunningCount = 0;
my $execute = sub {
	my %info = @_;
	my $ID = $info{ 'cluster' } . "." . $info{ 'job' };

	if( $info{ 'cluster' } != $clusterID ) {
		die( "Found stale test job or log file, aborting.\n" );
	}

	if( $testingPhase == 0 ) {
		if( 0 <= $info{ 'job' } && $info{ 'job' } <= 2 ) {
			++$longJobsRunningCount;
		} else {
			die( "Job ${ID} executed before it should have.\n" );
		}

		if( $longJobsRunningCount > 3 ) {
			die( "Long jobs started more than three times.\n" );
		} elsif( $longJobsRunningCount < 3 ) {
			return;
		}

		print( "All three long jobs have started.  Beginning draining...\n" );
		runCommandCarefully( undef, qw( condor_drain -start ),
			'TARGET.MaxJobRetirementTime == 0', $hostName );

		print( "Verifying state changes...\n" );
		for( my $delay = 0; $delay <= 20; ++$delay ) {
			if( $delay == 20 ) {
				die( "State failed to change by twenty seconds after draining, aborting.\n" ); 
			}

			sleep( 1 );

			my $ads = CustomMachineResource::parseMachineAds( qw(Name State Activity Start) );
			if( scalar(@{$ads}) != 4 ) {
				print( "Found unexpected number of ads: " . scalar(@{$ads}) . ", will retry.\n" );
				next;
			}

			# FIXME: also confirm ClaimedWhileDraining.
			my $stateChanged = 1;
			foreach my $ad (@{$ads}) {
				if( $ad->{ "Name" } =~ /^slot1@/ ) { next; }
				print( "Considering '" . $ad->{ "Name" } . "'...\n" );
				if(! $ad->{ "State" } =~ /^Claimed$/i) { print( "Found unexpected state '" . $ad->{ "State" } . "', will retry.\n" ); $stateChanged = 0; last; }
				if(! $ad->{ "Activity" } =~ /^Retiring$/i) { print( "Found unexpected activity '" . $ad->{ "Activity" } . "', will retry.\n" ); $stateChanged = 0; last; }
				if(! $ad->{ "Start" } =~ /TARGET\.MaxJobRetirementTime == 0/i) { print( "Found unexpected START '" . $ad->{ "Start" } . "', will retry.\n" ); $stateChanged = 0; last; }
			}
			if( $stateChanged == 1 ) { last; }
		}
		print( "... state changed successfully.\n" );

		print( "Killing two of the long-running jobs...\n" );
		touch( $killFile . ".${clusterID}.0" );
		touch( $killFile . ".${clusterID}.1" );
		$testingPhase = 1;
	} elsif( $testingPhase == 2 ) {
		if( $info{ 'job' } != 3 ) {
			die( "Job ${ID} executed during testing phase 2, aborting.\n" );
		}

		print( "Scavenger job started.  Verifying state changes...\n" );
		for( my $delay = 0; $delay <= 20; ++$delay ) {
			if( $delay == 20 ) {
				die( "State failed to change by twenty seconds after draining, aborting.\n" ); 
			}

			sleep( 1 );

			my $ads = CustomMachineResource::parseMachineAds( qw(Name State Activity Start) );
			if( scalar(@{$ads}) != 3 ) {
				print( "Found unexpected number of ads: " . scalar(@{$ads}) . ", will retry.\n" );
				next;
			}

			# FIXME: also confirm ClaimedWhileDraining.
			my $stateChanged = 0;
			foreach my $ad (@{$ads}) {
				if( $ad->{ "Name" } =~ /^slot1@/ ) { next; }
				print( "Considering '" . $ad->{ "Name" } . "'...\n" );

				if(		$ad->{ "State" } =~ /^Claimed$/i &&
						$ad->{ "Activity" } =~ /^Busy$/i ) {
					$stateChanged = 1;
					last;
				}
			}

			if( $stateChanged ) { last; }
		}
		print( "... state changed successfully.\n" );

		print( "Killing the last long-running job...\n" );
		touch( $killFile . ".${clusterID}.2" );
		$testingPhase = 3;
	} elsif( $testingPhase == 4 ) {
		if( $info{ 'job' } != 4 ) {
			die( "Job ${ID} executed during testing phase 4, aborting.\n" );
		}

		print( "Killing last job...\n" );
		touch( $killFile . ".${clusterID}.4" );
		$testingPhase = 5;
	} else {
		die( "execute() called unexpectedly in testing phase ${testingPhase}, aborting.\n" );
	}
};

my $longJobsSucceededCount = 0;
my $success = sub {
	my %info = @_;
	my $ID = $info{ 'cluster' } . "." . $info{ 'job' };

	if( $info{ 'cluster' } != $clusterID ) {
		die( "Found stale test job or log file, aborting.\n" );
	}

	if( $testingPhase == 1 ) {

		if( 0 <= $info{ 'job' } && $info{ 'job' } <= 1 ) {
			++$longJobsSucceededCount;
		} else {
			die( "Job ${ID} succeeded before it should have.\n" );
		}

		if( $longJobsSucceededCount > 2 ) {
			die( "Long jobs started more than three times.\n" );
		} elsif( $longJobsSucceededCount < 2 ) {
			return;
		}

		print( "Two long jobs have succeeded, calling condor_reschedule...\n" );
		runCommandCarefully( undef, 'condor_reschedule' );

		print( "Waiting for scavenger job to start...\n" );
		$testingPhase = 2;
	} elsif( $testingPhase == 3 || $testingPhase == 4 ) {
		# We /should/ get the succeeded event before the eviction event,
		# but it's OK if they happen in the other order.
		if( $info{ 'job' } != 2 ) {
			die( "Job ${ID} succeeded during testing phase 3 or 4, aborting.\n" );
		}
	} elsif( $testingPhase == 5 ) {
		if( $info{ 'job' } != 4 ) {
			die( "Job ${ID} succeeded during testing phase 5, aborting.\n" );
		}

		RegisterResult( 1, check_name => 'normal/drain/scavenge/drained/normal cycle', test_name => $testName );
	} else {
		die( "success() called unexpectedly in testing phase ${testingPhase}, aborting.\n" );
	}
};

my $evicted = sub {
	my %info = @_;
	my $ID = $info{ 'cluster' } . "." . $info{ 'job' };

	if( $info{ 'cluster' } != $clusterID ) {
		die( "Found stale test job or log file, aborting.\n" );
	}

	if( $testingPhase == 3 ) {
		if( $info{ 'job' } != 3 ) {
			die( "Job ${ID} evicted, aborting.\n" );
		}

		print( "Waiting for machine to fully drain...\n" );
		for( my $delay = 0; $delay <= 20; ++$delay ) {
			if( $delay == 20 ) {
				die( "State failed to change by twenty seconds after draining, aborting.\n" ); 
			}

			sleep( 1 );

			my $ads = CustomMachineResource::parseMachineAds( qw(Name State Activity Start) );
			if( scalar(@{$ads}) != 1 ) {
				print( "Found unexpected number of ads: " . scalar(@{$ads}) . ", will retry.\n" );
				next;
			}

			# FIXME: also confirm ClaimedWhileDraining.
			my $drained = 0;
			foreach my $ad (@{$ads}) {
				if(		$ad->{ 'State' } =~ /^Drained$/i &&
						$ad->{ 'Activity' } =~ /^Idle$/i ) {
					$drained = 1;
				}
			}
			if( $drained ) { last; }
		}
		print( "... machine fully drained.\n" );

		print( "Cancelling draining state...\n" );
		runCommandCarefully( undef, "condor_drain -cancel ${hostName}" );

		print( "Removing evicted job...\n" );
		runCommandCarefully( undef, 'condor_rm', $ID );

		print( "Calling condor_reschedule...\n" );
		runCommandCarefully( undef, 'condor_reschedule' );

		print( "Waiting for last job to start...\n" );
		$testingPhase = 4;
	} else {
		die( "evicted() called unexpectedly in testing phase ${testingPhase}, aborting.\n" );
	}
};

my $aborted = sub {
	my %info = @_;
	my $ID = $info{ 'cluster' } . "." . $info{ 'job' };

	if( $info{ 'cluster' } != $clusterID ) {
		die( "Found stale test job or log file, aborting.\n" );
	}

	if( $testingPhase == 4 ) {
		if( $info{ 'job' } != 3 ) {
			die( "Job ${ID} evicted, aborting.\n" );
		}
	} else {
		die( "aborted() called unexpectedly in testing phase ${testingPhase}, aborting.\n" );
	}
};

CondorTest::RegisterExecute( $testName, $execute );
CondorTest::RegisterExitedSuccess( $testName, $success );
CondorTest::RegisterEvictedWithoutCheckpoint( $testName, $evicted );
CondorTest::RegisterAbort( $testName, $aborted );
CondorTest::RunTest2( name => $testName, want_checkpoint => 0,
	submit_body => $submitBody, callback => $setClusterID );

exit( 0 );

sub touch {
	my( $filename ) = @_;

	my $rv = open( my $fh, ">", $filename );
	close( $fh );
	return $rv;
}
