#!/usr/bin/env perl
#testreq: personal

##**************************************************************
##
## Copyright (C) 1990-2018, Condor Team, Computer Sciences Department,
## University of Wisconsin-Madison, WI.
##
## Licensed under the Apache License, Version 2.0 (the "License"); you
## may not use this file except in compliance with the License.  You may
## obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
##**************************************************************

use strict;
use warnings;
use FindBin;

#
# This is a basic test to determine if Custom Machine Resource monitors are
# working properly.
#

use CondorTest;
use CondorUtils;
use CondorPersonal;

my $bindir = $FindBin::Bin;

#testreq: personal
my $config = '
NUM_CPUS = 16

MACHINE_RESOURCE_INVENTORY_SQUIDs = ${bindir}/cmr-squid-discovery

STARTD_CRON_JOBLIST = $(STARTD_CRON_JOBLIST) SQUIDs_MONITOR
STARTD_CRON_SQUIDs_MONITOR_MODE = periodic
STARTD_CRON_SQUIDs_MONITOR_PERIOD = 10
STARTD_CRON_SQUIDs_MONITOR_EXECUTABLE = ${bindir}/cmr-squid-monitor
STARTD_CRON_SQUIDs_MONITOR_METRICS = SUM:SQUIDs, PEAK:SQUIDsMemory

UPDATE_INTERVAL = 20
STARTER_UPDATE_INTERVAL = 20
SHADOW_QUEUE_UPDATE_INTERVAL = 60
';
#endtestreq

my $testName = 'cmr_monitor_basic';
my $testDescription = 'Custom Machine Resources - Monitor Test Basic';

my $abnormal = sub {
	die( "Error: Want to see only submit, execute and successful completion\n" );
};

my $aborted = sub {
	die( "Error: Want to see only submit, execute and successful completion\n" );
};

my $held = sub
{
	die( "Error: Want to see only submit, execute and successful completion\n" );
};

my $executed = sub
{
};

my $submitted = sub
{
};

my $success = sub
{
	# FIXME
};

my $on_evictedwithoutcheckpoint = sub {
	die( "Error: Want to see only submit, execute and successful completion\n" );
};

my $failure = sub {
	die( "Error: Want to see only submit, execute and successful completion\n" );
};

CondorTest::RegisterExitedAbnormal( $testName, $abnormal );
CondorTest::RegisterAbort( $testName, $aborted );
CondorTest::RegisterHold( $testName, $held );
CondorTest::RegisterExecute($testName, $executed );
CondorTest::RegisterSubmit( $testName, $submitted );
CondorTest::RegisterExitedSuccess( $testName, $success );
CondorTest::RegisterEvictedWithoutCheckpoint($testName, $on_evictedwithoutcheckpoint);
CondorTest::RegisterExitedFailure( $testName, $failure );

#
# OK, before we try running a job and checking its SQUIDsUsage, verify that
# the slots have SQUIDs and that they're being used.
#

# In `condor_status -af Name AssignedSQUIDs`, we should find sixteen slots,
# four of which have SQUIDs -- SQUID{0,1,2,3}.  [FIXME]
my $ads = parseMachineAds( "Name", "AssignedSQUIDs" );

my %SQUIDs;
my $totalCount = 0;
foreach my $ad (@{$ads}) {
	++$totalCount;
	if( $ad->{ "AssignedSQUIDs" } =~ /^(SQUID\d)$/ ) {
		$SQUIDs{ $1 } = 1;
	}
}

if( $totalCount != 16 ) {
	die( "Failure: Found ${totalCount} slots, was expecting 16.\n" );
}
if( scalar(keys( %SQUIDs )) != 4 ) {
	die( "Failure: Found " . scalar(keys(%SQUIDs)) . " SQUIDs, was expecting 4.\n" );
}

# There's probably testing framework goo to make this show up as its own
# (successful) sub-test.
print( "Found proper number of slots and SQUIDs, checking values...\n" );

# In `condor_status -direct ${NAME} -af Name UptimeSQUIDsSeconds`, we should
# find sixteen slots, four of which have UptimeSQUIDsSeconds.  Those four
# metrics should have a 5:1:9:4 ratio if everything is working properly; if
# any metric is 0, the test is a failure.  (The values should also be
# integer multiples of 5, 1, 9, and 4.)
my $directAds = parseDirectMachineAds( "AssignedSQUIDs", "UptimeSQUIDsSeconds" );

my $multiplier;
foreach my $ad (@{$directAds}) {
	my $value = $ad->{ "UptimeSQUIDsSeconds" };
	if( $value eq "undefined" ) { next; }

	if( $ad->{ "AssignedSQUIDs" } eq "SQUID1" ) {
		if( $value % 1 != 0 ) {
			die( "Failure: SQUID1 has bad uptime '${value}'.\n" );
		}

		$multiplier = $value;
	}
}

foreach my $ad (@{$directAds}) {
	my $value = $ad->{ "UptimeSQUIDsSeconds" };
	if( $value eq "undefined" ) { next; }

	my $SQUID = $ad->{ "AssignedSQUIDs" };

	if( $SQUID eq "SQUID0" ) {
		if( $value % 5 != 0 || 5 * $multiplier != $value ) {
			die( "Failure: SQUID0 has bad uptime '${value}'.\n" );
		}
	} elsif( $SQUID eq "SQUID1" ) {
		if( $value % 1 != 0 || 1 * $multiplier != $value ) {
			die( "Failure: SQUID1 has bad uptime '${value}'.\n" );
		}
	} elsif( $SQUID eq "SQUID2" ) {
		if( $value % 9 != 0 || 9 * $multiplier != $value ) {
			die( "Failure: SQUID2 has bad uptime '${value}'.\n" );
		}
	} elsif( $SQUID eq "SQUID3" ) {
		if( $value % 4 != 0 || 4 * $multiplier != $value ) {
			die( "Failure: SQUID3 has bad uptime '${value}'.\n" );
		}
	} else {
		die( "Failure: Assigned SQUID '%s' invalid.\n", $ad->{ "AssignedSQUIDs" } );
	}
}

# There's probably testing framework goo to make this show up as its own
# (successful) sub-test.
print( "Verified uptime values, checking job values...\n" );

#
# Run a job.  Verify that:
# * the job ad in condor_q contains the correct SQUIDsUsage
#   (FIXME: is this entailed by either of the tests below?)
# * the job ad in the history file contains the correct SQUIDsUsage
# * the user log contains the correct SQUIDsUsage
#

my $submitFileName = "FIXME"; # we should be able to use a generic sleep job.
if( CondorTest::RunTest( $testName, $submitFileName, 0 ) ) {
	CondorTest::debug("$testName: SUCCESS\n",1);
	exit(0);
} else {
	die( "Error: $testName: CondorTest::RunTest() failed\n" );
}

sub parseMachineAds {
	my @attributes = @_;
	my $attributeList = join( " ", @attributes );

	my @lines = ();
	my $result = runCondorTool( "condor_status -af ${attributeList}", \@lines, 2, { emit_output => 0 } );

	my @ads;
	foreach my $line (@lines) {
		my %ad;
		my @values = split( ' ', $line );
		for( my $i = 0; $i < scalar(@values); ++$i ) {
			$ad{ $attributes[$i] } = $values[$i];
		}
		push( @ads, \%ad );
	}

	return \@ads;
}

sub parseDirectMachineAds {
	my @attributes = @_;
	my $attributeList = join( " ", @attributes );

	# It's super sad that this is the least-annoying way to do this.
	my $startdAddressFile = `condor_config_val STARTD_ADDRESS_FILE`;
	chomp( $startdAddressFile );
	my $startdAddress = `head -n 1 ${startdAddressFile}`;
	chomp( $startdAddress );

	my @lines = ();
	my $result = runCondorTool( "condor_status -direct '${startdAddress}' -af ${attributeList}", \@lines, 2, { emit_output => 0 } );

	my @ads;
	foreach my $line (@lines) {
		my %ad;
		my @values = split( ' ', $line );
		for( my $i = 0; $i < scalar(@values); ++$i ) {
			$ad{ $attributes[$i] } = $values[$i];
		}
		push( @ads, \%ad );
	}

	return \@ads;
}
