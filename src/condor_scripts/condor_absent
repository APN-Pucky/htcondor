#! /usr/bin/env perl
#! /s/std/bin/perl -w
use strict;

# ******************************************************
# Command line options
# ******************************************************
my %Options =
    (
     "[-ping]"		=> "Enable ping test",
     "[-]"		=> "Read roster from STDIN",
     "[-reserved]"	=> "Check the reserved list",
     "[-cluster]"	=> "Report \"Cluster\" nodes that are down",
     "[-pool=host]"	=> "Set the condor pool to \"host\"",
     "[-down-cluster]"	=> "Report known down cluster nodes",
     "[-down-all]"	=> "Report all known down nodes",
     "[-v]"		=> "Verbose",
     "[-h]"		=> "Dump help",
    );

# Process command line
my $Verbose = 0;
my $DoPing = 0;
my $DoPingOk = 0;
my $DoReserved = 0;
my $DoClusterCheck = 0;
my $RosterFile = "";
my $Program = $0;
my $CondorPool = "";
my $DoDownCluster = 0;
my $DoDownNodes = 0;
my @DownList;
foreach my $Arg ( @ARGV )
{
    if ( $Arg =~ /^-ping$/ )
    {
	$DoPing = 1;
    }
    elsif ( $Arg =~ /^-pingok$/ )
    {
	$DoPingOk = 1;
    }
    elsif ( $Arg =~ /^-$/ )
    {
	$RosterFile = "<\&STDIN";
    }
    elsif ( $Arg =~ /^-reserved$/ )
    {
	$DoReserved = 1;
    }
    elsif ( $Arg =~ /^-cluster$/ )
    {
	$DoClusterCheck = 1;
    }
    elsif ( $Arg =~ /^-down-cluster$/ )
    {
	$DoDownCluster = 1;
    }
    elsif ( $Arg =~ /^-down-all$/ )
    {
	$DoDownCluster = 1;
	$DoDownNodes = 1;
    }
    elsif ( $Arg =~ /^-pool=(.*)/ )
    {
	$CondorPool = $1;
    }
    elsif ( $Arg =~ /^-v$/ )
    {
	$Verbose++;
    }
    elsif ( $Arg =~ /^-h$/ )
    {
	Help( );
	exit 0;
    }
    else
    {
	Usage( $Arg );
	die "$0: Unknown option '$Arg'";
    }
}

# -cluster w/o -ping doesn't make sense
if (  ( $DoClusterCheck ) && ( ! $DoPing )  )
{
    print STDERR "Warning: -cluster has no effect without -ping\n";
}

# Set this to the file that contains the list of machines in your
# pool, sorted and unique.  It should contain just hostnames, not full
# hostnames with domains.
my $RosterDir = "/p/condor/home/admin";
if ( exists( $ENV{CONDOR_ROSTER_DIR} ) )
{
    $RosterDir = $ENV{CONDOR_ROSTER_DIR};
}
$RosterFile = "$RosterDir/roster" if ( $RosterFile eq "" );
if ( exists( $ENV{CONDOR_ROSTER_FILE} ) )
{
    $RosterFile = $ENV{CONDOR_ROSTER_FILE};
}
my $RosterStateFile = "$RosterDir/roster.state";
if ( exists( $ENV{CONDOR_ROSTER_STATE} ) )
{
    $RosterStateFile = $ENV{CONDOR_ROSTER_STATE};
}
my $CondorStatus = "condor_status";
my $CondorReserved = "condor_reserved";
my $CondorStatusArgs = "-master";
$CondorStatusArgs = $CondorStatusArgs . " -pool $CondorPool"
    if ( $CondorPool ne "" );

# List of users,hosts,user@hosts to allow as personal condor users
my %PersonalCondorLists = (
			   Users	=> [ "NEVER-MATCH-ME" ],
			   Hosts	=> [ "NEVER-MATCH-ME" ],
			   Full 	=> [ "NEVER-MATCH-ME" ],
		      );

# Read the state; all we really need is the "ClusterNodes" list
my %ClusterNodes;
my $ClusterCount = 0;
die "can't read '$RosterStateFile'" if (! open ( IN, $RosterStateFile ) );
while ( <IN> )
{
    chomp;
    s/\#.*$//g;
    next if ( $_ eq "" );
    if ( /arch\s+=\s+\"(.+)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeUser\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeSponsor\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeRoom\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeAll\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ExcludeHost\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /IncludeHost\s+=\s+\"(.+?)\"/i )
    {
	# Do nothing
    }
    elsif ( /ClusterNode\s+=\s+\"(.+?)\"/i )
    {
	$ClusterNodes{$1} = $1;
	$ClusterCount++;
    }
    elsif ( /Down\s+=\s+\"(.+?)\"/i )
    {
	push @DownList, $1;
    }
    elsif ( /PersonalCondor(Users|Hosts|Full)\s+=\s+\"(.+?)\"/i )
    {
	push( @{$PersonalCondorLists{$1}}, $2 );
    }
    elsif ( ! /^$/ )
    {
	print "Can't parse state line $. '$_'\n";
    }
}
close( IN );

# Read in the current roster, build the "%Absent" hash of names
die "Can't open '$RosterFile'" if ( ! open( IN, "$RosterFile" )  );
my $RosterCount;
my %FullRoster;
my %RosterDown;
while ( <IN> )
{
    chomp;
    next if ( /^\s+$/ );

    # Is it a 'down' line from the roster?
    if ( /-\s+(\S+)/ )
    {
	$RosterDown{$1} = $1;
	$FullRoster{$1} = $1;
    }
    else
    {
	$FullRoster{$_} = $_;
    }

    # Default line...
    $RosterCount++;
}
close( IN );

# Initialize the absent list to be the full roster
my %Absent;
foreach my $Host ( keys %FullRoster )
{
    $Absent{$Host} = $Host if ( ! exists $RosterDown{$Host} );
}


# This is the actual work: Take the output from condor_status, remove
# any entries that have an '@' (which are from personal condors) unless
# the user listed is in the PersonalCondorUsers list.
# Delete from the %Absent hash each entry found..
{
    # Build a regex of personal condor users
    my $PersonalUsers =
	"(" . join( ")|(", @{$PersonalCondorLists{Users}} ) . ")";
    my $PersonalHosts =
	"(" . join( ")|(", @{$PersonalCondorLists{Hosts}} ) . ")";
    my $PersonalFull =
	"(" . join( ")|(", @{$PersonalCondorLists{Full}} ) . ")";

    # Build & run the condor_status command...
    my $Cmd = "$CondorStatus $CondorStatusArgs";
    die "Can't run '$Cmd'" if ( ! open( IN, "$Cmd|" )  );
    while ( <IN> )
    {
	chomp;
	my $Host = $_;

	# Check for personal condor, filter 'em
	if ( /(.*)@(.*)/ )
	{
	    my $User = $1;
	    $Host = $2;
	    my $Full = $_;
	    if ( ( $User =~ /$PersonalUsers/ ) ||
		 ( $Host =~ /$PersonalHosts/ ) ||
		 ( $Full =~ /$PersonalFull/ )  )
	    {
		# Do nothing
	    }
	    else
	    {
		next;
	    }
	}

	# Ok.  Now clean up the host name & strike it from the absent hash
	$Host =~ s/\..*//g;
	delete $Absent{$Host};
    }
    close( IN );
}

# Now, %Absent contains the list of all "Roster" machines that are
#  1 - Not known to be down (in the roster state file)
#  2 - Not reporting in to the collector

# Run the cluster tool...
my $ReservedCount = 0;
if ( $DoReserved )
{
    my $Cmd = "$CondorReserved";
    die "Can't run '$Cmd'" if ( ! open( IN, "$Cmd|" )  );
    while ( <IN> )
    {
	chomp;
	my $Host = $_;
	if ( exists $Absent{$Host} )
	{
	    delete $Absent{$Host};
	}
	$ReservedCount++;
	print "Reserved: $Host\n" if ( $Verbose >= 1 );
    }
    close( IN );
}

# Dump it out - Print out entries in the roster that aren't in the
# condor_status output.
my @ClusterDown;		# Cluster nodes that are 'down'
my $ClusterAbsent = 0;		# Count of the above
my @NotDown;			# Hosts listed as down, but not
if ( $DoPing )
{
    my %PingOk;

    # Build up a temp absent list
    my @TempAbsent = ( keys %Absent, keys %RosterDown );
    while( $#TempAbsent >= 0 )
    {
	my $PingCmd = "pingfilt";
	my $HostCount = 0;
	my $Host;
	while ( $Host = shift( @TempAbsent ) )
	{
	    if ( ( length($PingCmd) + length ($Host) + 2 ) > 2000 )
	    {
		unshift @TempAbsent, $Host;
		last;
	    }
	    $PingCmd = $PingCmd . " $Host";
	    $HostCount++;
	}

	# If there are hosts in our list to ping...
	if ( $HostCount )
	{
	    die "Can't run pingfilt" if ( ! open( IN, "$PingCmd 2>&1 |") );
	    while( <IN> )
	    {
		chomp;
		next if ( /^ping:/ );
		$PingOk{$_} = 1;
	    }
	    close( IN );
	}
    }

    # Now, remove the unreachable hosts from the absent list
    foreach my $Host ( keys %Absent )
    {
	# If it's down, remove it from the absent list
	if ( ! exists $PingOk{$Host} )
	{
	    delete $Absent{$Host};

	    # However, if it's in the cluster, note it..
	    if ( exists( $ClusterNodes{$Host} ) )
	    {
		push( @ClusterDown, $Host );
	    }
	}
	# Otherwise, note it as an "absent" cluster node
	elsif ( exists $ClusterNodes{$Host} )
	{
	    $ClusterAbsent++;
	}
    }

    # "Down" hosts that pinged ok?
    foreach my $Host ( @DownList )
    {
	if ( exists $PingOk{$Host} )
	{
	    push @NotDown, $Host;
	}
    }
}

# Ok, now dump out the results
my $AbsentCount = 0;
foreach my $Host ( sort keys %Absent )
{
    print "$Host\n";
    $AbsentCount++;
}

# Report hosts that are listed as down, but ping ok
if ( $DoPingOk )
{
    foreach my $Host ( @NotDown )
    {
	print "Host listed as down, but ping ok: '$Host'\n";
    }
}

# Report cluster hosts that are down
if ( $DoClusterCheck )
{
    foreach my $Host ( @ClusterDown )
    {
	print "Cluster node down: '$Host'\n";
    }
}

# Build the list of cluser & node hosts 'known' to be down..
my @KnownClusterDown;
my @KnownNodeDown;
foreach my $Host ( sort @DownList )
{
    if ( exists $ClusterNodes{$Host} )
    {
	push @KnownClusterDown, $Host;
    }
    else
    {
	push @KnownNodeDown, $Host;
    }
}
# Report hosts that are _known_ to be down...
if ( $DoDownCluster )
{
    foreach my $Host ( @KnownClusterDown )
    {
	print "Cluster node known to be down: '$Host'\n";
    }
}
if ( $DoDownNodes )
{
    foreach my $Host ( @KnownNodeDown )
    {
	print "Node known to be down: '$Host'\n";
    }
}

# Report cluster nodes that are known to be down..
print "# Summary\n";
print "#   $RosterCount machines in the roster\n";
print "#   Cluster: $ClusterCount nodes";
print ", $ReservedCount reserved" if ( $DoReserved );
print ", " . ($#ClusterDown + 1) . " down" if ( $DoClusterCheck );
print ", $ClusterAbsent absent";
print "\n#   $AbsentCount hosts absent\n";

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
