#! /usr/bin/env perl
#***********************************************************************
#
# Copyright (C) 2004, Computer Sciences Department,
# University of Wisconsin-Madison, WI, and Nick LeRoy,
# and other members of the Condor Project
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License version
# 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
# For contact information, please visit:
#      http://www.cs.wisc.edu/condor
#
#**********************************************************************/
use strict;
use warnings;
use File::Temp qw(tempfile);

# Update the module include path
BEGIN
{
	my $Dir = $0;
	if ( $Dir =~ /(.*)\/.*/ )
	{
		push @INC, "$1";
	}
}
use CondorConfig;
$| = 1;

# Prototypes
sub main( );
sub CommandLine( @ );
sub FindConfigFile( );
sub ReadConfigFiles( );
sub ConfigureModule( $ );
sub WriteConfigFile( );
sub UpdateConfigFile( );
sub ParseOldJob( $$ );
sub ImportOption( $$ );
sub Usage ( $ );
sub Help ( );


# ******************************************************
# Command line options
# ******************************************************
my $Distribution = "hawkeye";
my %Options =
    (
     "[--config=file]"	=> "Specify $Distribution config file",
     "[--no-update|-n]"	=> "Don't update the config file",
     "[--update=file]"	=> "Specify config file to update",
     "[--update|-u]"	=> "Enable config update <default>",
     "[--manual|-m]"	=> "Manual mode; asks lots of questions",
     "[--defaults]"	=> "Use defaults if possible",
     "[--all|-a]"	=> "Install all modules found in packages",
     "[--ask]"		=> "Ask before installing each module",
     "File [File..]"	=> "List of module package files to install",
     "[--help|-h]"	=> "Dump help",
    );

# Hash of directories & files
my %Config =
(
 RootDir => "",
 ConfigFile =>
 {
  Base => "",
  Updated => "",
 },
 DoDoUpdateConfig => 0,
 UseDefaults => 1,
 AskAll => 0,
 InstallAll => 1,
 Startd => -1,
 CronName => "",

);

# Valid setup info
my %ConfigOptions =
(
 continuous	=> { Reconfig => "True", WaitForExit => "True", },
 kill		=> { Kill => "True", },
 nokill		=> { Kill => "False", },
 reconfig	=> { Reconfig => "True", },
 waitforexit	=> { WaitForExit => "True", },
);

# Condor config stuff
my $ConfigMacros;
my $ConfigFiles;

my $Program;
my $ConfigEnv;

main( );

# ******************************************************
# Main
# ******************************************************
sub main( )
{
    # "Main" Logic
    if ( ! exists $ENV{PWD} )
    {
	$ENV{PWD} = `/bin/pwd`; chomp $ENV{PWD};
    }

    # Look at $0, see what we can gleen from it...
    if ( $0 =~ /(condor|hawkeye)_config_update/ )
    {
	$Distribution = $1;
    }
    elsif ( exists $ENV{CONDOR_DISTRIBUTION} )
    {
	$Distribution = $1;
    }
    $Program = $Distribution . "_config_update";
    $ConfigEnv = uc $Distribution . "_CONFIG";

    # Process command line, etc..
    CommandLine( @ARGV );
    $#ARGV = -1;
    $| = 1;

    # Create the config macro & file handlers
    $ConfigMacros = CondorConfigMacros->new( $Distribution );

    # Construct the config file object
    $ConfigFiles = CondorConfigFiles->new( $ConfigMacros );

    # Find the config file to use
    FindConfigFile( );

    # Read the config file
    ReadConfigFiles( );

    # Write the modified file if required
    my $OldJobs = $ConfigMacros->Expand( $Config{CronJobsVar} );
    if ( $OldJobs ne "" )
    {
	UpdateConfigFile( );
    }

} # end of "main"
# ******************************************************

# ******************************************************
# Parse the command line, etc.
# ******************************************************
sub CommandLine( @ )
{
    foreach my $Arg ( @_ )
    {

	# Speicify config file
	if ( $Arg =~ /--config=(.+)/ )
	{
	    die "Config file '$1' does not exist" if ( ! -f $1 );
	    my $File = $1;
	    if ( ! $File =~ /^\// )
	    {
		$File = $ENV{PWD} . "/$File";
	    }
	    $Config{ConfigFile}{Base} = $File;
	}

	# Config file to update
	elsif ( $Arg =~ /^--update=(.+)/ )
	{
	    $Config{ConfigFile}{Updated} = $1;
	    $Config{DoUpdateConfig} = 1;
	}

	# Config update
	elsif ( ( $Arg eq "-u") || ( $Arg eq "--update" ) )
	{
	    $Config{DoUpdateConfig} = 1;
	}

	# Don't update config
	elsif ( ( $Arg eq "-n") || ( $Arg eq "--no-update" ) )
	{
	    $Config{DoUpdateConfig} = 0;
	}

	# "Ask" mode
	elsif ( $Arg eq "--ask" )
	{
	    $Config{InstallAll} = 0;
	}

	# Manual mode
	elsif ( ( $Arg eq "-m" ) || ( $Arg eq "--manual" ) )
	{
	    $Config{InstallAll} = 0;
	    $Config{UseDefaults} = 0;
	    $Config{AskAll} = 1;
	}

	# Hawkeye mode
	elsif ( $Arg eq "--hawkeye" )
	{
	    $Distribution = "hawkeye";
	}

	# Condor mode
	elsif ( $Arg eq "--condor" )
	{
	    $Distribution = "condor";
	}

	# Help
	elsif ( ( $Arg =~ /^-h/ ) || ( $Arg eq "--help" ) )
	{
	    Help( );
	    exit 0;
	}

	# Unknown option
	elsif ( $Arg =~ /^-/ )
	{
	    Usage( $Arg );
	    exit( 1 );
	}

	# Must be a file
	else
	{
	    Usage( undef );
	}
    }

} # CommandLine( )
# ******************************************************

# ******************************************************
# Find the configuration file to use
# ******************************************************
sub FindConfigFile( )
{
    my $Base = $ConfigFiles->FindConfig( $ConfigEnv,
					 $Config{ConfigFile}{Base},
					 $Distribution );

    # Finally, let's go check the config
    if ( ! $Base )
    {
	print STDERR "No config found\n";
	Usage( "" );
	print STDERR "\tOr, set the $ConfigEnv env variable\n";
	exit 1;
    }

    # Store off the setting
    $Config{ConfigFile}{Base} = $Base;

    return 1;

} # FindConfigFile()
# ******************************************************

# ******************************************************
# Read the config file
# ******************************************************
sub ReadConfigFiles( )
{

    # Read them all in
    $ConfigFiles->ReadAll( );

    # Add basic things to the config if they're not defined...
    $Config{CronName} = $ConfigMacros->Expand( "STARTD_CRON_NAME" );
    if ( ! defined $Config{CronName} )
    {
	$Config{CronName} =
	    ( $Distribution eq "hawkeye" ) ? "Hawkeye" : "Cron";
	$ConfigFiles->AddText( "STARTD_CRON_NAME = $Config{CronName}" );
	$ConfigMacros->Set( "STARTD_CRON_NAME", $Config{CronName} );
    }

    # Jobs defined?
    my $CronJobsVar = uc( $Config{CronName} . "_JOBS" );
    my $Jobs = $ConfigMacros->Expand( $CronJobsVar );
    if ( ! defined $Jobs )
    {
	$ConfigFiles->AddText( "$CronJobsVar = " );
	$ConfigMacros->Set( "$CronJobsVar", "" );
    }
    $Config{CronJobsVar} = $CronJobsVar;

    # Job list defined?
    my $CronJobListVar = uc( $Config{CronName} . "_JOBLIST" );
    $Jobs = $ConfigMacros->Expand( $CronJobsVar );
    if ( ! defined $Jobs )
    {
	$ConfigFiles->AddText( "$CronJobListVar = " );
	$ConfigMacros->Set( "$CronJobListVar", "" );
    }
    $Config{CronJobListVar} = $CronJobListVar;

    # Try to find the file that last definied the job list
    if ( $Config{ConfigFile}{Updated} eq "" )
    {
	my $File = $ConfigMacros->Expand( "INSTALL_MODULE_CONFIG_FILE" );
	$Config{ConfigFile}{Updated} = $File if ( $File );
    }

    # Try to find the file that last definied the job list
    if ( $Config{ConfigFile}{Updated} eq "" )
    {
	my $Info = $ConfigMacros->GetInfo( $CronJobListVar );
	if ( ( $Info ) && ( $Info->{File} ) )
	{
	    $Config{ConfigFile}{Updated} = $Info->{File};
	    print "Found '$CronJobListVar' in "
		. $Info->{File} . " line " . $Info->{Line} . "\n";
	}
    }

    # Try to find the file that last definied the old job list
    if ( $Config{ConfigFile}{Updated} eq "" )
    {
	my $Info = $ConfigMacros->GetInfo( $CronJobsVar );
	if ( ( $Info ) && ( $Info->{File} ) )
	{
	    $Config{ConfigFile}{Updated} = $Info->{File};
	    print "Found '$CronJobsVar' in "
		. $Info->{File} . " line " . $Info->{Line} . "\n";
	}
    }

    # Try to find the file that last defined STARTD_CRON_NAME
    if ( $Config{ConfigFile}{Updated} eq "" )
    {
	my $Info = $ConfigMacros->GetInfo( "STARTD_CRON_NAME" );
	if ( ( $Info ) && ( $Info->{File} ) )
	{
	    $Config{ConfigFile}{Updated} = $Info->{File};
	    print "Found 'STARTD_CRON_NAME' in "
		. $Info->{File} . " line " . $Info->{Line} . "\n";
	}
    }

    # If there's a local config that's named ".jobs" or similar, use it as
    # the config to modify
    if ( $Config{ConfigFile}{Updated} eq "" )
    {
	my $Pat = "(jobs|joblist|hawkeye)\$";
	my @List = $ConfigFiles->GrepNames( $Pat );
	if ( scalar @List )
	{
	    $Config{ConfigFile}{Updated} = shift( @List );
	}
    }

    # If no config specified, use the base
    $Config{ConfigFile}{Updated} = $Config{ConfigFile}{Base}
	if ( $Config{ConfigFile}{Updated} eq "" );
    print "Config Updates will be written to $Config{ConfigFile}{Updated}\n";
    $ConfigFiles->SetUpdateFile( $Config{ConfigFile}{Updated} );


} # ReadConfigFiles
# ******************************************************

# ******************************************************
# DoUpdateConfig
# ******************************************************
sub UpdateConfig( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Config changed?
    return 1 if ( ! $Data->{ConfigChanged} );

    # Feedback if changed
    print "  !!NOTICE!! Configuration for $Name modified; updating..\n";

    # Do it
    $ConfigFiles->AddText( "" );
    $ConfigFiles->AddText( "##" );
    $ConfigFiles->AddText( "## Configuration for Module $Name" );
    foreach my $Text ( @{$Data->{Description}} )
    {
	$ConfigFiles->AddText( "##\t$Text" );
    }

    $ConfigFiles->AddText
	(
	 "$Config{CronJobsVar} = \$($Config{CronJobsVar}) " .
	 $Name . ":" . $Data->{Prefix} . ":" .
	 "\$(MODULES)/" . $Data->{ModuleFile} . ":" .
	 $Data->{Period} . ":" . join(":", @{$Data->{Options}} )
	);
    $ConfigFiles->AddText( "##  Parameters for module $Name:" );
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	$ConfigFiles->AddText( "##  $Param->{Name}" );
	foreach my $Text ( @{$Param->{Description}} )
	{
	    $ConfigFiles->AddText( "##    $Text" );
	}
	my $Default= (defined $Param->{Default} ) ? $Param->{Default} : "";
	$ConfigFiles->AddText( "##    Default: $Default" );

	my $ParamName = uc( $Config{CronName} . "_" . $Name . "_"  .
			    $Param->{Name} );
	if ( defined $Param->{Value} )
	{
	    $ConfigFiles->AddText( "$ParamName = $Param->{Value}" );
	}
	else
	{
	    $ConfigFiles->AddText( "# $ParamName =" );
	}
	$ConfigFiles->AddText( "##" );
    }

    # Check these lines
    $ConfigFiles->AddText( "##" );
    if ( $Data->{OriginalConfigLines} >= 0 )
    {
	my $LineNo = $Data->{OriginalConfigLines};
	my $File = $Data->{OriginalConfigFile};
	$ConfigFiles->AddText( "## Check original configuration:" );
	$ConfigFiles->AddText( "##  $File line $LineNo" );

    }
    $ConfigFiles->AddText( "## End of Configuration for Module $Name" );
    $ConfigFiles->AddText( "##" );

    return 1;

} # DoUpdateConfig()
# ******************************************************

# ******************************************************
# Write the new config file
# ******************************************************
sub WriteConfigFile( )
{
    my $File = $ConfigFiles->GetUpdateFile( );
    open( ORIG, $File ) or die "Can't read config file '$File'";

    my $Pattern = "$File.XXXXXXX";
    my ( $tmp_fh, $tmp_filename ) =
	tempfile( $Pattern, UNLINK => 0 );
    if ( !defined $tmp_fh ) {
	die "error: Can't create temporary file\n";
    }

    # OK, now read the whole file, write to the temp file
    my @Stack;
    while( <ORIG> )
    {
	chomp; s/\s+$//;
	my $DumpStack = 0;
	s/$Config{CronJobsVar}/$Config{CronJobListVar}/g;
	if ( /(.*?)(\w+:\w+:\"[^\"]+\":\S+)([^\\]*)(\\?)/ )
	{
	    my ( $t1, $t2, $t3, $t4 ) = ( $1, $2, $3, $4 );
	    $t4 = undef if ( ( !defined $4 ) or ( $4 eq "" ) );
	    my $Comment = ( $t1 =~ /#/ ) ? "# " : "";

	    my @Tmp = ParseOldJob( $t2, $Comment );

	    my $Line = "$t1" . shift( @Tmp ) . "$t3";
	    $Line .= " \\" if ( defined $t4 );
	    print $tmp_fh "$Line\n";

	    push( @Stack, @Tmp );
	    $DumpStack = 1 if ( ! defined $t4 );
	}
	elsif ( /(.*?)(\w+:\w+:[^:]+:\S+)([^\\]*)(\\?)/ )
	{
	    my ( $t1, $t2, $t3, $t4 ) = ( $1, $2, $3, $4 );
	    $t4 = undef if ( ( !defined $4 ) or ( $4 eq "" ) );
	    my $Comment = ( $t1 =~ /#/ ) ? "# " : "";

	    my @Tmp = ParseOldJob( $t2, $Comment );

	    my $Line = "$t1" . shift( @Tmp ) . "$t3";
	    $Line .= " \\" if ( defined $t4 );
	    print $tmp_fh "$Line\n";

	    push( @Stack, @Tmp );
	    $DumpStack = 1 if ( ! defined $t4 );
	}
	else
	{
	    print $tmp_fh "$_\n";
	}
	if ( $DumpStack )
	{
	    while ( my $Line = shift @Stack )
	    {
		print $tmp_fh "$Line\n";
	    }
	}
    }
    close( ORIG );
    close( $tmp_fh );

    # Done
    return ( $File, $tmp_filename );

}
# ******************************************************

# ******************************************************
# Parse old job line
# ******************************************************
sub ParseOldJob( $$ )
{
    my $Line = shift;
    my $Comment = shift;

    my $Name;
    my $Prefix;
    my $Exe;
    my $End;
    if ( $Line =~ /(\w+):(\w+):(\"[^\"]+\"):(\S+)/ )
    {
	$Name = $1;
	$Prefix = $2;
	$Exe = $3;
	$End = $4;
    }
    elsif ( $Line =~ /(\w+):(\w+):([^:]+):(\S+)/ )
    {
	$Name = $1;
	$Prefix = $2;
	$Exe = $3;
	$End = $4;
    }
    else
    {
	return undef;
    }

    my ( $Period,  @Opts ) = split( /:/, $End );
    my $FullName = uc( $Config{CronName} . "_" . $Name );
	
    my @Stack;
    push( @Stack, $Name );
    push( @Stack, $Comment . $FullName . "_PREFIX = $Prefix" );
    push( @Stack, $Comment . $FullName . "_EXECUTABLE = $Exe" );
    push( @Stack, $Comment . $FullName . "_PERIOD = $Period" );

    my %Data;
    foreach my $Opt ( @Opts )
    {
	if (! ImportOption( $Opt, \%Data ) )
	{
	    print STDERR
		"Line $.: Ignoring unknown option '$Opt' for job '$Name'\n";
	}
    }
    foreach my $Key ( keys %Data )
    {
	my $Parm = uc( $FullName . "_" . $Key );
	my $Value = $Data{$Key};
	push( @Stack, "$Comment$Parm = $Value" );
    }
    return @Stack;

} # ParseOldJob
# ******************************************************

# ******************************************************
# Update the config file
# ******************************************************
sub UpdateConfigFile( )
{

    # Write the updates to the temp file
    my ( $File, $TmpFile ) = WriteConfigFile( );
    if ( ! $File or ! $TmpFile )
    {
	die "Error writing update";
    }

    # Ask the user unless they explicietly asked us to overwrite it
    my $OverWrite = $Config{UpdateConfig};
    if ( ! $OverWrite )
    {
	if ( -f $File )
	{
	    print "\nAbout to overwrite $File; ok [N/y]? ";
	    $OverWrite = 1 if ( <> =~ /^y/ );
	}
	else
	{
	    $OverWrite = 1;
	}
    }

    # OverWrite it?
    if ( $OverWrite )
    {
	my $Backup = "$File.bak";
	unlink( $Backup );
	rename( $File, $Backup );
	rename( $TmpFile, $File );
	print "\n$File updated\n";
    }
    else
    {
	print "Updated config saved in $TmpFile\n";
    }

    return 1;

} # UpdateConfigFile()
# ******************************************************

# ******************************************************
# Import an option line
# ******************************************************
sub ImportOption( $$ )
{
    my $Opt = shift;
    my $Data = shift;

    $Opt = lc( $Opt );
    if ( ! exists $ConfigOptions{$Opt} )
    {
	return 0;
    }
    else
    {
	foreach my $Key ( keys %{$ConfigOptions{$Opt}} )
	{
	    $Data->{$Key} = $ConfigOptions{$Opt}{$Key};
	}
    }

    return 1;

} # ImportOption()
# ******************************************************

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( defined $Unknown );
    printf "usage: $Program [options] [files]\n";
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program [options] [files]\n";
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
