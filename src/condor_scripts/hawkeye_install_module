#! /usr/bin/perl -w
use strict;
$| = 1;

# Prototypes
sub Main( );
sub CommandLine( @ );
sub FindConfigFile( );
sub ReadConfigFile( );
sub ReadDescriptionFile( $$ );
sub InstallModules( );
sub InstallModule( $ );
sub ConfigureModule( $ );
sub ProcessConfigLine( $ );
sub WriteConfig( );
sub Expand( $ );
sub Usage ( $ );
sub Help ( );

# ******************************************************
# Command line options
# ******************************************************
my $Distribution = "hawkeye";
my %Options =
    (
     "[--modules=dir]"	=> "Specify modules directory",
     "[--config=file]"	=> "Specify $Distribution config file",
     "[--noupdate|-n]"	=> "Don't update the config file",
     "[--manual|-m]"	=> "Manual mode; asks lots of questions",
     "[--defaults]"	=> "Use defaults if possible",
     "[--all|-a]"	=> "Install all modules found in packages",
     "[--ask]"		=> "Ask before installing each module",
     "File [File..]"	=> "List of module package files to install",
     "[--help|-h]"	=> "Dump help",
    );

# Hash of directories & files
my %Config = (
	      RootDir => "",
	      ConfigFile => "",
	      ModulesDir => "",
	      UpdateConfig => 0,
	      UseDefaults => 1,
	      AskAll => 0,
	      InstallAll => 1,
	      Startd => -1,
	      );
my %ConfigMacros;
my @ConfigLines;

# Valid "Options"
my @ModuleOptions = qw ( continuous kill nokill reconfig waitforexit );
my $ModuleOptionsRe =
    "(" . join( ")|(", @ModuleOptions ) . ")";

# "Main" Logic
if ( ! exists $ENV{PWD} )
{
    $ENV{PWD} = `/bin/pwd`; chomp $ENV{PWD};
}

# Look at $0, see what we can gleen from it...
if ( $0 =~ /(condor|hawkeye)_install/ )
{
    $Distribution = $1;
}
if ( exists $ENV{CONDOR_DISTRIBUTION} )
{
    $Distribution = $1;
}
my $Program = $Distribution . "_install_module";
my $ConfigEnv = uc $Distribution . "_CONFIG";

# Process command line, etc..
CommandLine( @ARGV );
$#ARGV = -1;
$| = 1;

# Find the config file to use
$ENV{$ConfigEnv} = $Config{ConfigFile} if ( ! exists $ENV{$ConfigEnv} );
FindConfigFile( );

# Read the config file
ReadConfigFile( );

# Install the modules
InstallModules( );

# end of "main"
# ******************************************************

# ******************************************************
# Parse the command line, etc.
# ******************************************************
sub CommandLine( @ )
{
    foreach my $Arg ( @_ )
    {
	# Speicfy modules directory
	if ( $Arg =~ /^--modules=(.+)/ )
	{
	    die "Directory '$1' does not exist" if ( ! -d $1 );
	    $Config{ModulesDir} = $1;
	}
	# Speicify config file
	elsif ( $Arg =~ /--config=(.+)/ )
	{
	    die "Config file '$1' does not exist" if ( ! -f $1 );
	    my $File = $1;
	    if ( ! $File =~ /^\// )
	    {
		$File = $ENV{PWD} . "/$File";
	    }
	    $Config{ConfigFile} = $File;
	}
	# No config update
	elsif ( ( $Arg eq "-u") || ( $Arg eq "--update" ) )
	{
	    $Config{UpdateConfig} = 1;
	}
	# "Install all modules" mode
	elsif ( ( $Arg eq "-a" ) || ( $Arg eq "--all" ) )
	{
	    $Config{InstallAll} = 1;
	}
	# "Ask" mode
	elsif ( $Arg eq "--ask" )
	{
	    $Config{InstallAll} = 0;
	}
	# Manual mode
	elsif ( ( $Arg eq "-m" ) || ( $Arg eq "--manual" ) )
	{
	    $Config{InstallAll} = 0;
	    $Config{UseDefaults} = 0;
	    $Config{AskAll} = 1;
	}
	# Hawkeye mode
	elsif ( $Arg eq "--hawkeye" )
	{
	    $Distribution = "hawkeye";
	}
	# Condor mode
	elsif ( $Arg eq "--condor" )
	{
	    $Distribution = "condor";
	}
	# Help
	elsif ( ( $Arg =~ /^-h/ ) || ( $Arg eq "--help" ) )
	{
	    Help( );
	    exit 0;
	}
	elsif ( $Arg =~ /^-/ )
	{
	    Usage( $Arg );
	    exit( 1 );
	}
	else
	{
	    if ( ! -f $Arg )
	    {
		print STDERR "Warning: Can't find $Arg\n";
		next;
	    }
	    # Make sure it's absolute
	    if ( $Arg =~ /^\// )
	    {
		push( @{$Config{Modules}}, $Arg );
	    }
	    else
	    {
		push( @{$Config{Modules}}, $ENV{PWD} . "/$Arg" );
	    }
	}
    }

    # Any modules to install?
    if ( $#{@{$Config{Modules}}} < 0 )
    {
	print STDERR "No modules specified\n";
	Usage( "" );
	exit 1;
    }

} # CommandLine( )
# ******************************************************

# ******************************************************
# Find the configuration file to use
# ******************************************************
sub FindConfigFile( )
{

    # Check the config env variable...
    if ( ( $Config{ConfigFile} eq "" ) && ( exists $ENV{$ConfigEnv} ) )
    {
	warn "$ENV{$ConfigEnv} (from ENV) does not exist!"
	    if ( ! -f $ENV{$ConfigEnv} );
	$Config{ConfigFile} = $ENV{$ConfigEnv};
    }

    # Fallbacks...
    my @FallbackConfigs = [ "/home/$Distribution", ];
    my $RootEnv = uc $Distribution . "_ROOT_DIR";
    unshift @FallbackConfigs, $ENV{$RootEnv}
	if ( exists $ENV{$RootEnv} );
    foreach my $TempConfig ( @FallbackConfigs )
    {
	if (  ( $Config{ConfigFile} eq "" ) && ( -f $TempConfig )  )
	{
	    $Config{ConfigFile}{ConfigFile} = $TempConfig;
	}
    }

    # Finally, let's go check the config
    if ( $Config{ConfigFile} eq "" )
    {
	print STDERR "No config found\n";
	Usage( "" );
	print STDERR "\tOr, set the $ConfigEnv env variable\n";
	exit 1;
    }

} # FindConfigFile()
# ******************************************************

# ******************************************************
# Read the config file
# ******************************************************
sub ReadConfigFile( )
{
    print "Reading config file $Config{ConfigFile}...";
    open( CONFIG, $Config{ConfigFile} ) ||
	die "Can't read config @ $Config{ConfigFile}";
    my $Line = "";
    while( <CONFIG> )
    {
	chomp;
	push @ConfigLines, $_;
	s/^\s+//;
	s/\s+$//;

	# Comment?
	if ( /\#/ )
	{
	    ProcessConfigLine( $Line ) if ( $Line ne "" );
	    $Line = "";
	}

	# Continuation?
	elsif ( /(.*)\\$/ )
	{
	    $Line = ( $Line eq "" ) ? $1 : $Line . " " . $1;
	}

	# "Normal" line
	else
	{
	    $Line = ( $Line eq "" ) ? $_ : $Line . " " . $_;
	    ProcessConfigLine( $Line ) if ( $Line ne "" );
	    $Line = "";
	}
    }
    close( CONFIG );
    print "Done\n";

    # Ok, let's find the by evaluating the config
    if ( $Config{ModulesDir} eq "" )
    {
	my $Tmp = Expand( "MODULES" );
	$Config{ModulesDir} = $Tmp if ( ( defined $Tmp ) && ( -d $Tmp ) );
    }
    # Last resort
    if ( $Config{ModulesDir} eq "" )
    {
	if ( $Config{ConfigFile} =~ /(.*)\/hawkeye_config/ )
	{
	    my $Tmp = $1 . "/modules";
	    $Config{ModulesDir} = $Tmp if ( -d $Tmp );
	}
    }

    # Give up...
    die "Unable to find modules directory\n"
	if ( $Config{ModulesDir} eq "" );


    # Add basic things to the config if they're not defined...
    my $CronName = Expand( "STARTD_CRON_NAME" );
    if ( ! defined $CronName )
    {
	push @ConfigLines, "STARTD_CRON_NAME = Hawkeye";
	$ConfigMacros{STARTD_CRON_NAME} = "Hawkeye";
    }
    my $Modules = Expand( "MODULES" );
    if ( ! defined $Modules )
    {
	my $Value = $Config{ConfigFile};
	my $Hawkeye = Expand( "HAWKEYE" );
	if ( defined $Hawkeye )
	{
	    $Hawkeye =~ s/\//\\\//g;
	    $Value = "\$(HAWKEYE)/$1" if ( $Value =~ /^$Hawkeye\/(.*)/ );
	}
	push @ConfigLines, "MODULES = $Value";
	$ConfigMacros{MODULES} = $Value;
    }
    my $Jobs = Expand( "HAWKEYE_JOBS" );
    if ( ! defined $Jobs )
    {
	push @ConfigLines, "HAWKEYE_JOBS = ";
	$ConfigMacros{HAWKEYE_JOBS} = "";
    }

    print "Found modules directory '$Config{ModulesDir}'\n";

} # ReadConfigFile
# ******************************************************

# ******************************************************
# Configure & Install all Modules
# ******************************************************
sub InstallModules ( )
{
    my $TmpDir = "/tmp/$$";
    my $OrigDir = $ENV{PWD};
    die "$TmpDir already exists!" if ( -d $TmpDir );
    mkdir( $TmpDir, 0700 ) || die "Can't mkdir '$TmpDir'";
    chdir $TmpDir || die "Can't chdir to $TmpDir";

    # Summary info
    my @Ok;
    my @Failed;
    my $ConfigUpdated = 0;

    # Walk through the list of modules...
    print "Installing modules\n";
    foreach my $Module ( @{$Config{Modules}} )
    {
	die "$Module does not exist" if ( ! -f $Module );
	my $Cmd = "gzip -d < $Module | tar xvfp -";
	if ( system "$Cmd 2>&1 > /dev/null" )
	{
	    warn "Error extracting '$Module'\n";
	    next;
	}

	opendir( DIR, $TmpDir ) || die "Can't read dir $TmpDir";
	my @Files = grep { /^[^\.]/ } readdir( DIR );
	closedir( DIR );

	# Find the description ".hawk" file...
	my @DatFiles = grep { /\.hawk$/ } @Files;
	if ( $#DatFiles < 0 )
	{
	    print STDERR "$Module does not appear to be a valid module file\n";
	    system "/bin/rm *";
	    next;
	}

	# Loop through the list of modules to install...
	foreach my $Description ( @DatFiles )
	{
	    my %ModuleData;

	    # Read the description file for this module..
	    my $Errors = ReadDescriptionFile( $Description, \%ModuleData );
	    if ( $Errors )
	    {
		print "Errors encountered in description " .
		  "file; skipping $Module\n";
		push @Failed, $Module;
		next;
	    }

	    # Get it's name..
	    my $Name = $ModuleData{Name};
	    print "\n\nModule $Name:\n";

	    # Install it?
	    my $Status = InstallModule( \%ModuleData );
	    if ( $Status )
	    {
		push @Failed, $Module if ( $Status < 0 );
		next;
	    }

	    # Enable it?
	    if ( ! $Config{InstallAll} )
	    {
		print "  Do you wish to enable this module? ";
		my $Answer = "";
		while( <> )
		{
		    chomp;
		    if ( /^[yn]/i )
		    {
			$Answer = lc($_);
			last;
		    }
		    print "  Please answer 'y' or 'n': ";
		}
		next if ( $Answer ne "y" );
	    }

	    # Configure it?
	    if ( ! ConfigureModule( \%ModuleData ) )
	    {
		push @Failed, $Module if ( $Status < 0 );
		next;
	    }

	    # Update the config file
	    $Status = UpdateConfig( \%ModuleData );

	    # Add to the failed list?
	    if ( $Status < 0 )
	    {
		push @Failed, $Module
	    }
	    elsif ( $Status == 1 )
	    {
		push @Ok, $Name;
		$ConfigUpdated += $ModuleData{ConfigChanged};
	    }
	}

	# Clean up
	system( "/bin/rm *" );

    }

    # Create the new config file
    if ( $ConfigUpdated )
    {
	WriteConfig( );
    }
    else
    {
	print "No configuration updates required\n";
    }

    # Final clean-up
    chdir $OrigDir;
    system "/bin/rm -fr $TmpDir";

    # Summary
    if ( $#Ok >= 0 )
    {
	print "Fully installed modules:\n";
	foreach my $Tmp ( @Ok )
	{
	    print "   $Tmp\n";
	}
    }
    if ( $#Failed >= 0 )
    {
	print "Failed modules:\n";
	foreach my $Tmp ( @Failed )
	{
	    print "   $Tmp\n";
	}
    }

} # InstallModules()
# ******************************************************

# ******************************************************
# Read the module description file
# ******************************************************
sub ReadDescriptionFile( $$ )
{
    my $DescriptionFile = shift;
    my $Data = shift;

    if ( ! open( DESCRIPTION, $DescriptionFile ) )
    {
	print "Can't read description file '$DescriptionFile'; skipping\n";
	return -1;
    }

    # List of keywords..
    my @KeyWords =
	qw ( modulefiles default options parameter period version );
    my $KeyWordsRe =
	"^(" . join( ":)|(", @KeyWords ) . ":)";
    #print "KeyWordsRe='$KeyWordsRe'\n";

    # Read the description file
    my $Errors = 0;
  READLINE:
    while( <DESCRIPTION> )
    {
	chomp;
	my $Orig = $_;
	s/\#.*//;
	s/^\s+//;
	s/\s+$//;
	next if ( $_ eq "" );

	# Parse the line..

	# Module files
	if ( /MODULEFILES:\s*(.+)/i )
	{
	    my @Files = split( /\s+/, $1 );
	    foreach my $File ( @Files )
	    {
		if ( ! -f $File )
		{
		    print STDERR
			"Can't find '$File' specified in module line $.\n";
		    $Errors++;
		}
	    }

	    # Store it all away...
	    $Data->{ModuleFile} = shift @Files
		if ( ! exists $Data->{ModuleFiles} );
	    push( @{$Data->{OtherFiles}}, \@Files )
		if ( $#Files >= 0 );
	    $#Files = -1;
	}

	# Description
	elsif ( /DESCRIPTION:/i )
	{

	    # Read the module description
	    my @Description;
	    while( <DESCRIPTION> )
	    {
		chomp;
		s/\s+$//;
		my $Key = $_; $Key =~ s/\s.*$//;
		if ( ( $_ eq "" ) || ( /^\#/ ) || ( $Key =~ /$KeyWordsRe/i ) )
		{
		    #print "Key '$Key' matches\n";
		    $Data->{Description} = \@Description;
		    redo READLINE;
		}
		push @Description, $_;
	    }
	}

	# Default name
	elsif ( /DEFAULT:\s*(\S+)/i )
	{
	    $Data->{DefaultName} = $1;
	}

	# Prefix
	elsif ( /PREFIX:\s*(\S+)/i )
	{
	    $Data->{Prefix} = $1;
	}

	# Version (stored, but not used)
	elsif ( /VERSION:\s*(\S+)/i )
	{
	    $Data->{Version} = $1;
	}

	# Period
	elsif ( /PERIOD:\s*((\d+)[sSmMhHdD]?)/i )
	{
	    if ( $2 <= 0 )
	    {
		print STDERR "Period must be > 0\n";
		$Errors++;
	    }
	    else
	    {
		$Data->{Period} = $1;
	    }
	}

	# Options
	elsif ( /OPTIONS:\s*(.*)/i )
	{
	    @{$Data->{Options}} = split( /\s+/, $1 );
	    foreach my $Opt ( @{$Data->{Options}} )
	    {
		if ( ! $Opt =~ /$ModuleOptionsRe/i )
		{
		    print STDERR "Line $.: Unknown option '$Opt'\n";
		    $Errors++;
		}
	    }
	}

	# Parameter
	elsif ( /PARAMETER:\s*(\S+)(\s+=(.*))?/i )
	{
	    my $p = ();
	    my $ParamName = $1;
	    my $OrigName = $1;
	    $p->{Default} = $3 if ( defined $3 );

	    # For backward compatibility, mesage the old
	    # HAWKEYE_<NAME>_<PARAM>
	    # parameter names to just plain <PARAM>
	    my $Pat1 = "hawkeye_" . $Data->{DefaultName} . "_(\\w+)";
	    my $Pat2 = "hawkeye_[a-zA-Z]+_(\\w+)";
	    if ( $ParamName =~ /^$Pat1$/i )
	    {
		$ParamName = $1;
	    }
	    elsif ( $ParamName =~ /^$Pat2/i )
	    {
		$ParamName = $1;
	    }
	    $p->{Name} = $ParamName;
	    $p->{OrigName} = $OrigName;
	    $p->{Required} = 0;
	    my @Description;
	    while( <DESCRIPTION> )
	    {
		chomp;
		s/\s+$//;

		# Is it a keyword (ie the start of something else)?
		my $Key = $_; $Key =~ s/\s.*$//;
		if ( ( $_ eq "" ) || ( /^\#/ ) || ( $Key =~ /$KeyWordsRe/i ) )
		{
		    $p->{Description} = \@Description;
		    push ( @{$Data->{Parameters}}, $p );
		    $p = ();
		    redo READLINE;
		}

		# Parse flags, if provided
		elsif ( /^flags:\s*(.*)/i )
		{
		    foreach my $Flag ( split( /[\s+\,]+/, lc $1 ) )
		    {
			if ( $Flag eq "required" )
			{
			    $p->{Required} = 1;
			}
			else
			{
			    print STDERR "Line $.: Unknown flag '$Flag'\n";
			    $Errors++;
			}
		    }
		    next;
		}

		# Must be a description line; add it
		else
		{
		    s/$OrigName/$ParamName/ if ( $OrigName ne $ParamName );
		    push @Description, $_;
		}
	    }

	    # Store it
	    $p->{Description} = \@Description;
	    push (@{$Data->{Parameters}}, $p );
	    $p = ();

	    # Done
	    last;
	}

	# Unknown
	else
	{
	    print "Can't parse dat file '$DescriptionFile' line $.\n";
	    print "$Orig\n";
	    $Errors++;
	}
    }
    close( DESCRIPTION );


    # For backward compatibility, message the old HAWKEYE_<NAME>_<PARAM>
    # parameter names to just plain <PARAM>
    # Clean up the description, too
    for my $Param ( @{$Data->{Parameters}} )
    {
	next if ( $Param->{Name} eq $Param->{OrigName} );
	foreach my $LineNo ( 0 .. $#{$Data->{Description}} )
	{
	    $Data->{Description}[$LineNo] =~
		s/$Param->{OrigName}/$Param->{Name}/;
	}
    }

    # Final checks
    if ( ! exists $Data->{ModuleFile} )
    {
	print STDERR "No module file specified\n";
	$Errors++;
    }
    if ( ! exists $Data->{Period} )
    {
	print STDERR "No period specified\n";
	$Errors++;
    }

    # Finally, fill in some defaults...
    my $Name = $Data->{ModuleFile};
    $Name = $Data->{DefaultName} if ( exists $Data->{DefaultName} );
    $Data->{Name} = $Name;

    # Prefix
    $Data->{Prefix} = $Name . "_" if ( ! exists $Data->{Prefix} );

    return $Errors;

} # ReadDescriptionFile()
# ******************************************************

# ******************************************************
# Install the module
# ******************************************************
sub InstallModule( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Should we install this?
    foreach my $Text ( @{$Data->{Description}} )
    {
	print "\t$Text\n";
    }
    # Only ask if the InstallAll option is off
    if ( ! $Config{InstallAll} )
    {
	print "  Do you wish to install this module? ";
	my $Answer = "";
	while( <> )
	{
	    chomp;
	    if ( /^[yn]/i )
	    {
		$Answer = lc($_);
		last;
	    }
	    print "  Please answer 'y' or 'n': ";
	}
	return 1 if ( $Answer ne "y" );
    }

    # Install the files..
    $| = 1;
    foreach my $File ( $Data->{ModuleFile}, @{$Data->{OtherFiles}} )
    {
	print "  File = '$File'\n";
	my $Cmd = "cp $File $Config{ModulesDir}";
	print "\t$File -> $Config{ModulesDir}...";
	system $Cmd;
	print "\n";
    }

    # Check to see if it's already configured
    my $Found = 0;
    my $JobString = Expand( "HAWKEYE_JOBS" );
    foreach my $Job ( split( /\s+/, $JobString ) )
    {
	my @Fields = split( /:/, $Job );
	if ( scalar @Fields >= 4 )
	{
	    if ( $Fields[0] eq $Name )
	    {
		$Found++;
		$Data->{Current}{Name} = shift @Fields;
		$Data->{Current}{Prefix} = shift @Fields;
		$Data->{Current}{Path} = shift @Fields;
		$Data->{Current}{Period} = shift @Fields;
		if ( scalar @Fields )
		{
		    @{$Data->{Current}{Options}} = @Fields;
		}
		else
		{
		    $#{@{$Data->{Current}{Options}}} = -1;
		}
		last;
	    }
	}
    }
    $Data->{Configured} = $Found;

    # Done
    return 0;

} # InstallModule( )
# ******************************************************

# ******************************************************
# Configure the module
# ******************************************************
sub ConfigureModule( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};
    my $NeedsConfig = $Config{AskAll};
    my $OldLineNum = -1;
    my $Errors = 0;

    # By default, nothing has changed.
    $Data->{ConfigChanged} = 0;

    # If we've already found this one, try to use the old values
    if ( $Data->{Configured} )
    {
	my $Match = uc( $Distribution . "_JOBS" ) . ".*\\s$Name:";
	for my $i ( 0 .. $#ConfigLines )
	{
	    my $Line = $ConfigLines[$i];
	    $Line =~ s/\#.*$//;
	    if ( $Line =~ /$Match/ )
	    {
		$OldLineNum = $i;
		last;
	    }
	}

	my $Import = 0;
	if ( $Config{NoAsk} )
	{
	    $Import = 1;
	}
	else
	{
	    print "  Previous configuration for $Name found; import it? ";
	    $_ = <>;
	    if ( $_ =~ /^y/i )
	    {
		$Import = 1;
	    }
	}

	# Ok, import from the old
	if ( $Import )
	{
	    $Data->{Options} = $Data->{Current}{Options};
	    $Data->{Prefix}  = $Data->{Current}{Prefix};
	    $Data->{Period}  = $Data->{Current}{Period};

	    # UPdate the defaults with the old values
	    foreach my $Param ( @{$Data->{Parameters}} )
	    {
		my $ParamName =
		    uc( $Distribution . "_" . $Name . "_" . $Param->{Name} );
		my $Current = Expand( $ParamName );
		$Param->{Current} = $Current;
		$Param->{Default} = $Current
		    if ( ( defined $Current ) && ( $Current ne "" ) );
	    }
	}
    }
    else
    {
	# Nothing to import; by definition modified!!
	$Data->{ConfigChanged}++;
    }

    # Give the user an update
    my @Required;
    print "  Logical name: $Name\n";
    print "  Options: " . join( " ", @{$Data->{Options}} ) . "\n";
    print "  ClassAd prefix: " . $Data->{Prefix} . "\n";
    print "  Parameters:\n";
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	$Param->{String} = "<NONE>";
	if ( exists $Param->{Default} && $Param->{Default} ne "" )
	{
	    $Param->{String} = $Param->{Default};
	}
	print "    $Param->{Name} = $Param->{String}\n";
	if ( $Param->{Required} )
	{
	    if ( !exists $Param->{Default} || $Param->{Default} eq "" )
	    {
		push( @Required, $Param->{Name} );
		$NeedsConfig++;
	    }
	}
    }

    # Fill in the default parameter values
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	next if ( ! exists $Param->{Default} );
	if ( exists $Param->{Current} && $Param->{Current} ne $Param->{Default} )
	{
	    $Data->{ConfigChanged}++;
	}
	$Param->{Value} = $Param->{Default};
    }

    # Fill in the location of the original config
    $Data->{OriginalConfigLines} = $OldLineNum;

    # Check the results
    if ( $Config{NoAsk} )
    {
	# Done
	if ( $Data->{ConfigChanged} && ( $OldLineNum >= 0 ) )
	{
	    print "  Check original configuration lines around line ".
		"$OldLineNum\n";
	}
	return 1;
    }

    # Are we done?
    if ( $NeedsConfig )
    {
	print "  $NeedsConfig parameters require configuration; forcing\n";
    }
    else
    {
	print "  Would you like to change these settings (N/y): ";
	$_ = <>;
	$NeedsConfig = 1 if ( $_ =~ /^y/i );
    }

    # What name to give it?
    if ( $NeedsConfig )
    {
	print "  What logical name do you wish to use <default=$Name>: ";
	$_ = <>; chomp;
	if ( /\S/ )
	{
	    my $NewName = $_;
	    if ( $NewName ne $Name )
	    {
		$Data->{Name} = $Name = $NewName;
		$Data->{ConfigChanged}++;
	    }
	    print "  New name -> '$Name'\n";
	}
    }

    # Options
    if ( $NeedsConfig )
    {
	print "  Default options for $Name = " .
	    join( " ", @{$Data->{Options}} ) . "\n";

	# Get options from the user
	while( 1 )
	{
	    print "  What options would you like set ".
		"<enter = default; \"none\"; list>: ";
	    $_ = <>; chomp; s/^\s+//;
	    if ( $_ eq "none" )
	    {
		$#{@{$Data->{Options}}} = -1;
		last;
	    }
	    elsif ( $_ ne "" )
	    {
		my @Options = split;
		foreach my $Opt ( @Options )
		{
		    if ( ! ( $Opt =~ /$ModuleOptionsRe/i ) )
		    {
			print STDERR "  -> Unknown option '$Opt'\n";
			$Errors++;
		    }
		}
		if ( ! $Errors )
		{
		    $Data->{Options} = @Options;
		    $Data->{ConfigChanged}++;
		    last;
		}
	    }
	    else
	    {
		# Empty line; use defaults
		last;
	    }
	}
    }

    # Period
    if ( $NeedsConfig )
    {
	my $Default = "";
	my $DefString = "<no default>";
	if ( defined $Data->{Period} )
	{
	    $Default = $Data->{Period};
	    $DefString = "<enter = $Default>";
	}
	print "  Default period for $Name = $Default\n";
	while( 1 )
	{
	    print "  At what period should this module run " .
		"(s/m/h/d modifiers ok) $DefString? ";
	    $_ = <>; chomp;
	    last if ( ( $_ eq "" ) && ( $Default ne "" ) );
	    if ( /^(\d+[sSmMhHdD]?)$/)
	    {
		$Data->{Period} = $1;
		$Data->{ConfigChanged}++;
		last;
	    }
	    print "  '$_' is invalid.  Please enter a number ".
		"optionally followed by an s, an m, h, or a d\n";
	}
    }

    # Prefix
    if ( $Config{AskAll} )
    {
	print "  What prefix would you like for the ClassAd ".
	    "<enter = $Data->{Prefix}> ";
	$_ = <>; chomp;
	if ( $_ ne "" )
	{
	    $Data->{Prefix} = $_;
	    $Data->{ConfigChanged}++;
	}
    }

    # Parameter questions
    if ( $#{@{$Data->{Parameters}}} >= 0 )
    {
	if ( $NeedsConfig || scalar( @Required ) )
	{
	    print "  Parameters for module $Name:\n";
	    foreach my $Param ( @{$Data->{Parameters}} )
	    {
		next if ( !$NeedsConfig &&
			  !$Param->{Required} && $Param->{Value} eq "" );

		print "     $Param->{Name}\n";
		print "\t" . join( "\n\t", @{$Param->{Description}} );
		print "\n\tDefault: " . $Param->{String} . "\n";
		print "\tWhat value would you like for $Param->{Name}?".
		    " <enter for default> ";
		$_ = <>; chomp;

		$Param->{Value} = ( $_ eq "" ) ? $Param->{Default} : $_;
		$Data->{ConfigChanged}++;
	    }
	}
    }

    # Problems?
    if ( $Errors )
    {
	return 0;
    }
    return 1;

} # ConfigureModule()
# ******************************************************

# ******************************************************
# UpdateConfig
# ******************************************************
sub UpdateConfig( $ )
{
    my $Data = shift;
    my $Name = $Data->{Name};

    # Config changed?
    return 1 if ( ! $Data->{ConfigChanged} );

    # Do it
    print "  Updating config for $Name\n";
    push( @ConfigLines, "" );
    push( @ConfigLines, "##" );
    push( @ConfigLines, "## Configuration for Module $Name" );
    foreach my $Text ( @{$Data->{Description}} )
    {
	push( @ConfigLines, "##\t$Text" );
    }
    push( @ConfigLines,
	  "HAWKEYE_JOBS = \$(HAWKEYE_JOBS) " .
	  $Name . ":" . $Data->{Prefix} . ":" .
	  "\$(MODULES)/" . $Data->{ModuleFile} . ":" .
	  $Data->{Period} . ":" . join(":", @{$Data->{Options}} ) );
    push( @ConfigLines, "##  Parameters for module $Name:" );
    foreach my $Param ( @{$Data->{Parameters}} )
    {
	push( @ConfigLines, "##  $Param->{Name}" );
	foreach my $Text ( @{$Param->{Description}} )
	{
	    push( @ConfigLines, "##    $Text" );
	}
	my $Default= (defined $Param->{Default} ) ? $Param->{Default} : "";
	push( @ConfigLines, "##    Default: $Default" );

	my $ParamName = uc( "HAWKEYE_" . $Name . "_"  . $Param->{Name} );
	if ( defined $Param->{Value} )
	{
	    push( @ConfigLines, "$ParamName = $Param->{Value}" );
	}
	else
	{
	    push( @ConfigLines, "# $ParamName =" );
	}
    }

    # Check these lines
    push( @ConfigLines, "##" );
    if ( $Data->{OriginalConfigLines} >= 0 )
    {
	my $LineNo = $Data->{OriginalConfigLines} + 1;
	my $Text = "## Check original configuration around line $LineNo "
	       . "in config file";
	push( @ConfigLines, $Text );

    }
    push( @ConfigLines, "## End of Configuration for Module $Name" );
    push( @ConfigLines, "##" );

    return 1;

} # UpdateConfig()
# ******************************************************

# ******************************************************
# Write the new config file
# ******************************************************
sub WriteConfig( )
{
    my $TmpFile = "Config{ConfigFile}.$$";
    open( TMP, ">$TmpFile" ) || die "Can't create temp config '$TmpFile'";
    foreach my $Line ( @ConfigLines )
    {
	print TMP "$Line\n";
    }
    close( TMP );

    # Ask the user unless they explicietly asked us to overwrite it
    my $OverWrite = $Config{UpdateConfig};
    if ( ! $OverWrite )
    {
	print "About to overwrite $Config{ConfigFile}; ok? ";
	$OverWrite = 1 if ( <> =~ /^y/ );
    }

    # OverWrite it?
    if ( $OverWrite )
    {
	system( "/bin/cp $TmpFile $Config{ConfigFile}" );
	print "\n$Config{ConfigFile} updated\n";
    }
    else
    {
	system( "/bin/cp $TmpFile $Config{ConfigFile}.$$" );
	print "New config in $Config{ConfigFile}.$$\n";
    }

    return 1;

} # WriteConfig()
# ******************************************************

# ******************************************************
# Expand a macro from the config file
# ******************************************************
sub ProcessConfigLine( $ )
{
    my $Line = shift;

    $Line =~ s/^\s+//;
    $Line =~ s/\s+$//;
    return 0 if ( $Line eq "" ) ;

    # MACRO = value
    if ( $Line =~ /^(\S+)\s*=\s*(.+)/ )
    {
	my $Macro = uc( $1 );
	my $Value = $2;

	if ( exists $ConfigMacros{$Macro} )
	{
	    my $CurValue = $ConfigMacros{$Macro};
	    $Value =~ s/\$\($Macro\)/$CurValue/g;
	}
	$ConfigMacros{$Macro} = $Value;
    }
    elsif ( $Line =~ /^(\S+)\s*=$/ )
    {
	my $Macro = uc( $1 );
	$ConfigMacros{$Macro} = "";
    }
}

# ******************************************************
# Expand a macro from the config file
# ******************************************************
sub Expand( $ )
{
    my $Var = shift;

    # No dice; try getting it from the startd
    if ( ! exists ( $ConfigMacros{$Var} ) )
    {
	# Can we / should we?
	if ( $Config{Startd} )
	{
	    print "Trying to contact the startd to expand '$Var'...\n";
	    my $Cmd = "hawkeye_config_val -startd MODULES";
	    my $Tmp = `$Cmd`;

	    if ( $Tmp eq "" )
	    {
		print "-- Unable to contact the startd --\n";
		$Config{Startd} = 0;
	    }
	    else
	    {
		# Note that the startd is available..
		$Config{Startd} = 1;
		if ( $Tmp ne "Not defined" )
		{
		    $ConfigMacros{ModulesDir} = $Tmp;
		    return $Tmp;
		}
	    }
	}
    }

    # One more check
    return undef if ( ! exists ( $ConfigMacros{$Var} ) );

    # Now, expand it out...
    my $Value = $ConfigMacros{$Var};
    while( $Value =~ /(.*)\$\((\w+)\)(.*)/ )
    {
	if ( $2 eq $Var )
	{
	    $Value = $1 . $3;
	}
	elsif ( exists ( $ConfigMacros{$2} ) )
	{
	    $Value = $1 . $ConfigMacros{$2} . $3;
	    last if ( $2 eq $Var );
	}
	elsif ( exists ( $ENV{$2} ) )
	{
	    $Value = $1 . $ENV{$2} . $3;
	    last if ( $2 eq $Var );
	}
	else
	{
	    print STDERR "Warning: Unable to expand $Value\n";
	    last;
	}
    }
    $Value;

} # Expand()
# ******************************************************

# ******************************************************
# Dump out usage
# ******************************************************
sub Usage ( $ )
{
    my $Unknown = shift;

    print "$Program: unknown option '$Unknown'\n" if ( $Unknown ne "" );
    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    print "use '-h' for more help\n";
    exit 1;

} # usage ()
# ******************************************************

# ******************************************************
# Dump out help
# ******************************************************
sub Help ( )
{
    my ($opt, $text);

    printf "usage: $Program %s\n", join (" ", sort keys %Options);
    foreach $opt (sort {lc($a) cmp lc($b) } keys %Options)
    {
	printf ("  %15s : %-40s\n", $opt, $Options{$opt} );
    }
    exit 0;

} # help ()
# ******************************************************
