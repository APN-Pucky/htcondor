/*
  How to read this file:

  This file is used to generate 3 C language files -  "switches.c",
  "senders.c", and "receivers.c".  Not all of the information contained
  here is needed in every case.

  Switches are functions which are linked in with the user's code, and
  have the same names as the system call they are intended to invoke.
  The switch will determine whether the call should be done locally or
  remotely, and will invoke an appropriate mechanism to accomplish
  that.  In the case of local execution, that will most often be the
  syscall() routine.  In the case of remote calls, that will always be
  the REMOTE_syscall() routine.  The syscall() routine is generally
  provided in the C library, and REMOTE_syscall() is provided by
  Condor.  More on this in the next paragraph...

  Senders are the part of the code which packages up the arguments of a
  system call, sends them to the shadow for remote execution, and then
  package up the results so it looks to the calling routine as though
  the normal system call were done.  The REMOTE_syscall() routine is
  organized as a giant switch() statement, with one "case" for each
  system call.  Each case is called a "sender".

  Receivers are the part of the code which runs on the submitting
  machine that matches with the sender.  The receiver reads all the
  arguments to the system call, performs the call, then sends back the
  results.  We plan to eventually generate the recievers from this
  template file, but the current code doesn't do it.

  The general format of this file is a function prototype for every
  system call.  Those give the system call return type, the name, and
  the names and types of each of the system call arguments.  The system
  call prototypes have been augmented with other information needed to
  generate correct switches, senders, and receivers.  Each type of
  augmenting information is described here:

  : extract
	  Some system calls cannot be successfully executed by the syscall()
	  routine.  This is generally becuase syscall() expects that every
	  system call will pass its return value through register 0.  A few
	  system calls like getuid() will actually return 2 values, the
	  real uid in register 0, and the effective uid in register 1.  In
	  that case, there is no system call geteuid() - that information is
	  gotten as a side effect of the getuid() system call.  For this
	  reason geteuid() doesn't work with syscall().  In such a case
	  another means must be found to execute the offending system call.
	  We extract from the C library a copy of whatever the normal system
	  call stub is, and change the name by making it all upper case.
	  For example geteuid() becomes GETEUID().  The switch generator must
	  know that geteuid() has to be handled specially in the local case,
	  which is the meaning of "extract".

  in xdr_bytes( &buf, &len, len );
	  A statement like this appears with the prototype for the
	  write() system call.  Note that the parameter "buf" is a
	  pointer to void, and it is not immediately obvious whether
	  data should be sent to the remote system call receiver,
	  whether data should be sent back, or both.  Also, "buf" tells
	  us where the data starts, but it is not obvious (from the
	  syntax), how much data should be sent.  This statement tells
	  us that data should be sent to the remote system call
	  receiver by the keyword "in".  If you think of the system
	  call as simply a function, then "buf" is an "in" parameter to
	  the write() function.  "xdr_bytes( &buf, &len, len )" is the
	  xdr routine and arguments which should be used to transfer
	  the data.  A similar statement appears with the prototype for
	  read(), but in this case the keyword "out" indicates that
	  (from the point of view of the read() system call), "buf" is
	  an out parameter, i.e. data must be sent from the system call
	  receiver to the sender.  In cases where data needs to travel
	  in both directions, both an "in" and an "out" statement would
	  appear.

	map()

	Some system calls simply must be handled specially.  Examples
	are those system calls which directly affect the open files
	table used for checkpoint/restart.  Unfortunately, this
	"specialness" dosen't necessarily span all three pieces of code
	we want to generate.  For example, the switch for open() must
	be special because it affects the open files table, but the
	sender and receiver for open() don't need any special
	treatment.  We would therefore like to include a prototype for
	open(), but we must somehow tell the switch generator that it
	should not generate anything for open().  We solve the problem
	by running this file through the C preprocessor (cpp) before
	processing it.  The switch generator will ensure that the macro
	SWITCH is defined, the sender generator will instead define the
	macro SENDER, and similarly the reveiver generator will define
	the macro RECEIVER.  We then use cpp conditional statements to
	ensure that each generator sees only the prototypes for which it
	should generate code.
*/

	// Switches for these implemented in "condor_ckpt/file_state.C"
#if !defined (SWITCH)
int open( const char *path, int flags, int mode ) {
	in xdr_string( &path, _POSIX_PATH_MAX );
	alloc( path, _POSIX_PATH_MAX );
}
int close( int fd );
int dup( int old_fd );
int dup2( int old_fd, int new_fd );
#endif

pid_t fork() : extract {
	not_supported();
}

pid_t wait4( pid_t pid, int *status, int options, struct rusage *ru ) {
	out xdr_int( &status );
	alloc( status, INT_SIZE );
	out xdr_rusage( &ru );
	alloc( ru, RUSAGE_SIZE );
	not_supported();
}

int link( const char *p1, const char *p2 ) {
	in xdr_string( &p1, _POSIX_PATH_MAX );
	in xdr_string( &p2, _POSIX_PATH_MAX );
	alloc( p1, _POSIX_PATH_MAX );
	alloc( p2, _POSIX_PATH_MAX );
}
int unlink( const char *path ) {
	in xdr_string( &path, _POSIX_PATH_MAX );
	alloc( path, _POSIX_PATH_MAX );
}
ssize_t read( map(int fd), void *buf, size_t len ) {
	out xdr_bytes( &buf, &len, len );
	alloc( buf, len );
}
ssize_t write( map(int fd), const void *buf, size_t len ) {
	in xdr_bytes( &buf, &len, len );
	alloc( buf, len );
}
off_t lseek( map(int fd), off_t offset, int whence );
pid_t getpid();

int mount( char *spec, char *dir, int mflag, int fstyp, char *pt, int len );
int setuid( uid_t uid );
uid_t getuid();
int ptrace( long req, long int process, ulong_t *address, ulong_t data );
int recvmsg( int socket, struct msghdr *message, int flags );
int sendmsg( int socket, struct msghdr *message, int flags );
int recvfrom( int socket, char *buffer, int length, int flags,
			  struct sockaddr *address, int addr_len );
int accept( int socket, struct sockaddr *address, int addr_len );
int getpeername( int socket, struct sockaddr *address, int addr_len );
int getsockname( int socket, struct sockaddr *address, int addr_len );
int access( const char *path, int access_mode );
void sync();
int kill( pid_t pid, int sig ) : extract;
int setpgid( pid_t process_id, pid_t gid );
int pipe( int fd[] );
void profil( short *buf, unsigned int buf_size, unsigned int offset,
			 unsigned int scale );
int sigaction( int sig, const struct sigaction *act, struct sigaction *o_act ) : extract;
gid_t getgid();
int sigprocmask( int how, const sigset_t *set, sigset_t *o_set );
char *getlogin();
int setlogin( char *name );
int acct( char *path );
int sigpending( sigset_t *set );
int fstat( map(int fd), struct stat *buf );
int fchdir( int fd );
int mknod( const char *path, int mode, dev_t device );
int chmod( const char *path, mode_t mode );
int chown( const char *path, uid_t owner, gid_t group );
int getfsstat( struct statfs *buf[], long bufsize, int flags );
int flock( map(int fd), int op );
int fstatfs( map(int fd), struct statfs *buf );
int fsync( map(int fd) );
int ioctl( map(int fd), unsigned long request, char *argp );
void reboot( int howto );
int revoke( char *path );
int symlink( const char *path1, const char *path2 );
int readlink( const char *path, char *buf, int buf_size );
int execve( const char *path, char * const argv[], char * const envp [] );
			mode_t umask( mode_t mask );
int execv( const char *path, char * const argv[] );
int exec_with_loader( int flags, const char *loader, const char *file,
					  char * const argv[], char * const envp[] );
int chroot( const char *path );
pid_t getpgrp();
int getpagesize();
pid_t vfork();
int stat( const char *path, struct stat *buf );
int lstat( const char *path, struct stat *buf );
int fcntl( map(int fd), int req, int arg );
char * mmap( char * a, size_t l, int p, int f, map(int fd), off_t o );
int munmap( char * addr, size_t len );
int mprotect( char * addr, size_t len, int prot );
int madvise( char * addr, size_t len, int behav );
int getgroups( int gidsetsize, gid_t grouplist[] );
int setgroups( int gidsetsize, gid_t grouplist[] );
int setpgrp( int pid, int pgrp );
int setitimer( int which, struct itimerval *value, struct itimerval *oval );
int getitimer( int which, struct itimerval *value );
int getdirentries( map(int fd), char *buf, int nbytes, long *basep );
int table( int id, int index, char *addr, int nel, unsigned int lel );
int gethostname( char *address, int address_len );
int sethostname( char *address, int address_len );
int getdtablesize();
int select( int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
			struct timeval *timeout );
int poll( struct pollfd filedes[], unsigned int nfds, int timeout );
int setpriority( int which, int who, int priority );
int getpriority( int which, int who );
int socket( int addr_family, int type, int protocol );
int connect( int sock, struct sockaddr *address, int addr_len );
int send( int socket, char *msg, int length, int flags );
int recv( int socket, char *msg, int length, int flags );
int sigreturn( struct sigcontext *scp );
int bind( int socket, struct sockaddr *address, int addr_len );
int listen( int socket, int backlog );
int plock( int op );
int sigsuspend( const sigset_t *mask );
int sigstack( struct sigstack *instack, struct sigstack *outstack );
int gettimeofday( struct timeval *tp, struct timezone *tzp );
int settimeofday( struct timeval *tp, struct timezone *tzp );
int getsockopt( int sock, int level, int opt_name, char *opt_val, int opt_len );
int setsockopt( int sock, int level, int opt_name, char *opt_val, int opt_len );
int fchown( map(int fd), uid_t owner, gid_t group );
int fchmod( map(int fd), mode_t mode );
int setreuid( int ruid, int euid );
int setregid( int rgid, int egid );
int rename( const char *from, const char *to );
int truncate( const char *path, off_t length );
int ftruncate( map(int fd), off_t length );
int setgid( gid_t gid );
int sendto( int sock, char *msg, int msg_len, int flags, struct sockaddr *dest,
			int dest_len );
int shutdown( int socket, int how );
int socketpair( int domain, int type, int protocol, int sock_vector[] );
int mkdir( const char *path, mode_t mode );
int rmdir( const char *path );
int utimes( const char *path, struct timeval times[] );
int adjtime( struct timeval *delta, struct timeval *old_delta );
int gethostid();
int sethostid( int host_id );
int setrlimit( int resource, struct rlimit *rlp );
int getrlimit( int resource, struct rlimit *rlp );
pid_t setsid();
int quotackl( char *path, int cmd, int id, char *addr );
int nfssvc( int sock, int mask, int match );
int statfs( char *path, struct statfs *buf, int len );
int async_daemon();
int getfh( map(int fd), fhandle_t *fhp, int exp_fd );
int getdomainname( char *name, int namelen );
int setdomainname( char *name, int namelen );
int exportfs( int access, int *record, struct exportfsdata *exdata );
int lockf( map(int fd), int request, off_t size );
int swapon( char *path, int flags, int lo_water, int hi_water );
int msgctl( int msgid, int cmd, struct msqid_ds *buf );
int msgget( key_t key, int msgflg );
int msgrcv(int qid, void *msgp, size_t msgsz, long msgtyp, int msgflg );
int msgsnd( int msqid, void *msgp, size_t msgsz, int msgflg );
int semctl( int semid, int semnum, int cmd, void *arg );
int semget( key_t key, int nsems, int semflag );
int semop( int semid, struct sembuf *sops, unsigned int nsops );
int lchown( const char *path, uid_t owner, gid_t group );
int uname( struct utsname *name );
char * shmat( int shmid, char * shmaddr, int shmflg );
int shmctl( int shmid, int cmd, struct shmid_ds *buf );
int shmdt( char * addr );
int shmget( key_t key, unsigned int size, unsigned int flags );
int mvalid( char * addr, size_t len, int prot );
int getaddressconf( struct addressconf *buf, size_t length );
int msync( char * addr, size_t len, int flags );
pid_t getpgid( pid_t pid );
int uswitch( int cmd, int value );
int getsysinfo( unsigned long op, char * buf, unsigned long nbytes,
				int *start, char *arg );
int setsysinfo( unsigned long op, char *buffer, unsigned long nbytes,
				char * arg, unsigned long flag );
