
	case CONDOR_send_file:
	  {
		char	*local;
		char	*remote;
		MODE_T		mode;
		int		loc_fd;
		int		read_status = 0, write_status;
		char	buf[ XDR_BLOCKSIZ ];
		int		len;
		int		bytes_to_go;
		int		file_size;

		CurrentSysCall = CONDOR_send_file;

		local = va_arg( ap, char *);
		remote = va_arg( ap, char *);
		mode = va_arg( ap, MODE_T );

			/* Do the local open */
		if( (loc_fd = open(local,O_RDONLY)) < 0 ) {
			rval = -1;
			break;
		}

			/* Send over the file name, and mode */
		xdr_syscall->x_op = XDR_ENCODE;
		assert(xdr_int(xdr_syscall,&CurrentSysCall) );
		assert( xdr_u_int(xdr_syscall,&mode) );
		assert( xdr_string(xdr_syscall,&remote, _POSIX_PATH_MAX) );
		assert( xdrrec_endofrecord(xdr_syscall,TRUE) );

			/* Grab the result of the remote open */
		xdr_syscall->x_op = XDR_DECODE;
		assert( xdrrec_skiprecord(xdr_syscall) );
		assert( xdr_int(xdr_syscall,&rval) );
		if( rval < 0 ) {
			assert( xdr_int(xdr_syscall,&terrno) );
			errno = terrno;
			rval = -1;
			break;
		}

			/* Send file length */
		file_size = lseek( loc_fd, 0, 2 );
		lseek( loc_fd, 0, 0 );
		xdr_syscall->x_op = XDR_ENCODE;
		assert( xdr_int(xdr_syscall,&file_size) );

			/* Transfer the data */
		for( bytes_to_go = file_size; bytes_to_go; bytes_to_go -= len ) {
			len = bytes_to_go < sizeof(buf) ? bytes_to_go : sizeof(buf);
			read_status = read( loc_fd, buf, len );
			assert( xdr_opaque(xdr_syscall,buf,len) );
		}
		(void)close( loc_fd );

			/* As a check, re-send the length */
		assert( xdr_int(xdr_syscall,&file_size) );
		assert( xdrrec_endofrecord(xdr_syscall,TRUE) );


			/* Get cumulative status from remote writes */
		xdr_syscall->x_op = XDR_DECODE;
		assert( xdrrec_skiprecord(xdr_syscall) );
		assert( xdr_int(xdr_syscall,&write_status) );
		if( write_status < 0 ) {
			assert( xdr_int(xdr_syscall,&terrno) );
			errno = terrno;
			rval = write_status;
			break;
		}

			/* If we had a local error on the reads, we had to ignore
			   it until now to avoid getting out of sync with the
			   shadow - now we can deal with it.
			*/
		if( read_status < 0 ) {
			rval = read_status;
			break;
		}

			/* Everything worked - status is cumulative status from
			   remote writes.
			*/
		rval = write_status;
		break;
	}

	case CONDOR_get_file:
	  {
		char	*remote;
		char	*local;
		int		mode;
		int		loc_fd;
		int		open_status, write_status = 0, read_status;
		char	buf[ XDR_BLOCKSIZ ];
		int		checksum;
		int		len;
		int		file_size;
		int		bytes_to_go;
		int		scm;
		int		close_status;

		CurrentSysCall = CONDOR_get_file;

			/* Marshall the arguments */
		remote = va_arg( ap, char *);
		local = va_arg( ap, char *);
		mode = va_arg( ap, int );

			/* Open local file for writing */
		loc_fd = open( local, O_WRONLY|O_CREAT|O_TRUNC, mode );
		if( loc_fd < 0 ) {
			rval = -1;
			break;
		}

			/* Send over the file name */
		xdr_syscall->x_op = XDR_ENCODE;
		assert(xdr_int(xdr_syscall,&CurrentSysCall) );
		assert( xdr_string(xdr_syscall,&remote, _POSIX_PATH_MAX) );
		assert( xdrrec_endofrecord(xdr_syscall,TRUE) );

			/* Grab the result of the remote open */
		xdr_syscall->x_op = XDR_DECODE;
		assert( xdrrec_skiprecord(xdr_syscall) );
		assert( xdr_int(xdr_syscall,&rval) );
		if( rval < 0 ) {
			assert( xdr_int(xdr_syscall,&terrno) );
			errno = terrno;
			rval = -1;
			break;
		}

			/* Get the size of the file */
		assert( xdr_int(xdr_syscall,&file_size) );

			/* Transfer the data */
		for( bytes_to_go = file_size; bytes_to_go; bytes_to_go -= len ) {
			len = bytes_to_go < sizeof(buf) ? bytes_to_go : sizeof(buf);
			assert(xdr_opaque(xdr_syscall,buf,len));
			write_status = write( loc_fd, buf, len );
		}
		close_status = close( loc_fd );
		if( close_status < 0 ) {
			dprintf( D_ALWAYS,
				"Close of \"%s\" failed - errno = %d\n", local, errno
			);
		}

			/* Should get file size again as a check */
		assert( xdr_int(xdr_syscall,&checksum) );
		assert( checksum == file_size );

			/* Get status from remote reads */
		assert( xdr_int(xdr_syscall,&read_status) );
		if( read_status < 0 ) {
			assert( xdr_int(xdr_syscall,&terrno) );
			errno = terrno;
			rval = -1;
			break;
		}

			/* Wrapup */
		if( write_status >= 0 && read_status >= 0 && close_status >= 0 ) {
			dprintf( D_ALWAYS,
				"CONDOR_get_file: transferred %d bytes\n", file_size );
			rval = 0;
		} else {
			rval = -1;
		}

		break;
	}

	  default:
		SetSyscalls( scm );
		fprintf(
			stderr,
			"Don't know how to do system call %d <%s> remotely - yet\n",
			syscall_num, _condor_syscall_name( syscall_num )
		);
		rval =  -1;
	}

	/* Some problem with blocking and unblocking sigs on OSF1 */
#if !defined(OSF1)
		/* Restore previous signal mask - generally unblocks TSTP and USR1 */
	if( sigprocmask(SIG_SETMASK,&omask,0) < 0 ) {
		EXCEPT( "sigprocmask" );
	}
#endif

	SetSyscalls( scm );
	return rval;
}
