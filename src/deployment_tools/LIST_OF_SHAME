LIST OF SHAME
==============
1. condor_local_stop needs to query the collector to shut off the
   master 
   - normally condor_off uses the config to find the masters address
   file, which is usually stored in log/
   - condor_local_off doesn't know the location of the local dir or
     the log_dir so it cannot find the masters address file
   - Possible Solution: Tree of collectors
     + a collector for each machine, with its port listed in config
     + the machine collector aggregates info for the machine and sends
       it to its parent collector

2. condor_cold_start does not allow the setup process to install local
   configs
   - this requires configMD to bind the local config files into the
     global config (the global config can't know the location of the
     local configs until after they are installed, environment variables
     won't work for this)
   - Adding ConfigMD will move functionality out of local_start,
     namely LB_RELEASE_DIR

5. Warnings: Warnings are kind of glommed together.  Its like endlines
   don't work.
   - Maybe just write directly to stderr and use endlines

6. cold_stop: If a specified configuration files installed version is
   not in the expected location, cold stop uses the original version
   (specified as a file path or a url).  If the path is specified as a
   url, this will fail strangely.

7. condor_local_start's prediagnosis is very specific for schedd.  We
   may want to use config variables or something else to make this
   work for non-scheduler installs

8. condor_local_stop is also very schedd specific.  It will not
   shutdown if the schedd still has jobs.
   - the force option ignores the schedd
   - the interface may need to be changed so that the default mode is
     not schedd specific

9. condor_install_local will not handle arbitrarily named log, exec,
   spool directories with its install from archive option

10. condor_cleanup_local doesn't work with dynamically named local
    dirs 

12. bpid_undertaker may mistakenly determine that a process is still
    alive.
    - the kernel can and does return different bday values for a given
      process
    - we are forced to accept a range of birthdays
    - if the pid is reused in this range, then the undertaker may be
      fooled 
    - alternatively, it may return that a process is dead when it
      is actually alive because the bday returned is so wrong it
      doesn't even fit in the range we accept
    - POSSIBLE SOLUTION:
      Midwife
      -------
      bday = systime()
      sleep(1)
      fork child with MIDWIFE_BIRTHDAY = bday
      write bday and pid to file
      Undertaker
      ----------
      read pid + bday from file
      use procapi to get env from pid
      if( env contains MIDWIFE_BIRTHDAY and it equals bday from file)
      then process is still alive

13. bpid_midwife always blocks until the "midwifed" process is dead.
    - unlike flock and linklock it doesn't need to do this
    - however to keep the interfaces and behavior the same across
      midwifes I had the bpid_midwife block as well

14. condor_local_start cannot execute the master in the background
    - the midwife blocks until the midwifed process is dead
    - executing the master with the background option will not solve
      this problem because then the midwife will birth the process that
      will start the master, not the master itself
    - adding bg option to midwife or having local_start fork to start
      the midwife

15. condor_local_start and condor_local_stop are not symmetric
    - local_stop only shutsdown a master
    - local_start creates the local_dir structure
    - cold_stop cleans up the local_dir structure
    - either local_stop should clean up the local_dir structure
    - OR cold_start should create it
