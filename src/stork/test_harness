#!/bin/bash
# Stork test harness.  Currently, this harness tests stork_server,
# stork_submit, stork_rm, stork_q.  Tests can optionally be run from a memory
# debugger, such as valgrind.

# Configuration constants

# Test enables
STORK_TESTS=true	# run Stork tests
GLOBUS_TESTS=true	# run Globus tests
CREDD_TESTS=true	# run CredD tests
MEMORY_TESTS=true	# run memory tests
LEAK_TESTS=false	# run memory leak tests.  implies MEM_TESTS

#INSTALL_ROOT=/scratch/weber/install/stork-v67	# FIXME
STORKD_HOST=localhost	# stork_server host
DAEMON_START_DELAY=4	# daemon startup/shutdown delay
SIGSPEC="0 1 2 3 15"	# signals to catch.  Run finish() function.

# Optional memory debugger harness. Uncomment VALGRIND definition to enable
# memory debugging.
VALGRIND=~nleroy/local/bin/valgrind		# FIXME
VALGRIND_OPTS="$VALGRIND_OPTS --tool=addrcheck"
VALGRIND_OPTS="$VALGRIND_OPTS --time-stamp=yes"
VALGRIND_OPTS="$VALGRIND_OPTS --trace-children=yes"
#VALGRIND_OPTS="$VALGRIND_OPTS -v"
VALGRIND_LEAK_OPTS="--leak-check=yes --show-reachable=yes"
#VALGRINDCMD="$VALGRIND $VALGRIND_OPTS"

PERL=perl	# Perl program
PERL_GLOBUS_BIN_FIND='/^\s*globus_bin_dir\s*=\s*"(\S+)"\s*/ && print $1,"\n"'
PERL_GLOBUS_LIB_FIND='/^\s*ld_library_path\s*=\s*"(\S+)"\s*/ && print $1,"\n"'
PERL_DAP_ID_FIND='/^\s*Request assigned id:\s+(\d+)/ && print $1,"\n"'


# stork_server daemon invocation
STORKD=stork_server
STORKD_PORT="-p 34048"
STORKD_OPTS="$STORKD_OPTS $STORKD_PORT"
STORKD_OPTS="$STORKD_OPTS -f"
#STORKD_OPTS="$STORKD_OPTS -Config $INSTALL_ROOT/etc/stork.config"
#STORKD_OPTS="$STORKD_OPTS -Serverlog $INSTALL_ROOT/local.north/log/Stork"	# FIXME
DAP_XFER_FILE_FILE=DaP.transfer.file-file

CCV=condor_config_val

# stork_q invocation
STORK_Q=stork_q
STORK_Q_OPTS=$STORKD_HOST

#stork_submit invocation
STORK_SUBMIT=stork_submit
STORK_SUBMIT_OPTS=$STORKD_HOST

#stork_status invocation
STORK_STATUS=stork_status
STORK_STATUS_OPTS=$STORKD_HOST

#stork_rm invocation
STORK_RM=stork_rm
STORK_RM_OPTS=$STORKD_HOST

# Variables
PROG=`basename $0`	# this program name
TEST_COUNT=0	# total count of all tests
FAIL_COUNT=-1	# total count of test failures

# Functions

# Program cleanup and results summary
finish() {
	trap - $SIGSPEC	# restore default signal handlers to avoid loop
	if [ -n "$STORKD_PID" ]; then
		if kill $STORKD_PID; then
			wait $STORKD_PID
		else
			echo ERROR: stork_server not running 1>&2
		fi
	fi
	# FIXME: too heavy handed!  Any other instances of this same program will
	# be killed also.  Instead, consider this process group.
	killall --quiet --wait $DAP_XFER_FILE_FILE
	if $MEMORY_TESTS; then
		echo $VALGRIND errors:	# display memory error summary
		grep "ERROR SUMMARY:" *.pid* | grep -v "ERROR SUMMARY: 0 errors"
	fi
	echo
	echo --------------------------------------------------------------
	echo test harness summary: tests: $TEST_COUNT failures: $FAIL_COUNT
	echo results in $TESTDIR #FIXME: may not exist yet
	exit $FAIL_COUNT	# program exit point
}


# Fatal error message and exit
fatal () {
	echo $PROG ERROR: "$@" 1>&2
	exit 
}

# Announce a test error
error() {
	echo "  ERROR: " "$@" 1>&2
}

# announce a test
test_announce () {
	name=$1; shift;
	printf "test: %-60s -> " $name
}

# update a test status
test_status () {
	status=$1; shift
	(( TEST_COUNT++ ))
	#TEST_COUNT=`expr $TEST_COUNT + 1`
	if [ $status -eq 0 ]; then
		echo pass
	else
		echo FAIL
		FAIL_COUNT=`expr $FAIL_COUNT + 1`
	fi
}

# wait for a file transfer, with timeout
wait_file_cmp() {
	new_file=$1; shift;
	match_file=$1; shift;
	timeout=$1; shift;
	[ -z "$timeout" ] && timeout=0	# default timeout=0
	resolution=1

	elapsed=0
	while true; do
		cmp --silent $new_file $match_file && return 0
		(( elapsed++ >= $timeout )) && return 1
		sleep $resolution
	done
}

# wait for a process, timeout
wait_process_name() {
	process_regex="$1"; shift;
	timeout=$1; shift;
	[ -z "$timeout" ] && timeout=0	# default timeout=0
	resolution=1

	elapsed=0
	while true; do
		if ps auwwx | grep -v grep | grep --silent "$process_regex"; then
			#echo pattern \"$process_regex\" found
			return 0
		fi
		(( elapsed++ >= $timeout )) && return 1
		sleep $resolution
	done
}

usage() {
cat <<EOF
usage: $PROG [options]

options:
	-debug		enable debugging output
	-[no]stork	enable stork tests [enabled]
	-[no]memory	enable memory tests [enabled]
	-[no]leak	enable memory leak tests, implies -memory [disabled]
EOF
}

# parse command line
parse_cmd() {
	while [ -n "$1" ]; do
		echo ARG = $1
		case $1 in 
			-debug) set -x ;;
			-stork) STORK_TESTS=true ;;
			-nostork) STORK_TESTS=false ;;
			-memory) MEMORY_TESTS=true ;;
			-nomemory) MEMORY_TESTS=false ;;
			-leak) LEAK_TESTS=true; MEMORY_TESTS=true ;;
			-noleak) LEAK_TESTS=false ;;
#			-globus) GLOBUS_TESTS=true ;;
#			-noglobus) GLOBUS_TESTS=false ;;
#			-credd) CREDD_TESTS=true ;;
#			-nocredd) CREDD_TESTS=false ;;
			*) usage; exit 1 ;;
		esac
		shift
	done
}

# test setup
setup() {
	if $STORK_TESTS; then
		echo Stork core tests are enabled
	else
		echo Stork core tests are disabled
	fi
	if $MEMORY_TESTS; then
		echo memory tests are enabled
		MEMTEST="$VALGRIND $VALGRIND_OPTS"
	else
		echo memory tests are disabled
	fi
	if $LEAK_TESTS; then
		MEMTEST="$MEMTEST $VALGRIND_LEAK_OPTS"
		echo memory leak tests are enabled
	else
		echo memory leak tests are disabled
	fi
#	if $GLOBUS_TESTS; then
#		echo Globus tests are enabled
#	else
#		echo Globus tests are disabled
#	fi
#
#	if $CREDD_TESTS; then
#		echo CredD tests are enabled
#	else
#		echo CredD tests are disabled
#	fi

	# Verify some prerequisite test files
	DEVZERO=/dev/zero
	[ -c $DEVZERO ] || fatal character special file $DEVZERO does not exist
	DEVNULL=/dev/null
	[ -c $DEVNULL ] || fatal character special file $DEVNULL does not exist

	# Basic sanity tests, before beginning
	[ -n "$CONDOR_CONFIG" ] || fatal CONDOR_CONFIG environment not defined
	[ -r $CONDOR_CONFIG ] || fatal $CONDOR_CONFIG file is not readable
	echo CONDOR_CONFIG = $CONDOR_CONFIG
	type $CCV >/dev/null || fatal $CCV binary not found. Check your PATH .
	BIN=`$CCV BIN`
	SBIN=`$CCV SBIN`
	export PATH="$BIN:$SBIN:$PATH"
	type $STORKD >/dev/null || fatal $STORKD binary not found.

	# Update this shell environment to find and run Condor and Globus programs
	# Parse Globus locations from etc/stork.config file.  This is a shakey
	# method, but it's all we have, for now.
	etc=`dirname $CONDOR_CONFIG`
	STORK_CONFIG="$etc/stork.config"
	echo parsing $STORK_CONFIG
	[ -r $STORK_CONFIG ] || fatal $STORK_CONFIG file is not readable

	if $GLOBUS_TESTS; then
		GLOBUS_BIN=`$PERL -ne "$PERL_GLOBUS_BIN_FIND" $STORK_CONFIG`
		if [ -d $GLOBUS_BIN ]; then
			export PATH="$GLOBUS_BIN:$PATH"
		else
			fatal globus_bin_dir directory not found in $STORK_CONFIG
		fi
		GLOBUS_LIB=`$PERL -ne "$PERL_GLOBUS_LIB_FIND" $STORK_CONFIG`
		if [ -d $GLOBUS_LIB ]; then
			export LD_LIBRARY_PATH="$GLOBUS_LIB:$LD_LIBRARY_PATH"
		else
			fatal globus_bin_dir directory not found in $STORK_CONFIG
		fi
	fi

	# create a uniq test directory
	TESTDIR="`pwd`/$PROG-$$"
	mkdir $TESTDIR || fatal mkdir $TESTDIR
	cd $TESTDIR || fatal cd $TESTDIR
}

# Run program from memory tester in the background
run_bg() {
	out="$1"; shift;
	if $MEMORY_TESTS; then
		LOGFILE="--log-file=$out"
	fi
	$MEMTEST $LOGFILE "$@" >"$out.out" 2>&1 &
	status=$?	# is this pointless?
	return $status
}

# Run program from memory tester in the foreground
run_fg() {
	out="$1"; shift;
	if $MEMORY_TESTS; then
		LOGFILE="--log-file=$out"
	fi
	$MEMTEST $LOGFILE "$@" >"$out.out" 2>&1
	status=$?
	return $status
}

# start stork daemon
storkd () {
	name="$1"; shift;
	test_announce "$name"
	STORKD_OPTS="$STORKD_OPTS -Serverlog $TESTDIR/Stork"
	STORKD_OPTS="$STORKD_OPTS -Config $STORK_CONFIG"
	cmd="$STORKD $STORKD_OPTS"
	run_bg $name $cmd
	STORKD_PID="$!"
	sleep $DAEMON_START_DELAY
	ps >/dev/null $STORKD_PID
	status=$?
	test_status $status
	if [ $status -ne 0 ];then
		error $cmd failed
	fi
	return $status
}

# stork_q should see no dap jobs
stork_q_0dap() {
	name="$1"; shift;
	test_announce "$name"
	cmd="$STORK_Q $STORK_Q_OPTS"
	run_fg $name $cmd
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error $cmd failed
		return $status
	fi
	regex="dap_id = *$DAP_ID;"
	grep --silent "$regex" "$name.out"
	status=$?
	if (( $status==1 )); then
		new_status=0
	else
		new_status=1
	fi
	test_status $new_status
	if [ $new_status -ne 0 ]; then
		error stork_q output not empty
		cat "$name.out"
	fi
	return $new_status
}

# stork_q should see one dap job
stork_q_1dap() {
	name="$1"; shift;
	test_announce "$name"
	cmd="$STORK_Q $STORK_Q_OPTS"
	run_fg $name $cmd
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error $cmd failed
		return $status
	fi
	regex="dap_id = *$DAP_ID;"
	grep --silent "$regex" "$name.out"
	status=$?
	test_status $status
	if [ $status -ne 0 ]; then
		error dap_id $DAP_ID not found in $STORK_Q output "$name.out"
	fi
	return $status
}

# stork_status should see one dap job
stork_1status() {
	name="$1"; shift;
	test_announce "$name"
	cmd="$STORK_STATUS $STORK_STATUS_OPTS $DAP_ID"
	run_fg $name $cmd
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error $cmd failed
		return $status
	fi
	regex="dap_id = *$DAP_ID;"
	grep --silent "$regex" "$name.out"
	status=$?
	test_status $status
	if [ $status -ne 0 ]; then
		error dap_id $DAP_ID not found in $STORK_STATUS output "$name.out"
	fi
	return $status
}

stork_1rm() {
	name="$1"; shift;
	test_announce "$name"
	cmd="$STORK_RM $STORK_RM_OPTS $DAP_ID"
	run_fg $name $cmd
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error $cmd failed
		return $status
	fi
	regex="DaP job $DAP_ID is removed from queue."
	grep --silent "$regex" "$name.out"
	status=$?
	test_status $status
	if [ $status -ne 0 ]; then
		error dap_id $DAP_ID not removed from queue
	fi
	return $status
}

# test file:// to file:// transfer and exit
stork_submit_file_file() {
	name="$1"; shift;
	test_announce "$name"
	DEST_FILE=$TESTDIR/termcap
	rm -f $DEST_FILE
	SUBMIT_FILE=file-file.dap
	COMPARE_FILE=/etc/termcap
	cat <<EOF >$SUBMIT_FILE
	[
		dap_type = transfer;
		src_url = "file:$COMPARE_FILE";
		dest_url = "file:$DEST_FILE";
	]
EOF
	cmd="$STORK_SUBMIT $STORK_SUBMIT_OPTS $SUBMIT_FILE"
	run_fg $name $cmd
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error $cmd failed
		return $status
	fi
	wait_file_cmp $DEST_FILE $COMPARE_FILE 10
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error cmp $DEST_FILE $COMPARE_FILE failed
		return $status
	fi
	DAP_ID=`$PERL -ne "$PERL_DAP_ID_FIND" "$name.out"`
	if [ -z "$DAP_ID" ]; then
		status=1
		test_status $status
		error $STORK_SUBMIT dap_id not found in "$name.out"
		return $status
	fi
	test_status $status
	return $status
}

# test stork file submit, stork_q, stork_status, stork_rm, stork_q,
# stork_status
stork_submit_long_xfer() {
	name="$1"; shift;
	test_announce "$name"
	SRC_FILE=$DEVZERO
	DEST_FILE=$DEVNULL
	SUBMIT_FILE=file-zero.dap
	cat <<EOF >$SUBMIT_FILE
	[
		dap_type = transfer;
		src_url = "file:$SRC_FILE";
		dest_url = "file:$DEST_FILE";
	]
EOF
	cmd="$STORK_SUBMIT $STORK_SUBMIT_OPTS $SUBMIT_FILE"
	run_fg $name $cmd
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error $cmd failed
		return $status
	fi
	wait_process_name $DAP_XFER_FILE_FILE 4
	status=$?
	if [ $status -ne 0 ];then
		test_status $status
		error process $DAP_XFER_FILE_FILE not spawned
		return $status
	fi
	# FIXME this dependency on the previous DAP_ID is not reflected in test
	# dependencies below
	_dap_id=`$PERL -ne "$PERL_DAP_ID_FIND" "$name.out"`
	if [ -z "$_dap_id" ]; then
		return $status
	fi
	if [ -z "$DAP_ID" ]; then
		error $STORK_SUBMIT previous dap_id not found
		status=1
		return $status
	fi
	if (( $DAP_ID != $_dap_id - 1 )); then
		error $STORK_SUBMIT dap_id $_dap_id unchanged from $DAP_ID
		status=1
		return $status
	fi

	DAP_ID=$_dap_id	# save newest dap_id
	test_status $status
	return $status
}

# start main program ###########################################################

parse_cmd "$@"
setup

# Start tests.
FAIL_COUNT=0	# total count of test failures
trap finish $SIGSPEC

if $STORK_TESTS; then
	echo
	echo running stork core tests ...
	if storkd "stork_daemon" && stork_q_0dap "stork_q_simple"; then
		stork_submit_file_file "stork_submit_file_file"
		if stork_submit_long_xfer "stork_submit_long_xfer"; then
			stork_q_1dap "stork_q_1dap"
			stork_1status "stork_1status"
			if stork_1rm "stork_1rm"; then
				stork_q_0dap "stork_q_0dap"
			fi
		fi
	fi
fi



echo 
echo all tests complete
