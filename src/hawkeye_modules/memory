#! /usr/bin/perl -w
use strict;

# Prototypes
sub GatherMeminfo( $$ );
sub GatherFree( $$ );
sub GatherError( $$ );

# Update the module include path
BEGIN
{
    my $Dir = $0;
    if ( $Dir =~ /(.*)\/.*/ )
    {
	push @INC, "$1";
    }
}
use HawkeyePublish;
use HawkeyeLib;

# Setup the hawkeye stuff
my $Hawkeye;

# Table of ways to gather data..
my @GatherMethods =
(
 { Description => "Linux /proc/meminfo", Function => \&GatherMeminfo, },
 { Description => "Linux free", Function => \&GatherFree, },
 { Description => "Error", Function => \&GatherError, },
);

# Do it
Init();
RunIt();

# Init logic
sub Init
{
    HawkeyeLib::DoConfig( );

    $Hawkeye = HawkeyePublish->new;
    $Hawkeye->Quiet( 1 );
    $Hawkeye->AutoIndexSet( 1 );
}

# The runtime logic
sub RunIt
{
    # Try various methods..
    # Let each method determine if it's 
    my $Count = 0;
    foreach my $Method ( @GatherMethods )
    {
	# Create the hash to use...
	my $Hash = HawkeyeHash->new( \$Hawkeye, "" );

	# Start things off
	my $Error = "";
	my $Status = $Method->{Function}( $Hash, \$Error );

	# >= 0 : ok
	if ( $Status >= 0 )
	{
	    # Ok, go "store" the data; done if there was data to store...
	    $Count = $Hash->Store( );
	    last if ( $Count > 0 );
	}
	# < 0 : Error
	else
	{
	    print STDERR "$Method->{Description}: $Error\n";
	}
    }

    # Store 'em all & publish them.
    if ( $Count > 0 )
    {
	$Hawkeye->Publish( );
    }
}

# Gather data via "/proc/meminfo" (Linux)
sub GatherMeminfo( $$ )
{
    my $Hash = shift;
    my $Error = shift;

    # Here's the meminfo file..
    my $Meminfo = "/proc/meminfo";
    return 0 if ( ! -f $Meminfo );

    # Run it, parse it
    Carp::confess( "Can't open '$Meminfo'" ) if ( ! open ( MEMINFO, "$Meminfo" ) );
    my @Fields;
    my %Offsets;
    while( <MEMINFO> )
    {
	if ( /^\s+(.*)/ )
	{
	    my $Str = $1;
	    $Str =~ s/://g;
	    @Fields = split( /\s+/, $Str );
	    foreach my $FieldNo ( 0 .. $#Fields )
	    {
		$Offsets{$Fields[$FieldNo]} = $FieldNo;
	    }
	    next;
	}

	# Mem line
	if ( /Mem:\s+(.*)/ )
	{
	    my @Values = split( /\s+/, $1 );
	    for my $Num ( 0 .. $#Values )
	    {
		$Hash->Add( "mem_$Fields[$Num]", "n", $Values[$Num] );
	    }
	    if ( ( exists $Offsets{total} ) && ( exists $Offsets{used} ) )
	    {
		my $Percent = ( 100 *
				$Values[ $Offsets{used} ] /
				$Values[ $Offsets{total} ] );
		$Hash->Add( "mem_used_pct", "n", sprintf( "%.2f", $Percent) );
	    }
	}
	# Swap line
	elsif( /Swap:\s+(.*)/ )
	{
	    my @Values = split( /\s+/, $1 );
	    for my $Num ( 0 .. $#Values )
	    {
		$Hash->Add( "swap_$Fields[$Num]", "n", $Values[$Num] );
	    }
	    if ( ( exists $Offsets{total} ) && ( exists $Offsets{used} ) )
	    {
		my $Percent = ( 100 *
				$Values[ $Offsets{used} ] /
				$Values[ $Offsets{total} ] );
		$Hash->Add( "swap_used_pct", "n", sprintf( "%.2f", $Percent) );
	    }
	}
	# Other lines
	elsif ( /(\S+):\s+(\d+) kB/)
	{
	    $Hash->Add( $1, "n", $2 * 1024 );
	}
    }

    # Ok...
    return 1;
}

# Gather data via the "free" program (Linux)
sub GatherFree( $$ )
{
    my $Hash = shift;
    my $Error = shift;

    # Run it, parse it
    my $Program = "/usr/bin/free";
    return 0 if ( ! -x $Program );

    my $Cmd = "$Program -b";
    Carp::confess( "Can't run free '$Cmd'" ) if ( ! open ( FREE, "$Cmd|" ) );
    my @Fields;
    my %Offsets;
    while( <FREE> )
    {
	if ( /^\s+(.*)/ )
	{
	    @Fields = split( /\s+/, $1 );
	    foreach my $FieldNo ( 0 .. $#Fields )
	    {
		$Offsets{$Fields[$FieldNo]} = $FieldNo;
	    }
	    next;
	}

	# Mem line
	if ( /Mem:\s+(.*)/ )
	{
	    my @Values = split( /\s+/, $1 );
	    for my $Num ( 0 .. $#Values )
	    {
		$Hash->Add( "mem_$Fields[$Num]", "n", $Values[$Num] );
	    }
	    if ( ( exists $Offsets{total} ) && ( exists $Offsets{used} ) )
	    {
		my $Percent = ( 100 *
				$Values[ $Offsets{used} ] /
				$Values[ $Offsets{total} ] );
		$Hash->Add( "mem_used_pct", "n", sprintf( "%.2f", $Percent) );
	    }
	}
	# Buffers/cache line
	elsif ( /buffers\/cache:\s+(.*)/ )
	{
	    my @Values = ( 0, split( /\s+/, $1 ) );
	    for my $Num ( 1 .. $#Values )
	    {
		$Hash->Add( "buffers_cache_$Fields[$Num]",
			    "n", $Values[$Num] );
	    }
	}
	# Swap line
	elsif( /Swap:\s+(.*)/ )
	{
	    my @Values = split( /\s+/, $1 );
	    for my $Num ( 0 .. $#Values )
	    {
		$Hash->Add( "swap_$Fields[$Num]", "n", $Values[$Num] );
	    }
	    if ( ( exists $Offsets{total} ) && ( exists $Offsets{used} ) )
	    {
		my $Percent = ( 100 *
				$Values[ $Offsets{used} ] /
				$Values[ $Offsets{total} ] );
		$Hash->Add( "swap_used_pct", "n", sprintf( "%.2f", $Percent) );
	    }
	}
    }

    return 1;
}

sub GatherError( $$ )
{
    my $Hash = shift;
    my $Error = shift;
    $$Error = "No valid data gathering method found";

    return -1;
}
