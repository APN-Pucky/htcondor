
INTRODUCTION

Chirp is a simple and lightweight remote I/O protocol.

Each Chirp operation is a remote procedure call from a client to a server. A Chirp operation is initiated by a client, which sends a formatted request.  The server acts upon the request and sends a response.  For example, in this interaction, a client creates a file for reading and writing, and the server responds with a file descriptor:

client:  open /tmp/file rwct 777
server:  5

AUTHENTICATION

It is assumed that Chirp is carried over a stream protocol such as TCP.  The stream itself may uniquely identify the client to the server, in which case authentication is performed before Chirp comes into play.  For example, the server might identify the client based upon its IP address or credentials determined by SSL.

If desired, client authentication may be done within the context of Chirp itself.  Two commands are available for authentication within the protocol, "cookie" and "login".  The exact syntax of these commands is given below.  The "cookie" command is used to pass a magic string discovered by the client through a covert channel.  If the cookie present is what the server expects, then authentication succeeds.  The "login" command is a traditional cleartext username and password.

Exactly what authentication the server requires is different in every setting.  If the user fails to satisfy the server's authentication requirements, then the server is free to return NO_AUTHENTICATION in response to the authentication attempt or any other I/O request.

SYNTAX

A request consists of an LF-terminated line possibly followed by binary data.  At a minimum, a Chirp server must accepts request of 1024 characters.  It may accept longer lines.  Certain requests are immediately followed by binary data.  The number of bytes is dependent on the semantics of the request, described below.

A request is parsed into words separated by any amount of white space consisting of spaces and tabs.  The first word of the request is called the "command" and the rest are called "arguments."

Words fall into three categories: strings, decimal integers, and octal integers.  In lex syntax, valid words are:
	string:  [^ \t]+
	decimal: [-+]+[0-9]*
	octal:   [-+]+[0-7]*

At the protocol level, integers have no maximum size.  They may stretch on to fill any number of bytes.  Of course, each implementation has limits on the number of bytes in an integer.  If a receiver can not store an integer contained in a request, it must return a TOO_BIG error response, defined below.

A response consists of an LF-terminated line, bearing an ASCII integer. If greater than or equal to zero, the response indicates the operation succeeded. If negative, the operation failed, and the exact value tells why:

-1   NOT_AUTHENTICATED You have not authenticated your identify.
-2   NOT_AUTHORIZED    You are not authorized to perform that action.
-3   DOESNT_EXIST      There is no object by that name.
-4   ALREADY_EXISTS    There is already an object by that name.
-5   TOO_BIG           That request is too big for me to execute.
                       i.e.  The request line exceeds an internal buffer.
                             The filename is longer than permitted.
                             An integer exceeds thelocal representation.
-6   NO_SPACE          There is not enough space to store that.
                       i.e.  The user has exceeded a quota.
                             The disk is full.
-7   NO_MEMORY         I am out of memory.
-8   INVALID_REQUEST   I don't understand the form of your request.
-9   TOO_MANY_OPEN     I have too many resources open.
-10  BUSY              That object is in use by someone else.
-11  TRY_AGAIN         A temporary condition stopped me, but you can try again.
-12  UNKNOWN           An unknown error occurred.

Negative values greater than -12 are reserved for future expansion.  The receipt of such a values should be interpreted in the same way as UNKNOWN.

COMMANDS

So, here are the available commands.
Each argument to a command is specified with a type and a name.  The valid types are:

cookie <string:cookie>

	Authenticate to the server with the given cookie string.

login  <string:name> <string:password>

	Authenticate to the server with this name and password.

open   <string:name> <string:flags> <octal:mode>

	Open the file named "name."  "mode" is interpreted in the same manner as a POSIX file mode.  "flags" may contain any of these characters which affect the nature of the open:
		r - open for reading
		w - open for writing
		a - force all writes to append
		t - truncate before use
		c - create if it doesn't exist
		x - fail if 'c' is given and the file already exists
	Returns an integer file descriptor which may be used with later calls.

close  <decimal:fd>

	Complete access to this file.

read   <decimal:fd> <decimal:length>

	Read "length" bytes from the file descriptor "fd."  If successful, the server may respond with any value between zero and "length."  Immediately following the response will be binary data of exactly as many bytes indicated in the response.  If zero, the end of the file has been reached.  If any other value is given, no assumptions about the file size may be made.

write  <decimal:fd> <decimal:length>

	Write "length" bytes to the file descriptor "fd."  This request should be immediately followed by "length" binary bytes.  If successful, may return any value between 0 and "length," indicating the number of bytes actually accepted for writing.  An efficient server should avoid accepting fewer bytes than requested, by the client must be prepared for this possibility.

lseek  <decimal:fd> <decimal:offset> <decimal:whence>

	Move the current seek pointer of "fd" by "offset" bytes from the base given by "whence." "whence" may be:
		0 - from the beginning of the file
		1 - from the current seek position
		2 - from the end of the file.
	Returns the current seek position.


unlink <string:path>

	Delete the file named "path".

rename <string:oldpath> <string:newpath>

	Cause the file "oldpath" to be renamed to "newpath".


