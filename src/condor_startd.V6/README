
My initial goal was to come to an interface to resource representation /
management which was as generic as possible, within the startd.

I used the following notions/definitions:

	* A resource is just that, it's an entity that the startd can
	  represent and manage. The startd can represent multiple
	  resources, but resources of one class, i.e. one 'back-end'
	  can be fitted into it.
	* A resource can be allocated by a 'job'. A job can be a parallel
	  job, in which case it consists of multiple 'tasks'.

To make the startd a more generic resource manager, I split it in two
layers. The upper layer being the part that interacts with Condor,
the bottom layer the part that does the (low-level) resource handling
itself. That way, you can rip out the lower layer (back-end) and
replace it. The backend is mainly in resourc.xxxx.c, exporting
the resource_ interface. The resource_ interface is the one to
rewrite for a new backend. The glue/interface between the resource_
backend and the Condor frontend is in resmgr.c, the resmgr_ interface.
The Condor frontend should ideally only use the resmgr_ calls, although
resource_allocate is called from too.

What resmgr.c does is maintain a list of resources, talking to each
of them through the resource_ interface.

Other modules in the source code include the event_ interface,
which was intented to handle asynchronous events like the machine
becoming unavailable (i.e. a call from a kbdd notifying the startd
of activity). The idea was to not periodically scan the machine
for activity, but rather having the startd be informed asynchronously.
The event_ interface is now only called for incoming Condor requests,
though. Another interface is the command_ interface, which has
a procedure for each possible incoming Condor request.

Now for some more detail.

Each resource is advertised by the Condor frontend seperately, on
a different port. Requests come in via the main loop, via the select()
call. The fdset from the select call is then 'offered' to all the
resources, i.e. in resmgr_call() the list of resources is walked
through. If a filedescriptor belonging to a resource has incoming data,
the request is handled via the call_incoming function, which calls
the appropriate command_ function. The command_ functions pull
the needed RPC data from the network, and do the work via
the resmgr or event_ interface. A seperate state/context
(err.. classad!) is kept per resource. In effect, you just
have multiple multiplexed startds in one.

How to specify multiple resources. You can specify a comma-separated list
of resources in the RESOURCE_LIST parameter, in the config file.
This list is retrieved by the resource_names function, and each of
those names is then passed to resource_open function. The backend is
expected to know how to match a name with a resource. So the names
are specific to the class of resource that you represent. If you
want to represent multiple CPUs on an SMP system, you can make
the 'stock' Condor backend understand CPU identifiers (cpu0, cpu1)
in resource_open. You probably would not have much explicit control
over placing the jobs on those exact CPUs, I think most systems
require you to be root to bind a process/thread to a certain CPU.

Short description of the main res* functions (the ones that are used):

resmgr_init:
	- Walk through the list of resources to manage, and
	  initialize them.

resmgr_setsocks
	- Add sockets for all the resources, initializing the fdset
	  to be used in select()

resmgr_call
	- Walk through the list of resources, offering them the
	  fdset from select. Check for each resource (in resmgr_command)
	  whether its filedescriptor has an incoming call, and if so,
	  handle the call

resmgr_getbyrid
	- Find the structure describing the information/state for
	  a resource, identified by a resource identifier.
	  Most of the types here, such as resource_id_t and
	  resource_info_t are opaque to the frontend. This
	  function is used a bit too much, as resource_info_t
	  has become the main handle used in the frontend code.	
	  This probably needs to be fixed, it is a slow function.

resmgr_getbyname
	- Same as above, but by name.

resmgr_getbypid
	- Same again, but by process identifier (the job/task
	  that has the resource allocated)

resmgr_walk
	- Function used to walk through the list of maintained resources.
	  Takes a function pointer that is called with a resource_info_t
	  type to do the operation on each resource.

resmgr_changestate
	- Set the new state for the specified resource.


resource_init
	- Do whatever is necesarry to initialize a backend.

resource_names
	- Provide a list of resource names that this backend manages.
	  Will read in RESOURCE_LIST for the Condor backend version.

resource_open
	- Open a resource. Sort of the per-resource version of
	  resource_init

resource_params
	- Set/retrieve parameters for a resource/job/task. For now,
	  in the Condor backend, this just means getting the updated
	  machine statistics such as load average.

resource_allocate
	- Allocate a resource for a given number of jobs and tasks.

resource_activate
	- Run a job on an already allocated resource. For the Condor
	  backend this is just execing the starter.

resource_free
	- Free up a resource.

resource_event
	- Handle a specific event for a resource. Calls the event_
	  interface, which is the only use of the event_ interface
	  now.

resource_initcontext
	- Glue to initialize a context/classad for a given resource.

resource_context
	- Get the current state of a recourse and give back a context
	  (classad)

resource_close
	- Close one specific resource. Does nothing now.


Most of these interfaces were designed to be very generic, but as such,
a lot of their pictured functionality is not used yet.

-------------------------------------------------------------------------------

Well, that's what I can think about for the moment. If you need more
information, I'll be happy to provide it.

- Frank
Frank van der Linden <frank@wins.uva.nl>
