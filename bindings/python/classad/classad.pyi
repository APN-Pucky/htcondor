from typing import Optional, TextIO, Union, Iterator, Callable, Any, Tuple, List, Dict, Mapping


class Value:
    Error: "Value"
    Undefined: "Value"


ClassAdPythonEquivalents = Union[str, int, float, bool]

ClassAdValueType = Union[
    ClassAdPythonEquivalents,
    "ClassAd",
    "ExprTree",
    Value,
    # the real return values are ClassAdValueType instead of Any,
    # but mypy does not support recursive types!
    List[Any],
    Dict[str, Any],
]

ExprTreeOperatorTypes = Union[
    "ExprTree",
    Value,
    ClassAdPythonEquivalents,
]


class ClassAd:
    def __init__(self, input: Optional[Union[str, dict]] = None): ...

    def __delitem__(self, key): ...

    def __getitem__(self, item: str) -> ClassAdValueType: ...

    def eval(self, attr: str) -> ClassAdPythonEquivalents: ...

    def __setitem__(self, key: str, value: ClassAdValueType): ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[str]: ...

    def keys(self) -> Iterator[str]: ...

    def values(self) -> Iterator[ClassAdValueType]: ...

    def items(self) -> Iterator[Tuple[str, ClassAdValueType]]: ...

    def __len__(self) -> int: ...

    # TODO: this is what we have, but obj should be Any; must fix in bindings
    def __contains__(self, obj: str) -> bool: ...

    def lookup(self, attr: str) -> ExprTree: ...

    def printOld(self) -> str: ...

    def printJson(self) -> str: ...

    def get(self, key: str) -> ClassAdValueType: ...

    # TODO: broken in bindings, default can't be None because we can't convert it
    def setdefault(self, key: str, default: ClassAdValueType = None) -> ClassAdValueType: ...

    def update(self, other: Union[Mapping, ClassAd]) -> None: ...

    def flatten(self, expr: ExprTree) -> ExprTree: ...

    def matches(self, ad: ClassAd) -> bool: ...

    def symmetricMatch(self, ad: ClassAd) -> bool: ...

    def externalRefs(self, expr: ExprTree) -> List[str]: ...

    def internalRefs(self, expr: ExprTree) -> List[str]: ...


# TODO: ExprTree methods
class ExprTree:
    def __init__(self, expr: str) -> None: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    # TODO: !?
    def __getitem__(self, item) -> Any: ...

    def _get(self, item) -> Any: ...

    def simplify(self, scope: ClassAd = None) -> "ExprTree": ...

    def eval(self, scope: ClassAd = None) -> ClassAdPythonEquivalents: ...

    def __bool__(self) -> bool: ...

    def __int__(self) -> int: ...

    def __float__(self) -> float: ...

    def __nonzero__(self) -> bool: ...

    def sameAs(self, expr: ExprTree) -> bool: ...

    # we need to ignore the signatures for __eq__ and __ne__,
    # because typeshed has the return type as bool, which is not general
    # enough for use in DSLs
    # https://github.com/python/mypy/issues/2783
    # https://github.com/python/mypy/issues/6710
    def __eq__(self, expr: Any) -> ExprTree: ...  # type: ignore

    def __ne__(self, expr: Any) -> ExprTree: ...  # type: ignore

    def __ge__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __gt__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __le__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __lt__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __and__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rand__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __or__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __ror__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __sub__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rsub__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __add__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __radd__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __mul__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rmul__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __div__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rdiv__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __xor__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __mod__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __lshift__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rlshift__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rshift__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def __rrshift__(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def and_(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def or_(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def is_(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...

    def isnt_(self, expr: ExprTreeOperatorTypes) -> ExprTree: ...


class Parser:
    Auto: "Parser"
    Old: "Parser"
    New: "Parser"


def version() -> str: ...


def lastError() -> str: ...


def registerLibrary(path: str) -> None: ...


def parse(input: Union[str, TextIO]) -> ClassAd: ...


def parseAds(input: Union[str, TextIO], parser: Parser) -> Iterator[ClassAd]: ...


def parseOld(input: Union[str, TextIO]) -> ClassAd: ...


def parseOldAds(input: Union[str, TextIO], parser: Parser) -> Iterator[ClassAd]: ...


def parseOne(input: Union[str, TextIO], parser: Parser) -> ClassAd: ...


def parseNext(input: Union[str, TextIO], parser: Parser) -> ClassAd: ...


def quote(input: str) -> str: ...


def unquote(input: str) -> str: ...


def Literal(obj: ClassAdPythonEquivalents) -> ExprTree: ...


def Function(name: str, *args: str) -> ExprTree: ...


def Attribute(name: str) -> ExprTree: ...


# TODO: signature for the Callable?
def register(function: Callable, name: Optional[str] = None) -> None: ...
