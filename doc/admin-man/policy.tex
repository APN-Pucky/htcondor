%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\label{sec:Configuring-Policy}
Configuring The Startd Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section describes how to configure the \Condor{startd} to
implement the policy you choose for when remote jobs should start, be
suspended, (possibly) resumed, vacated (with a checkpoint) or killed
(no checkpoint).  This policy is the heart of Condor's balancing act
between the needs and wishes of resource owners (machine owners) and
resource users (people submitting their jobs to Condor).  Please read
this section carefully if you plan to change any of the settings
described below, as getting it wrong can have a severe impact on
either the owners of machines in your pool (in which case they might
ask to be removed from the pool entirely) or the users of your pool
(in which case they might stop using Condor).

Much of this section refers to ClassAd expressions.  You probably want
to read through section~\ref{classad-reference} on ClassAd expressions
before continuing with this.

\Note If you are defining the policy for an SMP (multi-CPU) machine,
be sure to also read section~\ref{sec:Configuring-SMP} on
``Configuring The Startd for SMP Machines''.  
Each \Term{virtual machine} represented by the \condor{startd} on an
SMP machine will have its own \Term{state} and \Term{activity}
(described below). 
In the future, each virtual machine will even be able to have its
own policy defined.
For the rest of this section, whenever you see the word ``machine'',
that really just means an individual virtual machine, if you're
talking about an SMP machine that is showing up as multiple virtual
machines in your pool.  

To define your policy, you basically set a number of expressions in
the config file (see section~\ref{sec:Configuring-Condor} on
``Configuring Condor'' for an introduction to Condor's config files).
These expressions are evaluated in the context of the machine's ClassAd
and the ClassAd of a potential resource request (a job that has been
submitted to Condor).
The expressions can therefore reference attributes from either
ClassAd. 
First, we'll list all the attributes that are included in the Machine's
ClassAd.
Then, we'll list all the attributes that are included in a job
ClassAd. 
Next, we'll explain the the \Expr{START} expression, which describes
to Condor what conditions must be met for the machine to start a job.
Then, we'll describe the \Expr{RANK} expression, which allows you to
specify which kinds of jobs a given machine prefers to run.
Then, we'll discuss in some detail how the \Condor{startd} works, in
particular, the machine \Term{states} and \Term{activities}, to give
you an idea of what is possible for your policy decisions.
Finally, we offer two example policy settings.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Startd-Attributes}
Startd ClassAd Attributes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \Condor{startd} represents the machine on which it is running to
the Condor pool.  It publishes a number of characteristics about the
machine in its ClassAd to help in match-making with resource requests.
The values of all these attributes can be found by using
\Prog{\condor{status} -l hostname}.
On an SMP machine, the startd will break the machine up and advertise
it as seperate virtual machines, each with its own name and ClassAd.
The attributes themselves and what they represent are described below:

\input{user-man/machad.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Job-Attributes}
Job ClassAd Attributes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Start-Expr}
The START expression}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The most important expression in the startd (and possibly in all of
Condor) is the \Expr{START} expression.  
This expression describes what conditions must be met for a given
machine to service a resource request (in other words, start someone's
job). 
This expression (like any other expression) can reference attributes
in the machine's ClassAd (such as \Attr{KeyboardIdle}, \Attr{LoadAvg},
etc), or attributes in a potential requester's ClassAd (such as
\Attr{Owner}, \Attr{Imagesize}, even \Attr{Cmd}, the name of the
executable the requester wants to run).
What the \Expr{START} expression evaluates to plays a crucial role in
determining what state and activity the machine is in.

It is technically the \Expr{Requirements} expression that is used for
matching with other jobs.  The startd just always defines the
\Expr{Requirements} expression as the \Expr{START} expression.
However, in situations where the machine wants to make itself
unavailable for further matches, it sets its \Expr{Requirements}
expression to False, not its \Expr{START} expression.  
When the \Expr{START} expression \Term{locally evaluates} to true, the
machine advertises the \Expr{Requirements} expression as ``True'' and
doesn't even publish the \Expr{START} expression.

Normally, the expressions in the machine ClassAd are evaluated against
certain request ClassAds in the \Condor{negotiator} to see if there is
a match, or against whatever request ClassAd currently has claimed the
machine.  However, by locally evaluating an expression, the machine only
evaluates the expression against its own ClassAd.  If an expression
cannot be locally evaluated (because it references other expressions
that are only found in a request ad, such as \Attr{Owner} or
\Attr{Imagesize}), the expression is (usually) undefined.  See the
ClassAd appendix, section~\ref{classad-reference}, for specifics of
how undefined terms are handled in ClassAd expression evaluation. 

\Note If you have machines with lots of real memory and swap space so
  the only scarce resource is CPU time, you could use the
  \Macro{JOB\_RENICE\_INCREMENT} (see
  section~\ref{sec:Starter-Config-File-Entries} on ``\condor{starter}
  Config File Entries'' for details) so that Condor starts jobs on
  your machine with low priority.  Then, you could set
  up your machines with:
\begin{verbatim}
        START : True
        SUSPEND : False
        PREEMPT : False
        KILL : False
\end{verbatim}
  This way, Condor jobs would always run and would never be kicked
  off. 
  However, because they would run with ``nice priority'', interactive 
  response on your machines would not suffer.
  You probably wouldn't even notice Condor was running the jobs, 
  assuming you had enough free memory for the Condor jobs so that you 
  weren't swapping all the time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Rank-Expression}
The RANK expression}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A machine can be configured to prefer running certain jobs over other
jobs.  This is done via the \Expr{RANK} expression.  This is an
expression, just like any other in the machine's ClassAd.  It can
reference any attribute found in either the machine ClassAd or a
request ad (normally, in fact, it references things in the request
ad).  Probably the most common use of this expression is to configure a
machine to prefer to run jobs from the owner of that machine, or by
extension, a group of machines to prefer jobs from the owners of those
machines.  

For example, imagine you have a small research group with 4 machines:
``tenorsax'', ``piano'', ``bass'' and ``drums''.  These machines are
owned by 4 users: ``coltrane'', ``tyner'', ``garrison'' and ``jones'',
respectively.  

Say there's a large Condor pool in your department, but you spent a
lot of money on really fast machines for your group.  You want to make
sure that if anyone in your group has Condor jobs, they have priority
on your machines.  To achieve this, all you have to do is set the Rank
expression on your machines to refer to the \Attr{Owner} attribute and
prefer requests where that attribute matches one of the people in your
group:
\begin{verbatim}
        RANK : Owner == "coltrane" || Owner == "tyner" \
               || Owner == "garrison" || Owner == "jones"
\end{verbatim}

The \Expr{RANK} expression is evaluated as a floating point number.
However, just like in C, boolean expressions evaluate to either 1 or 0
depending on if they're true or false.  So, if this expression
evaluated to 1 (because the remote job was owned by one of the blessed
folks), that would be higher than anyone else (for whom the expression
would evaluate to 0).

If you wanted to get really fancy, you could still have the same basic
setup, where anyone from your group has priority on your machines, but
the actual machine owner has even more priority on their own machine.
For example, you'd put the following entry in Jimmy Garrison's local
config file \File{bass.local}:
\begin{verbatim}
        RANK : Owner == "coltrane" + Owner == "tyner" \
               + (Owner == "garrison") * 10 + Owner == "jones"
\end{verbatim}
Notice, we're using ``+'' instead of ``\Bar\Bar'', since we want to be able
to distinguish which terms matched and which ones didn't.  Now, if
anyone who wasn't in the John Coltrane quartet was running a job on
``bass'', the \Expr{RANK} would evaluate numerically to 0, since none
of those boolean terms would evaluate to 1, and 0+0+0+0 is still 0.
Now, suppose Elvin Jones submits a job.  His job would match this
machine (assuming the \Expr{START} was true for him at that time) and
the \Expr{RANK} would numerically evaluate to 1 (since one of the
boolean terms would evaluate to 1), so Elvin would preempt whoever
else was using the machine at the time.  After a while, say Jimmy
decides to submit a job (maybe even from another machine, it doesn't
matter, all that matters is that it's Jimmy's job).  Now, the
\Expr{RANK} would evaluate to 10, since the boolean that matches him
gets multiplied by 10.  So, Jimmy would preempt even Elvin, and his
job would run on his machine.

The \Expr{RANK} expression doesn't just have to refer to the
\Attr{Owner} of the jobs.  Suppose you have a machine with a ton of
memory, and others with not much at all.  You could configure your
big-memory machine to prefer to run jobs with bigger memory
requirements:
\begin{verbatim}
        RANK : ImageSize
\end{verbatim}

That's all there is to it.  The bigger the job, the more this machine
wants to run it.  That's pretty altruistic of you, always servicing
bigger and bigger jobs, even if they're not yours.  So, perhaps you
still want to be a nice guy, all else being equal, but if you have
jobs, you want to run them, regardless of everyone else's
\Attr{Imagesize}:
\begin{verbatim}
        RANK : (Owner == "coltrane" * 1000000000000) + Imagesize
\end{verbatim}
This scheme would break down if someone submitted a job with an image
size of more 10\Circum12 kbytes.  However, if they did, this Rank expression
preferring their job over yours wouldn't be the only problem Condor
had. :-)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:States}
Machine States}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A given machine could be in a number of different \Term{states},
depending on whether or not the machine is available to run Condor
jobs, and if so, what stage in the Condor protocol has been reached.
The possible states are:

\begin{description}
  
\item[Owner] The machine is being used by the machine owner, or at
  least is not available to run Condor jobs.  When the machine first
  starts up, it begins in this state.
  
\item[Unclaimed] The machine is available to run Condor jobs, but is
  not currently doing so in any way.
  
\item[Matched] The machine is available to run jobs, and has been
  matched by the negotiator with a given schedd.  That schedd just
  hasn't claimed this machine yet.  In this state, the machine is
  unavailable for further matches.

\item[Claimed] The machine has been claimed by a schedd. 
  
\item[Preempting] The machine was claimed by a schedd, but is now
  preempting that claim because either the owner of the machine came
  back, the negotiator decided to preempt this match because another
  user with higher priority has jobs waiting to run, or the negotiator
  decided to preempt this match because it found another request that
  this resource would rather serve (see the \Expr{RANK} expression
  below).

\end{description}

See figure~\ref{fig:machine-states} on page~\pageref{fig:machine-states}
for the various states and the possible transitions between them.

\begin{figure}[hbt]
\centering
\includegraphics{admin-man/machine-states.eps}
\caption{\label{fig:machine-states}Machine States}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Activities}
Machine Activities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Within some of these states, there could be a number of different
\Term{activities} the machine is in.  The idea is that all the things
that are true about a given state are true regardless of what activity
you are in.  However, there are certain important differences between
each activity, which is why they are separated out from each other
within a given state.  In general, you must specify both a state and
an activity to describe what ``state'' the machine is in.  This will be
denoted in this manual as ``state/activity'' pairs.  For example,
``Claimed/Busy''.  The following list describes all the possible
state/activity pairs:

\begin{itemize}

\item Owner
\begin{description}
\item[Idle] This is the only activity for Owner state.  As far as
  Condor is concerned the machine is ``Idle'' (not doing anything for
  Condor).
\end{description}

\item Unclaimed
\begin{description}
  
\item[Idle] This is the normal activity of Unclaimed machines.  The
  machine is still ``Idle'' in that the machine owner is willing to
  let someone run jobs on it, but Condor is still not using the
  machine for anything.
  
\item[Benchmarking] The machine could also be running benchmarks to
  determine the speed on this machine.  It only does this when the
  machine is in the Unclaimed state.  How often it does so is
  determined by the \Expr{RunBenchmarks} expression described below.

\end{description}

\item Matched
\begin{description}
\item[Idle] When Matched, the machine is still ``Idle'' as far as
  Condor is concerned.
\end{description}

\item Claimed
\begin{description}
  
\item[Idle] In this activity, the machine has been claimed, but the
  schedd that claimed it has yet to \Term{activate} the claim by
  requesting a \Condor{starter} to be spawned which would service a
  given job.
  
\item[Busy] Once a \Condor{starter} has been started and the claim is
  active, the machine moves to the Busy activity to signify that it's
  actually doing something as far as Condor is concerned.
  
\item[Suspended] If the job is suspended by Condor, the machine goes
  into the Suspended activity.
  The match between the schedd and machine has not been broken (the
  claim is still valid), but the job is not making any progress and
  Condor is no longer generating a load on the machine.

\end{description}

\item Preempting

  The preempting state is used for evicting a Condor job from a given
  machine.  When the machine enters the Preempting state, it checks the
  \Expr{WANT\_VACATE} expression (described below) to decide which of
  the following activities it should enter:

\begin{description}
  
\item[Vacating] Vacating simply means that the job that was running is
  in the process of checkpointing.  As soon as the checkpoint process
  completes, the machine moves into either the Owner state or the
  Claimed state, depending on why it began preempting in the first
  place.
  
\item[Killing] Killing means that the machine has requested the running
  job to exit the machine immediately, without checkpointing.

\end{description}

\end{itemize}

Figure~\ref{fig:machine-activities} on
page~\pageref{fig:machine-activities} gives the overall view of all
machine states and activities, and shows all the possible transitions
from one to another within the Condor system.  
Each transition is labeled with a number on the diagram, and
transition numbers refered to in this manual will be \Bold{bold}.  
This may seem pretty daunting, but it's actually easier to handle than
it looks.

\begin{figure}[hbt]
\centering
\includegraphics{admin-man/machine-activities.eps}
\caption{\label{fig:machine-activities}Machine States and Activities}
\end{figure}

Various expressions are used to determine when and if many of these
state and activity transitions occur.  Other transitions are initiated
by parts of the Condor protocol (such as when the \Condor{negotiator}
matches a machine with a schedd).  The following section describes the
conditions that lead to the various state and activity transitions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:State-and-Activity-Transitions}
State and Activity Transitions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section will trace through all possible state and activity
transitions within the machine and describe the conditions under which
each one occurs.
Whenever a transition occurs, the machine records when it entered its
new activity and/or new state.
These times are often used to write the expressions that determine
when further transitions occurred (for example, you might only enter
the Killing activity if you've been in the Vacating activity longer
than a given amount of time). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Owner-State}
Owner State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

When the startd is first spawned, the machine it represents enters the
Owner state. 
The machine will remain in this state as long as the \Expr{START}
expression locally evaluates to false.
If the \Expr{START} locally evaluates to true or can't be locally
evaluated (it evaluates to \Term{undefined}), transition \Bold{1} will
occur and the machine will enter the Unclaimed state.

So long as the \Expr{START} expression locally evaluates to false,
there is no possible request in the Condor system that could match it,
so the machine in unavailable to Condor and stays in the Owner state.
For example, if the \Expr{START} expression was:
\begin{verbatim}
START : KeyboardIdle > 15 * $(MINUTE) && Owner == "coltrane" 
\end{verbatim}
and if \Attr{KeyboardIdle} was only 34 seconds, then the machine would
still be in the Owner state, even though it references Owner, which is
undefined.  \verb@False && anything@ is False, even 
\verb@False && undefined@

If, however, the \Expr{START} expression was:
\begin{verbatim}
        START : KeyboardIdle > 15 * $(MINUTE) || Owner == "coltrane"
\end{verbatim}
and \Attr{KeyboardIdle} was still only 34 seconds, then the machine
would leave the Owner state and go to Unclaimed.  This is because
``False || undefined'' is undefined.  So, while this machine isn't
available to just any body, if user ``coltrane'' has jobs submitted,
the machine is willing to run them.  Anyone else would have to wait
until \Attr{KeyboardIdle} exceeds 15 minutes.  However, since
``coltrane'' might claim this resource, but hasn't yet, the machine
goes to the Unclaimed state.

While in the Owner state the startd only polls the status of the
machine every \Macro{UPDATE\_INTERVAL} to see if anything has changed
that would lead it to a different state.  The idea is that you don't
want to put much load on the machine while the Owner is using it
(frequently waking up, computing load averages, checking the access
times on files, computing free swap space, etc), and there's nothing
time critical that the startd needs to be sure to notice as soon as it
happens.  If the \Expr{START} expression evaluates to True and it's 5
minutes before we notice it, that's a drop in the bucket of High
Throughput Computing.

The machine can only go to the Unclaimed state from the Owner state,
and only does so when the \Expr{START} expression no longer locally
evaluates to False.  Generally speaking, if the \Expr{START}
expression locally evaluates to false at any time, the machine will
either transition directly to the Owner state, or to the Preempting
state on its way to the Owner state, if there's a job running that
needs preempting.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Unclaimed-State}Unclaimed State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While in the Unclaimed state, if the \Expr{START} expression locally
evalutes to false, the machine will return to the Owner state via
transition \Bold{2}.

When it's in the Unclaimed state, another expression comes into
effect, \Expr{RunBenchmarks} \label{param:RunBenchmarks}.  
Whenever the \Expr{RunBenchmarks} evaluates to True while the machine
is in the Unclaimed state, the machine will transition from the Idle
activity to the Benchmarking activity (transition \Bold{3}) and
perform benchmarks to determine \Attr{MIPS} and \Attr{KFLOPS}.  
When the benchmarks complete, the machine returns to the Idle activity
(transition \Bold{4}).

The startd automatically inserts an attribute, \Attr{LastBenchmark},
whenever it runs benchmarks, so commonly \Attr{LastBenchmark} is
defined in terms of this attribute, for example:
\begin{verbatim}
        BenchmarkTimer = (CurrentTime - LastBenchmark)
        RunBenchmarks : $(BenchmarkTimer) >= (4 * $(HOUR))
\end{verbatim}
Here, a macro, \Macro{BenchmarkTimer} is defined to help write the
expression.  The idea is that this macro holds the time since the last
benchmark, so when this time exceeds 4 hours, we run the benchmarks
again.  The startd keeps a weighted average of these benchmarking
results to try to get the most accurate numbers possible.  That's why
you would want the startd to run them more than once in its lifetime.

\Note LastBenchmark is initialized to 0 before the benchmarks
have ever been run.
So, if you want the startd to run benchmarks as soon as the machine is
unclaimed (if it hasn't done so already), just include a term for
\Attr{LastBenchmark} as in the example above.

\Note If \Expr{RunBenchmarks} is defined, and set to something
other than ``False'', the startd will automatically run one set of
benchmarks when it first starts up.
So, if you want to totally disable benchmarks, both at startup, and at
any time thereafter, just set \Expr{RunBenchmarks} to ``False'' or
comment it out from your config file.

From the Unclaimed state, the machine can go to two other possible
states: Matched or Claimed/Idle.
Once the \Condor{negotiator} matches an Unclaimed machine with a
requester at a given schedd, the negotiator sends a command to both
parties, notifying them of the match.  
If the schedd gets that notification and initiates the claiming
procedure with the machine before the negotiator's message gets to the
machine, the Match state is skipped entirely, and the machine goes
directly to the Claimed/Idle state (transition \Bold{5}).
However, normally the machine will enter the Matched state (transition
\Bold{6}), even if it's only for a brief period of time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Matched-State}Matched State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Matched state is not very interesting to Condor.  The only
noteworthy things are that the machine lies about its \Expr{START}
expression while in this state and says that \Expr{Requirements} are
false to prevent being matched again before it has been claimed, and
that the startd starts a timer to make sure it doesn't stay in the
Matched state too long.  This timer is set with the
\Macro{MATCH\_TIMEOUT} \label{param:MatchTimeout} config file
parameter.  It is specified in seconds and defaults to 300 (5
minutes).  If the schedd that was matched with this machine doesn't
claim it within this period of time, the machine gives up on it, goes
back into the Owner state via transition \Bold{7} (which it will
probably leave right away to get to the Unclaimed state again, and
wait for another match). 

At any time while the machine is in the Matched state, if the
\Expr{START} expression locally evaluates to false, the machine enters
the Owner state directly (transition \Bold{7}).

If the schedd that was matched with the machine claims it before the
\Macro{MATCH\_TIMEOUT} expires, the machine goes into the Claimed/Idle
state (transition \Bold{8}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Claimed State}
\label{sec:Claimed-State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Claimed state is certainly the most complicated state.
It has the most possible activities, and the most expressions that
determine what it will do next.
In addition the \Condor{checkpoint} and \Condor{vacate} commands only
have any effect on the machine when its in the Claimed state.
In general, there are two sets of expressions that might take effect,
depending on if the universe of the request that claimed the machine is
Standard or Vanilla.
The Standard Universe expressions are the ``normal'' expressions, for
example:
\begin{verbatim}
        WANT_SUSPEND            : True
        WANT_VACATE             : $(ActivationTimer) > 10 * $(MINUTE)
        SUSPEND                 : $(KeyboardBusy) || $(CPUBusy)
        ...
\end{verbatim}

The Vanilla expressions have ``\_VANILLA'' appended to the end, for
example:
\begin{verbatim}
        WANT_SUSPEND_VANILLA    : True
        WANT_VACATE_VANILLA     : True
        SUSPEND_VANILLA         : $(KeyboardBusy) || $(CPUBusy)
        ...
\end{verbatim}

If you don't specify seperate vanilla versions, the normal versions
will be used for all jobs, including vanilla jobs.  
For the purposes of this manual, we'll always refer to the regular 
expressions.
Keep in mind that if the request was a Vanilla Universe, the Vanilla
expressions (if they were defined) would be in effect, instead.
The reason for this is that the resource owner might want the machine
to behave differently for Vanilla jobs, since they can't checkpoint.
For example, they might want to let Vanilla jobs remain suspended for
much longer than standard jobs.

While Claimed, the \Macro{POLLING\_INTERVAL} takes effect, and the
startd starts polling the machine much more frequently to evaluate its
state.

If the owner starts typing on the console again, we want to notice as
soon as possible and start doing whatever that owner wants at that
point.
For SMP machines, if any virtual machine is in the Claimed state, the
startd will poll the machine more frequently.
If we're already polling for one virtual machine, it doesn't really
cost us any more to evaluate the state of all the virtual machines at
the same time.

In general, when the startd is going to kick a job off a machine
(usually because of activity on the machine that signifies that the
owner is using the machine again) the startd will go through
successive levels of getting the job out of the way.
The first and least costly to the job is suspending it.
This even works for Vanilla jobs.
If suspending the job for a little while doesn't satisfy the machine
owner, (the owner is still using the machine after a certain period of
time, for example), the startd moves on to vacating the job, which
involves performing a checkpoint so that the work it had completed up
until this point is not lost.
If even that does not satisfy the machine owner (usually because it's
taking too long and the owner wants their machine back \emph{now}),
the final, most drastic stage is reached: killing.  
Killing is just quick death to the job, without a checkpoint.  
For Vanilla jobs, vacating and killing are basically equivalent,
though a vanilla job can request to have a certain \Term{softkill
signal} sent to it at vacate time so that it can perform
application-specific checkpointing, for example.

The \Expr{WANT\_SUSPEND} expression determines if the machine will even
evaluate the \Expr{SUSPEND} expression to consider entering the
Suspended activity.
The \Expr{WANT\_VACATE} expression determines what happens when the
machine enters the preempting state, whether it will go to the vacating
activity, or go directly to killing. 
If one or both of these expressions evaluates to false, the machine
will skip that stage of getting rid of the job and proceed directly to
the more drastic stages.

When the machine first enters the Claimed state, it goes to the Idle
activity.  From there, it has two options.  
It can enter the Preempting state via transition \Bold{9} (if a 
\Condor{vacate} comes in, or if the \Expr{START} expression locally
evaluates to false).  
Or, it can enter the busy activity (transition \Bold{10}) if the
schedd that has claimed the machine decides to activate the claim and
start a job.

From Claimed/Busy, the machine can go to many different state/activity
combinations.
The startd evaluates the \Expr{WANT\_SUSPEND} expression to decide
which other expressions to evaluate.  
If \Expr{WANT\_SUSPEND} is true, the startd will evalutate the
\Expr{SUSPEND} expression, and if it is false, the startd will
evaluate the \Expr{PREEMPT} expression and skip the Suspended activity
entirely.
Here are all the possibile state/activity destinations that the
machine can get to from Claimed/Busy:

\begin{description}
  
\item[Claimed/Idle] If the starter that is serving a given job exits
  (because the jobs completes, for example), the machine will go back
  to Claimed/Idle (transition \Bold{11}).
  
\item[Preempting] If \Expr{WANT\_SUSPEND} is false and the
  \Expr{PREEMPT} expression is true, the machine will enter the
  Preempting state (transition \Bold{12}).
  
\item[Claimed/Suspended] If both the \Expr{WANT\_SUSPEND} and
  \Expr{SUSPEND} expressions evaluate to true, the machine will
  suspend the job (transition \Bold{13}).
  
  The other reason the machine would go from Claimed/Busy to
  Preempting is if the \Condor{negotiator} matched the machine
  with a ``better'' match.  This better match could either be from the
  machine's perspective (see section~\ref{sec:Rank-Expression} on the
  \Expr{RANK} Expression above) or from the negotiator's perspective
  (because a user with a better user priority has jobs that should be
  running on this machine).
  In this case, \Expr{WANT\_VACATE} is assumed to be true, and the
  machine will always go to Preempting/Vacating.
  
\item[Claimed/Busy] While it's not really a state change, there is
  another thing that could happen to the machine while it's in
  Claimed/Busy, which is that either a \Condor{checkpoint} command
  could arrive, or the \Expr{PeriodicCheckpoint} expression could
  evaluate to true.  When either of these things occur, the startd
  requests that the job begin a periodic checkpoint.  Since the startd
  has no way to know when this process completes, there's no way
  periodic checkpointing could be its own state.  However, for the
  purposes of all the expressions, periodic checkpointing is
  Claimed/Busy, just like a job was running.

\end{description}

You already know what happens in Claimed/Idle, so now we'll discuss
what happens in Claimed/Suspended.  Again, there are multiple
state/activity combinations that you can reach from Claimed/Suspended:

\begin{description}
  
\item[Claimed/Busy] If the \Expr{CONTINUE} expression evaluates to
  true, the machine will resume the computation and will go back to the
  Claimed/Busy state (transition \Bold{14}).

\item[Preempting] If the \Expr{PREEMPT} expression is true, the machine
  will enter the Preempting state (transition \Bold{15}).

\end{description}

From the Claimed state, you can only enter other activities in the
Claimed state (all of which we've already discussed), or the
Preempting state, which is described next.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Preempting-State}Preempting State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Preempting state is much less complicated than the Claimed state.
Basically, there are two possible activities, and two possible
destinations.  Depending on \Expr{WANT\_VACATE} you either enter the
Vacating activity (if it's true) or the Killing activity (if it's
false).  

While in the Preempting state (regardless of activity) the machine
advertises its \Expr{Requirements} expression as False to signify that
it is not available for further matches, either because it is about to go
to the owner state anyway, or because it has already been matched with
one preempting match, and further preempting matches are disallowed
until the machine has been claimed by the new match.

The main function of the Preempting state is to get rid of the starter
associated with this resource.  If the \Condor{starter} associated
with a given claim exits while the machine is still in the Vacating
activity, it means the job successfully completed its checkpoint.

If the machine is in the Vacating activity, it keeps evaluating the 
\Expr{KILL} expression.  As soon as this expression evaluates to true,
the machine enters the Killing activity (transition \Bold{16}).

When the starter exits, or if there was no starter running when the
machine enters the Preempting state (because it came from
Claimed/Idle), the other job of the preempting state is completed:
notifying the schedd that had claimed this machine that the claim is
broken.

At this point, the machine will either enter the Owner state via
transition \Bold{17} (if the job was preempted because the machine
owner came back) or the Claimed/Idle state via transition \Bold{18}
(if the job was preempted because a better match was found).

Then the machine enters the Killing activity, it begins a timer, the
length of which is defined by the \Macro{KILLING\_TIMEOUT}
\label{param:KillingTimeout} macro.  This macro is defined in seconds 
and defaults to 30.  If this timer expires and the machine is still in
the Killing activity, something has gone seriously wrong with the
\Condor{starter} and the startd tries to vacate the job immediately by
sending SIGKILL to all of the \Condor{starter}'s children, and then to
the \Condor{starter} itself.

Again, once the starter is gone and the schedd that had claimed the
machine is notified that the claim is broken, the machine will either
enter the Owner state via transition \Bold{19} (if the job was
preempted because the machine owner came back) or the Claimed/Idle
state via transition \Bold{20} (if the job was preempted because a
better match was found). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:State-Expression-Summary}
State/Activity Transition Expression Summary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The following section is meant to summarize the information from the
previous sections to serve as a quick reference.  If anything is
unclear here, please refer to the previous sections for clarification.

\begin{description}
  
\item[\Expr{START}] When this is true, the machine is willing to spawn
  a remote Condor job.
  
\item[\Expr{RunBenchmarks}] While in the Unclaimed state, the machine
  will run benchmarks whenever this is true.
  
\item[\Macro{MATCH\_TIMEOUT}] If the machine has been in the Matched
  state longer than this, it will go back to the Owner state.
  
\item[\Expr{WANT\_SUSPEND}] If this is true, the machine will evaluate
  the \Expr{SUSPEND} expression to see if it should transition to the
  Suspended activity.  If this is false, the machine will look at
  the \Expr{PREEMPT} expression.
  
\item[\Expr{SUSPEND}] If \Expr{WANT\_SUSPEND} is true, and the machine
  is in the Claimed/Busy state, it will enter the Suspended activity
  if \Expr{SUSPEND} is true.
  
\item[\Expr{CONTINUE}] If the machine is in the Claimed/Suspended
  state, it will enter the Busy activity if \Expr{CONTINUE} is true.
  
\item[\Expr{PREEMPT}] If the machine is either in the Claimed/Suspended
  activity, or is in the Claimed/Busy activity and the
  \Expr{WANT\_SUSPEND} is false, the machine will enter the Preempting
  state whenever \Expr{PREEMPT} is true. 
  
\item[\Expr{WANT\_VACATE}] This is only checked when the
  \Expr{PREEMPT} expression is true and the machine enters the
  Preempting state.
  If \Expr{WANT\_VACATE} is true, the machine will enter the Vacating
  activity.  
  If it is false, the machine will proceed directly to the Killing
  activity.  
  
\item[\Expr{KILL}] If the machine is the Preempting/Vacating state, it
  will enter Preempting/Killing whenever \Expr{KILL} is true. 
  
\item[\Macro{KILLING\_TIMEOUT}] If the machine is in the
  Preempting/Killing state for longer than \Macro{KILLING\_TIMEOUT}
  seconds, the startd will just send a SIGKILL to the \Condor{starter}
  and all its children to try to kill the job as quickly as possible.
  
\item[\Expr{PERIODIC\_CHECKPOINT}] If the machine is in the
  Claimed/Busy state and \Expr{PERIODIC\_CHECKPOINT} is true, the
  user's job will begin a periodic checkpoint.
  
\item[\Expr{RANK}] If this expression evaluates to a higher number for
  a pending resource request than it does for the current request, the
  machine will preempt the current request (enter the
  Preempting/Vacating state).  When the preemption is complete, the
  machine will enter the Claimed/Idle state with the new resource
  request claiming it.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\label{sec:Example-Policy}Example Policy Settings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following section provides two examples of how you might configure
the policy at your pool.  Each one is described in English, then the
actual macros and expressions used are listed and explained with
comments.  Finally the entire set of macros and expressions are listed
in one block so you can see them in one place for easy reference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:Default-Policy}Default Policy Settings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

These settings are the default as shipped with Condor.  They have been
used for many years with no problems.  The Vanilla expressions are
identical to the regular ones. (They aren't even listed here.  If you
don't define them, the regular expressions are used for Vanilla jobs
as well).

First, we define a bunch of macros which help us write the expressions
more clearly.  In particular, we use:

\begin{description}
  
\item[\Macro{StateTimer}] How long we've been in the current state.

\item[\Macro{ActivityTimer}] How long we've been in the current
  activity. 

\item[\Macro{ActivationTimer}] How long the has job been running on
  this machine.

\item[\Macro{LastCkpt}] How long it's been since we last performed a
  periodic checkpoint.

\item[\Macro{NonCondorLoadAvg}] The difference of the system load and
  the Condor load (i.e the load generated by everything but Condor).

\item[\Macro{BackgroundLoad}] How much background load we're willing
  to have on our machine and still start a Condor job.

\item[\Macro{BackgroundLoad}] How much background load we're willing
  to have on our machine and still start a Condor job.

\item[\Macro{HighLoad}] If the \MacroU{NonCondorLoadAvg} goes over
  this, the CPU is ``busy'' and we want to start evicting the Condor
  job. 

\item[\Macro{StartIdleTime}] How long the keyboard has to be idle
  before we'll start a job.

\item[\Macro{ContinueIdleTime}] How long the keyboard has to be idle
  before we'll resume a suspended job.

\item[\Macro{MaxSuspendTime}] How long we're willing to let the job be
  suspended before we move on to more drastic measures.

\item[\Macro{MaxVacateTime}] How long we're willing to let the job be
  checkpointing before we give up on it and have to kill it outright.

\item[\Macro{KeyboardBusy}] A boolean string that evaluates to true
    when the keyboard is being used. 

\item[\Macro{CPU\_Idle}] A boolean string that evaluates to true
    when the CPU is idle is being used.

\item[\Macro{CPU\_Busy}] A boolean string that evaluates to true
    when the CPU is busy.

\item[\Macro{MachineBusy}] The CPU or the Keyboard is busy.

\end{description}

\begin{verbatim}
##  These macros are here to help write legible expressions:
MINUTE          = 60
HOUR            = (60 * $(MINUTE))
StateTimer      = (CurrentTime - EnteredCurrentState)
ActivityTimer   = (CurrentTime - EnteredCurrentActivity)
ActivationTimer = (CurrentTime - JobStart)

NonCondorLoadAvg        = (LoadAvg - CondorLoadAvg)
BackgroundLoad          = 0.3
HighLoad                = 0.5
StartIdleTime           = 15 * $(MINUTE)
ContinueIdleTime        = 5 * $(MINUTE)
MaxSuspendTime          = 10 * $(MINUTE)
MaxVacateTime           = 5 * $(MINUTE)

KeyboardBusy            = KeyboardIdle < $(MINUTE)
CPU_Idle                = $(NonCondorLoadAvg) <= $(BackgroundLoad)
CPU_Busy                = $(NonCondorLoadAvg) >= $(HighLoad)
MachineBusy             = ($(CPU_Busy) || $(KeyboardBusy))
\end{verbatim}

Now, we define that we always want to suspend jobs.
If that's not enough, we'll always try to gracefully vacate them,
unless they've only been running for less than 10 minutes anyway, in
which case we'll just kill them, instead of trying to checkpoint those
10 minutes of work.
\begin{verbatim}
WANT_SUSPEND            : True
WANT_VACATE             : $(ActivationTimer) > 10 * $(MINUTE)
\end{verbatim}

Finally, we define the actual expressions.  Start any job if the CPU
is idle (as defined by our macro), and the keyboard has been idle long
enough.
\begin{verbatim}
START           : $(CPU_Idle) && KeyboardIdle > $(StartIdleTime)
\end{verbatim}

Suspend a job if the machine is busy.
\begin{verbatim}
SUSPEND         : $(MachineBusy)
\end{verbatim}

Continue a suspended job if the CPU is idle and the Keyboard has been
idle for long enough.
\begin{verbatim}
CONTINUE        : $(CPU_Idle) && KeyboardIdle > $(ContinueIdleTime)
\end{verbatim}

There are two conditions that we want to preempt under.
First, if we have suspended the job, but it's been suspended too long.
Second, if we don't even want to suspend the job, and the machine is
busy. 
\begin{verbatim}
PREEMPT	        : ( ($(ActivityTimer) > $(MaxSuspendTime)) && \
                   (Activity == "Suspended") ) || \
                  ( $(MachineBusy) && (WANT_SUSPEND == False) )
\end{verbatim}

Kill a job if we've been vacating for too long.
\begin{verbatim}
KILL            : $(ActivityTimer) > $(MaxVacateTime)
\end{verbatim}

Finally, specify we want periodic checkpointing.  
For jobs smaller than 60 megs, we periodic checkpoint every 6 hours.  
For larger jobs, we only checkpoint every 12 hours.
\begin{verbatim}
PERIODIC_CHECKPOINT     : ( (ImageSize < 60000) && \
                            ($(LastCkpt) > (6 * $(HOUR))) ) || \ 
                          ( $(LastCkpt) > (12 * $(HOUR)) )
\end{verbatim}

For clarity and reference, the entire set policy settings are included
once more without comments:

\begin{verbatim}
##  These macros are here to help write legible expressions:
MINUTE          = 60
HOUR            = (60 * $(MINUTE))
StateTimer      = (CurrentTime - EnteredCurrentState)
ActivityTimer   = (CurrentTime - EnteredCurrentActivity)
ActivationTimer = (CurrentTime - JobStart)
LastCkpt	= (CurrentTime - LastPeriodicCheckpoint)

NonCondorLoadAvg        = (LoadAvg - CondorLoadAvg)
BackgroundLoad          = 0.3
HighLoad                = 0.5
StartIdleTime           = 15 * $(MINUTE)
ContinueIdleTime        = 5 * $(MINUTE)
MaxSuspendTime          = 10 * $(MINUTE)
MaxVacateTime           = 5 * $(MINUTE)

KeyboardBusy            = KeyboardIdle < $(MINUTE)
CPU_Idle                = $(NonCondorLoadAvg) <= $(BackgroundLoad)
CPU_Busy                = $(NonCondorLoadAvg) >= $(HighLoad)
MachineBusy             = ($(CPU_Busy) || $(KeyboardBusy))

WANT_SUSPEND            : True
WANT_VACATE             : $(ActivationTimer) > 10 * $(MINUTE)

START           : $(CPU_Idle) && KeyboardIdle > $(StartIdleTime)
SUSPEND         : $(MachineBusy)
CONTINUE        : $(CPU_Idle) && KeyboardIdle > $(ContinueIdleTime)
PREEMPT	        : ( ($(ActivityTimer) > $(MaxSuspendTime)) && \
                   (Activity == "Suspended") ) || \
                  ( $(MachineBusy) && (WANT_SUSPEND == False) )
KILL            : $(ActivityTimer) > $(MaxVacateTime)

PERIODIC_CHECKPOINT     : ( (ImageSize < 60000) && \
                            ($(LastCkpt) > (6 * $(HOUR))) ) || \ 
                          ( $(LastCkpt) > (12 * $(HOUR)) )
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\label{sec:UW-Policy}
UW-Madison CS Condor Pool Policy Settings} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Due to a recent increase in the number of Condor users and the size of
their jobs (many users here are submitting jobs with an
\Attr{Imagesize} of over 100 megs!), we have had to customize our
policy to try to handle this range of \Attr{Imagesize} better.

Basically, whether or not we suspend or vacate jobs is now a function
of the \Attr{Imagesize} of the job that's currently running (which is
defined in terms of kilobytes).  We have divided the \Attr{Imagesize}
into three possible categories, which we define with macros.
\begin{verbatim}
BigJob          = (ImageSize > (30 * 1024))
MediumJob       = (ImageSize <= (30 * 1024) && ImageSize >= (10 * 1024))
SmallJob        = (ImageSize < (10 * 1024))
\end{verbatim}

Our policy can be summed up with the following few sentences: If the
job is ``small'', it goes through the normal progression of suspend to
vacate to kill based on the tried and true times.  If the job is
``medium'', when the user comes back, we start vacating the job right
away.  The idea is that if we checkpoint immediately, all our pages
are still in memory, checkpointing will be fast, and we'll free up
memory pages as soon as we checkpoint.  If we suspend, our pages will
start getting swapped out and when we finally want to checkpoint (10
minutes later), we'll have to start swapping out the user's pages
again, they'll see reduced performance, and checkpointing will take
much longer.  If the job is ``big'', don't even bother checkpointing,
since we won't finish before the owner gets too upset and we might as
well not even bother putting the wasted load on the network and
checkpoint server.

All the logic for our pool's special policy is tuned with the
\Expr{WANT\_\*} expressions. 
All of the other expressions and macros just use the defaults.
We only want to suspend jobs if they are ``small'', and we only want
to vacate jobs that are ``small'' or ``medium''.  
We still want to always suspend Vanilla jobs, regardless of their
size.
\begin{verbatim}
WANT_SUSPEND            : $(SmallJob)
WANT_VACATE             : $(MediumJob) || $(SmallJob)
WANT_SUSPEND_VANILLA    : True
WANT_VACATE_VANILLA     : True
\end{verbatim}

Now, we define the actual expressions, (which we just use the defaults
for).
We really do this with macros and simply define the expressions with
the macros later on.
This may seem really strange, but we do it because it makes it easier
to do special customized settings (for example, for testing purposes)
and still reference the defaults.
There will be a brief example of this at the end of this section.
\begin{verbatim}
CS_START        = $(CPU_Idle) && KeyboardIdle > $(StartIdleTime)
CS_SUSPEND      = $(MachineBusy)
CS_CONTINUE     = (KeyboardIdle > $(ContinueIdleTime)) && $(CPU_Idle)
CS_PREEMPT      = ( ($(ActivityTimer) > $(MaxSuspendTime)) && \
                   (Activity == "Suspended") ) || \
                  ( $(MachineBusy) && (WANT_SUSPEND == False) )
CS_KILL         = ($(ActivityTimer) > $(MaxVacateTime))
\end{verbatim}

Here's where we actually define the expressions in terms of our
special macros:
\begin{verbatim}
START       : $(CS_START)
SUSPEND     : $(CS_SUSPEND)
CONTINUE    : $(CS_CONTINUE)
PREEMPT     : $(CS_PREEMPT)
KILL        : $(CS_KILL)
\end{verbatim}

We still don't want to define seperate Vanilla versions of any of
these, since we already have a different \Expr{WANT\_SUSPEND} for
vanilla jobs and all of the policy expressions are just written in
terms of that. 

Periodic checkpointing also takes image size into account.  
Since we kill large jobs right away at eviction time, we want to
periodically checkpoint them more frequently (every 3 hours), since
that's the only way they make forward progress.
However, with all those large periodic checkpoints going on on so
frequently, we don't want to bog down our network or our checkpoint
servers.
So, we only periodic checkpoint small or medium jobs every 12 hours,
since they get the privilege of checkpointing at eviction time.
\begin{verbatim}
PERIODIC_CHECKPOINT  : (($(LastCkpt) > (3 * $(HOUR))) \
      && $(BigJob)) || (($(LastCkpt) > (12 * $(HOUR))) && \
      ($(SmallJob) || $(MediumJob)))
\end{verbatim}

For clarity and reference, the entire set of policy settings are
included once more, without comments:
\begin{verbatim}
ActivationTimer = (CurrentTime - JobStart)
StateTimer      = (CurrentTime - EnteredCurrentState)
ActivityTimer   = (CurrentTime - EnteredCurrentActivity)
LastCkpt        = (CurrentTime - LastPeriodicCheckpoint)

NonCondorLoadAvg   = (LoadAvg - CondorLoadAvg)
BackgroundLoad     = 0.3
HighLoad           = 0.5
StartIdleTime      = 15 * $(MINUTE)
ContinueIdleTime   = 5 * $(MINUTE)
MaxSuspendTime     = 10 * $(MINUTE)
MaxVacateTime      = 5 * $(MINUTE)

KeyboardBusy       = KeyboardIdle < $(MINUTE)
CPU_Idle           = $(NonCondorLoadAvg) <= $(BackgroundLoad)
CPU_Busy           = $(NonCondorLoadAvg) >= $(HighLoad)
MachineBusy        = ($(CPU_Busy) || $(KeyboardBusy))

BigJob       = (ImageSize > (30 * 1024))
MediumJob    = (ImageSize <= (30 * 1024) && ImageSize >= (10 * 1024))
SmallJob     = (ImageSize < (10 * 1024))

WANT_SUSPEND            : $(SmallJob)
WANT_VACATE             : $(MediumJob) || $(SmallJob)
WANT_SUSPEND_VANILLA    : True
WANT_VACATE_VANILLA     : True

CS_START    = $(CPU_Idle) && KeyboardIdle > $(StartIdleTime)
CS_SUSPEND  = $(CPU_Busy) || $(KeyboardBusy)
CS_CONTINUE = (KeyboardIdle > $(ContinueIdleTime)) && $(CPU_Idle)
CS_PREEMPT  = ( ($(ActivityTimer) > $(MaxSuspendTime)) && \
               (Activity == "Suspended") ) || \
              ( $(MachineBusy) && (WANT_SUSPEND == False) )
CS_KILL     = ($(ActivityTimer) > $(MaxVacateTime))

START       : $(CS_START)
SUSPEND     : $(CS_SUSPEND)
CONTINUE    : $(CS_CONTINUE)
PREEMPT     : $(CS_PREEMPT)
KILL        : $(CS_KILL)

PERIODIC_CHECKPOINT  : (($(LastCkpt) > (3 * $(HOUR))) \
      && $(BigJob)) || (($(LastCkpt) > (12 * $(HOUR))) && \
      ($(SmallJob) || $(MediumJob)))
\end{verbatim}

As a final example, we show how our default macros can be used to
setup a given machine for testing.  Suppose we want the machine to
behave just like normal, but if user ``coltrane'' submits a job, we
want that job to start regardless of what's happening on the machine,
and we don't want the job suspended, vacated or killed.  For example,
we might know ``coltrane'' is just going to be submitting very short
running programs to test something and he wants to see them execute
right away.  Anyway, we could configure any machine (or our whole
pool, for that matter) with the following 5 expressions:
\begin{verbatim}
        START      : ($(CS_START)) || Owner == "coltrane"
        SUSPEND    : ($(CS_SUSPEND)) && Owner != "coltrane"
        CONTINUE   : $(CS_CONTINUE)
        PREEMPT    : ($(CS_PREEMPT)) && Owner != "coltrane"
        KILL       : $(CS_KILL)
\end{verbatim}
Notice that you don't have to do anything special with either the
\Expr{CONTINUE} or \Expr{KILL} expressions.
If Coltrane's jobs never suspend, they'll never even look at
\Expr{CONTINE}.  
Similarly, if they never preempt, they'll never look at \Expr{KILL}. 
