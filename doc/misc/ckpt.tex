Checkpointing is taking a snapshot of the current state of a program
in such a way that the program can be restarted from that state at a
later time.  Checkpointing gives the Condor scheduler the freedom to
reconsider scheduling decisions through preemptive-resume scheduling.
If the scheduler decides to no longer allocate a machine to a job (for
example, when the owner of that machine returns), it can checkpoint
the job and preempt it without losing the work the job has already
accomplished.  The job can be resumed later when the scheduler
allocates it a new machine.  Additionally, periodic checkpointing
provides fault tolerance in Condor.  Snapshots are taken periodically,
and after an interruption in service the program can continue from the
most recent snapshot.

Condor provides checkpointing services to single process jobs on a
number of Unix platforms.
To enable checkpointing, the user must link the program with the
Condor system call library (\File{libcondorsyscall.a}), using the
\Condor{compile} command.
This means that the
user must have the object files or source code of the program to use
Condor checkpointing.  However, the checkpointing services provided by
Condor are strictly optional.  So, while there are some classes of
jobs for which Condor does not provide checkpointing services, these
jobs may still be submitted to Condor to take advantage of Condor's
resource management functionality.  (See
section~\ref{sec:standard-universe} on
page~\pageref{sec:standard-universe} for a description of the
classes of jobs for which Condor does not provide checkpointing
services.)

Process checkpointing is implemented in the Condor system call library
as a signal handler.  When Condor sends a checkpoint signal to a
process linked with this library, the provided signal handler writes
the state of the process out to a file or a network socket.  This
state includes the contents of the process stack and data segments,
all shared library code and data mapped into the process's address
space, the state of all open files, and any signal handlers and
pending signals.  On restart, the process reads this state from the
file, restoring the stack, shared library and data segments, file
state, signal handlers, and pending signals.  The checkpoint signal
handler then returns to user code, which continues from where it left
off when the checkpoint signal arrived.

Condor processes for which checkpointing is enabled perform a
checkpoint when preempted from a machine.  When a suitable replacement
execution machine is found (of the same architecture and operating
system), the process is restored on this new machine from the
checkpoint, and computation is resumed from where it left off.  Jobs
that can not be checkpointed are preempted and restarted from the
beginning.

Condor's periodic checkpointing provides fault tolerance.  Condor
pools are each configured with the \Expr{PERIODIC\_CHECKPOINT}
expression which controls when and how often jobs which can be
checkpointed do periodic checkpoints (examples: never, every three
hours, etc.).  When the time for a periodic checkpoint occurs, the job
suspends processing, performs the checkpoint, and immediately
continues from where it left off.  There is also a \Condor{ckpt} command
which allows the user to request that a Condor job immediately perform
a periodic checkpoint.

In all cases, Condor jobs continue execution from the most recent
complete checkpoint.  If service is interrupted while a checkpoint is
being performed, causing that checkpoint to fail, the process will
restart from the previous checkpoint.  Condor uses a commit style
algorithm for writing checkpoints: a previous checkpoint is deleted
only after a new complete checkpoint has been written successfully.

In certain cases, checkpointing may be delayed until a more appropriate
time.  For example, a Condor job will defer a checkpoint request if
it is communicating with another process over the network.  When the
network connection is closed, the checkpoint will occur.

The Condor checkpointing facility can also be used for any Unix process
outside of the Condor batch environment. Standalone checkpointing
is described in section~\ref{sec:standalone-ckpt}.

Condor can now read and write compressed checkpoints.  This new
functionality is provided in the \File{libcondorzsyscall.a} and
\File{libcondorzckpt.a} libraries.  
If \File{/usr/lib/libz.a} exists on your workstation, \Condor{compile}
will automatically link your job with the compression-enabled version
of the checkpointing library.

By default, a checkpoint is written to a file on the local disk of the
machine where the job was submitted.  A checkpoint server is available
to serve as a repository for checkpoints.  (See
section~\ref{sec:Ckpt-Server} on page~\pageref{sec:Ckpt-Server}.)
When a host is configured to use a checkpoint server, jobs submitted
on that machine write and read checkpoints to and from the server
rather than the local disk of the submitting machine, taking the
burden of storing checkpoint files off of the submitting machines and
placing it instead on server machines (with disk space dedicated to
the purpose of storing checkpoints).

\subsection{\label{sec:standalone-ckpt}Standalone Checkpointing}

Using the Condor checkpoint library without the remote system call
functionality and outside of the Condor system is known as standalone
mode checkpointing.

To prepare a program for standalone checkpointing, simply use the
\Condor{compile} utility as for a standard Condor job, but do not
use \Condor{submit} -- just run your program normally from the command
line.  The checkpointing library will print a message to let you know
that checkpointing is enabled and to inform you where the checkpoint
image is stored:

\begin{verbatim}
Condor: Will checkpoint to program_name.ckpt
Condor: Remote system calls disabled.
\end{verbatim}

To force the program to write a checkpoint image and stop, send it
the SIGTSP signal or press control-Z.  To force the program to 
write a checkpoint image and continue executing, send it the
SIGUSR2 signal.

To restart the program from a checkpoint, run it again with the
option ``-\_condor\_restart'' and the name of the checkpoint
image file.

To use a different filename for the checkpoint image, use the option
''-\_condor\_ckpt'' and the name of the file you want checkpoints
written to.

\subsection{\label{sec:ckpt-api}Checkpoint Library Interface}

A program need not be rewritten to take advantage of checkpointing.
However, the checkpointing library provides several C entry points
that allow for a program to control its own checkpointing behavior
if needed.

\begin{itemize}

\item \verb$void ckpt()$\\
This function causes a checkpoint image to be written to disk.
The program will continue to execute.  This is identical to sending
the program a SIGUSR2 signal.

\item \verb$void ckpt_and_exit()$\\
This function causes a checkpoint image to be writtent to disk.
The program will then exit.  This is identical to sending the program
a SIGTSTP signal.

\item \verb$void init_image_with_file_name( char *ckpt_file_name )$\\
This function prepares the library to restart from the 
given file name. \verb$restart()$ must be called to perform the
actual restart.

\item \verb$void init_image_with_file_descriptor( int fd )$\\
This function prepares the library to restart from
the given file descriptor.  \verb$restart()$ must be called to
perform the actual restart.

\item \verb$void restart()$\\
This function causes the program to read the checkpoint
image specified by one of the above functions, and to resume the
program where the checkpoint left off.  This function does
not return.

\item \verb$void _condor_ckpt_disable()$\\
This function temporarily disables checkpointing.  This can
be handy if your program does something with is not checkpoint-safe.
For example, if a program must not be interrupted while accessing
a special file, call \verb$_condor_ckpt_disable()$, access the
file, and then call \verb$_condor_ckpt_enable()$.  Some program
actions, such as opening a socket or a pipe, implicitly cause
checkpointing to be disabled.

\item \verb$void _condor_ckpt_enable()$\\
This function re-enables checkpointing after a call to
\verb$_condor_ckpt_disable()$.  If a checkpointing signal arrived
while checkpointing was disabled, the checkpoint will occur when
this function is called.  Disabling and enabling of checkpointing
must occur in matched pairs.  \verb$_condor_ckpt_enable()$ must
be called once for every time that \verb$_condor_ckpt_disable()$
is called.

\item \verb$extern int condor_compress_ckpt$\\
Setting this variable to one causes checkpoint images to be compressed.
Setting it to zero disables compression.

\item \verb$extern int condor_debug_output$\\
Setting this variable to one causes additional debugging information
to be shown during the checkpoint process.  Setting it to zero
disables debug messages.

\end{itemize}
