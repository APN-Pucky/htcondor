
\subsection{Introduction}

Bypass is a tool for replacing UNIX system calls and library procedures with new code.

Bypass reads an interface description (ID) that describes what procedures are to be replaced and what code is to be inserted.  The output is a C++ module that may be compiled and then linked with an arbitray program.  A C++ compiler is required to build the code created by Bypass, but the resulting code works effectively with any language using C calling conventions.  On most platforms, this includes C, C++, and Fortran.

Bypass can also generate RPC stubs and a simple RPC server according to the ID.  With this feature, a program can be transparently instrumented to send any or all of its library calls to another process for execution.   To use this feature, you must link with the Condor External Data Representation (CEDAR) library.

Bypass is used to implement a portion of the Condor distributed batch system.  A number of the more esoteric features of Bypass exist soley for this purpose.

This chapter consists of a cookbook and a reference.  The cookbook gives several examples of ID files.  The reference section enumerates all the various and sundry features of Bypass.

\subsection{Cookbook}

\subsubsection{Getting Started}

Bypass is a standalone program that is packaged with the Condor distributed batch sytem.  To compile code produced by Bypass, you will need to do several things:

\begin{enumerate}
\item Unpack the Condor distribution into a directory.
\item Add the \File{bin} sub-directory to your path.
\item Add the \File{include} sub-directory to your compiler include path.
\item Add the \File{lib} sub-directory to your linker search path.
\item Set the environment variable \Env{BYPASS\_LIBRARY\_DIR} to the \File{lib} sub-directory.
\end{enumerate}

The \File{examples} sub-directory contains a simple program named \Prog{display.c} and several examples of instrumenting the program with Bypass code.

By itself, \Prog{display} simply opens up a file named on the command
line, and then displays the first five lines of the file.  Here's some example output:

\begin{verbatim}
>>> ./display /etc/passwd
0: root:x:0:1:System Administration:/:/sbin/sh
1: operator:X:5:5:System Backups:/u/o/p/operator:/bin/tcsh
2: troot:x:0:1:System Administration:/:/bin/tcsh
3: smtp:x:0:0:mail daemon user:/:
4: daemon:x:1:1:System Administration:/:
\end{verbatim}

Bypass can be used to instrument this program as either a standalone client or a client and server. A standalone client simply uses Bypass to augment its procedure calls with additional code.  A client and server use Bypass to augment code with remote procedure calls that are executed by the server program.

\subsubsection{A Standalone Client}

An ID file consists of a prologue and a declaration for every procedure that will be replaced.

Example ID file \File{measure.bypass} instruments the system calls \Procedure{read}, \Procedure{write}, and \Procedure{exit} in order to report the amount of data transferred by a program:

\begin{verbatim}
client_prologue
{{
        #include <stdio.h>

        static int bytes_read=0;
        static int bytes_written=0;
}}

ssize_t read( int fd, void *data, size_t nbytes )
        client_action
        {{
                result = read(fd,data,nbytes);
                if(result>0) bytes_read += result;
        }};

ssize_t write( int fd, const void *data, size_t nbytes )
        client_action
        {{
                result = write(fd,data,nbytes);
                if(result>0) bytes_written += result;
        }};

void exit( int status )
        client_action
        {{
                printf("NOTICE: %d bytes read, %d bytes written.\n",
                        bytes_read, bytes_written );
                exit(status);
        }};
\end{verbatim}

The prologue section is optional, and contains any header code required by the user-written code that follows.

Each procedure declaration looks very much like a C function declaration.   The return value, name, and formal parameters are given, followed by some keywords, a code block, and a semicolon.  The formal parameters must match whatever library definition already exists.  Bypass does not check this condition for you -- you will encounter compiler errors if there is a mismatch.  The code block is delimited by double braces, and may contain any arbitrary C++ fragment.  You may define symbols, use the procedure arguments, and assign a value to \Code{result}, which is used as the return value of the function.

\Notice{
Do not perform a \Code{return} statement in the code block.  Bypass needs to clean up some state after the \Keyword{client\_action} has completed.  Assign your return value to \Code{result}.
}

To build a standalone client, run Bypass with the \Keyword{-local} flag on the ID file.  This will produce a C++ file, \File{bypass\_client.C}.  Compile this file, then link it with your existing program.

\begin{verbatim}
>>> bypass -local < measure.bypass
>>> g++ -c bypass_client.C -o bypass_client.o
>>> g++ display.o bypass_client.o -o display
\end{verbatim}

\Notice{
Some platforms may require the \Prog{dl} library to make use of the Bypass code.  If your linker complains about the symbols \Procedure{dlopen} and \Procedure{dlsym}, try linking with the \Opt{-ldl} flag.
}

Here is the output of \Prog{display} after it is instrumented with \File{measure.bypass}:

\begin{verbatim}
>>> ./display /etc/passwd
0: root:x:0:1:System Administration:/:/sbin/sh
1: operator:X:5:5:System Backups:/u/o/p/operator:/bin/tcsh
2: troot:x:0:1:System Administration:/:/bin/tcsh
3: smtp:x:0:0:mail daemon user:/:
4: daemon:x:1:1:System Administration:/:
NOTICE: 8192 bytes read, 230 bytes written.
\end{verbatim}

\subsubsection{A Client and Server}

Bypass may also be used to generate a client and server that perform remote procedure calls.

Example ID file \File{io.bypass} replaces all of the standard UNIX I/O system calls with remote procedure calls:

\begin{verbatim}
int open( in "_POSIX_PATH_MAX" const char *path, int flags, [int mode] );
int close( int fd );
int read( int fd, out "length" void *data, size_t length );
int write( int fd, in "length" const void *data, size_t length );
off_t lseek( int fd, off_t where, int whence );
\end{verbatim}

Notice that some annotations have been made to the parameters of open,
read, and write.  These three procedures have pointer arguments.  Pointers
are a bit tricky because they refer to some large, variable size amount of 
data.  Bypass must be informed of what direction pointer data must move,
and how much data is to be transferred.

The parameter \Code{name} is given to \Procedure{open} to determine what
file to open.  We know that open will not send back any data when it completes,
so we determine that the \Code{name} data only flows \Keyword{in} to
the procedure.  Furthermore, the maximum amount of data that \Procedure{open}
would be interested in is given by a POSIX constant, \Code{\_POSIX\_PATH\_MAX}.

Every pointer argument must be prefixed with \Keyword{in}, \Keyword{out}, or
\Keyword{in out}, to describe which way data flows.  Following may be a 
quoted C++ expression which tells how many bytes are to be transferred.
If no expression is given, it is assumed one object is to be transferred.

Notice also that no \Keyword{client\_action} or \Keyword{server\_action} is
given for each procedure.  When no client action is given, the default
is to simply transmit the call to the server.  When no server action is
given, the default is to simply execute the call with no change.

To build this program, run \Prog{bypass} with the \Opt{-remote} flag.  This time, three files will be written: \File{bypass\_client.C}, \File{bypass\_server.C}, and \File{bypass\_global.h}.  The client code should be built as before, and then linked with the CEDAR library:

\begin{verbatim}
>>> bypass -remote < io.bypass
>>> g++ -I (condor-include-dir) -c bypass_client.C -o bypass_client.o
>>> g++ -L (condor-library-dir) display.o bypass_client.o -lcedar -o display
\end{verbatim}

The server consists only of \File{bypass\_server.C}.  It should also be linked with the CEDAR library.

\begin{verbatim}
>>> g++ -I (condor-include-dir) -c bypass_server.C -o bypass_server.o
>>> g++ -L (condor-library-dir) bypass_server.o -lcedar -o display-server
\end{verbatim}

To execute the program, the server must be started, and then the client must be instructed where to find the server.

First, run the server with no arguments.  It will display a message indicating
the host and port it is running on, and then it will wait for a client
to connect:

\begin{verbatim}
>>> ./display-server
setenv BYPASS_SERVER_HOST 128.105.175.116
setenv BYPASS_SERVER_PORT 3314
bypass_server: Waiting for connection...
\end{verbatim}

The client must be told the host and port number of the server it is
to connect to.  These are passed by way of environment variables.
Handily, the server has printed them out in a format which is convenient
for cutting and pasting.  Paste these into another window, and then
run the client as you normally would.

\begin{verbatim}
>>> setenv BYPASS_SERVER_HOST 128.105.175.116
>>> setenv BYPASS_SERVER_PORT 3314
>>> ./display /etc/passwd
bypass_client: Getting configuration from environment...
bypass_client: Connecting to 128.105.175.116 port 33134...
bypass_client: Connection made.
\end{verbatim}

All the input and output for the program will be conducted in the {\em server} window:

\begin{verbatim}
>>> ./display-server
setenv BYPASS_SERVER_HOST 128.105.175.116
setenv BYPASS_SERVER_PORT 3314
bypass_server: Waiting for connection...
0: root:x:0:1:System Administration:/:/sbin/sh
1: operator:X:5:5:System Backups:/u/o/p/operator:/bin/tcsh
2: troot:x:0:1:System Administration:/:/bin/tcsh
3: smtp:x:0:0:mail daemon user:/:
4: daemon:x:1:1:System Administration:/:
\end{verbatim}

\subsubsection{Combining Client and Server Actions}

Each procedure call may involve an action on either (or both) the client and server programs.  Simply specify a \Keyword{client\_action} or \Keyword{server\_action} block to invoke code.  When no \Keyword{client\_action} is given, the default is to invoke a remote procedure call.  When no \Keyword{server\_action} is given, the default is to invoke the function of the same name.  For example, an ID declaration of 

\begin{verbatim}
off_t lseek( int fd, off_t where, int whence );
\end{verbatim}

implies these actions:

\begin{verbatim}
        client_action
        {{
                result = rpd_remote_lseek( fd, where, whence );
        }}
        server_action
        {{
                result = lseek( fd, where, whence );
        }};
\end{verbatim}

We can use these action blocks to create some very powerful code.  For example, let's modify \Procedure{open} so that some invocations are passed to the server, and some are executed by the client.

\begin{verbatim}
int open( in "_POSIX_PATH_MAX" const char *path, int flags, int mode )
        client_action
        {{
                if(!strncmp(path,"/lib",4)) {
                        printf("Opening %s on the client...\n",path);
                        result = open(path,flags,mode);
                } else {
                        printf("Asking server to open %s\n",path);
                        result = rpd_remote_open(path,flags,mode);
                }
        }}
        server_action
        {{
                printf("Client asked me to open %s...\n");
                result = open(path,flags,mode);
        }};
\end{verbatim}

\subsubsection{Complex Types and CEDAR}

Bypass makes use of CEDAR to transmit the various data types used by
the remote procedures.  CEDAR hides binary data details such as
endianness and integer size so that applications on different platforms
may communicate regardless of these issues.
CEDAR also understands how to pack and unpack
various system structures, such as \Code{struct stat} and
\Code{struct utsname}.

However, CEDAR must be informed of new data types that you create.
Complete documentation for this may be found in the CEDAR manual.
Here is a brief example.

Suppose that you define two procedures which manipulate a patient record:

\begin{verbatim}
client_prologue
{{
        struct patient {
                int id;
                int age;
        };        
}}

int write_patient( int which, in struct patient *p );
int read_patient( int which, out struct patient *p );
\end{verbatim}

\File{stream.h} needs two entries added:
\begin{verbatim}
int code(struct patient &x);
int code(struct patient *x) { return code(*x); }
\end{verbatim}

\File{stream.C} needs a method which describes how to pack and unpack a patient:
\begin{verbatim}
int Stream::code( struct patient &x )
{
        if(!code(x.id) return 0;
        if(!code(x.age) return 0;
        return 1;
}
\end{verbatim}

\subsection{Reference}

\subsubsection{How It Works}

Bypass provides a new definition of each procedure you wish to replace.  Because the Bypass code is linked before the standard library, the Bypass definition is used in favor of the standard definition.

There are several complicating factors:
\begin{enumerate}
\item Bypass must find a way to invoke the original function.  The default is to invoke a system call by the same name, although there are other methods for situations where this doesn't work.  More on this below.
\item Header files often include inline definitions or macros that have the same name as the function you are attempting to replace.  Bypass can produce macros to kill these definitions before the Bypass definitions are processed.
\item Library procedures often have several definitions: \Procedure{open} often calls \Procedure{\_open} or \Procedure{\_\_open}.  Bypass produces a number of these definitions with similar names.
\item We are unwiling to accept an implementation which requires source modification of the original program.  An implementation which does not require re-linking would be even better.
\end{enumerate}

Bypass creates several pieces of code for each procedure declaration:

A \Term{switch} is a procedure with the same name as the input declaration. The job of the switch is to examine the call mode (local or remote) and perform the \Keyword{client\_action} if necessary.

A \Term{sender} has the name of the input declaration with \Code{bypass\_remote\_} prepended.  The job of the sender is to marshall the procedure arguments, send the procedure call to the server, and then wait for the results.

A \Term{receiver} is a \Code{case} statement in the server.  After the system call number has been identified, the job of the receiver is to collect the procedure arguments, perform the server action, and to send the results back to the client.

When building a standalone client, only the switches are built.
When building a client and server, the switches and senders become part of the client, while the receivers become part of the server.

\subsubsection{Explicit Link Control}

Bypass knows of three mechanisms for invoking a procedure.  A specific mechanism can be selected by adding one of the four keywords below to a procedure declaration.  If no keyword is given, the default is taken from the command line.  If no option is given on the command line, the default is \Keyword{syscall}.

\begin{enumerate}
\item[\Keyword{syscall}] Invoke the original procedure by making a system call.  The procedure in question must actually be a system call and must have the appropriate \Code{SYS\_} constant defined in filename{sys/syscall.h}.
\item[\Keyword{dynamic} \oOpt{"library"} ] Invoke the original procedure by dynamically linking to at runtime.  This option only works if the client program is dynamically linked.
\item[\Keyword{static} \oOpt{"library"}] Invoke the original procedure by extracting a copy of the procedure from the library at build time.  All the extracted procedures are put into a file named \File{bypass\_extract.o}, which must be linked with the client program.
\item[\Keyword{plain}] Do not create any code for invoking the original procedure.
\end{enumerate}

Generally, the \Keyword{syscall} method is the most reliable.  However, there are several reasons you might pick one of the others:
\begin{itemize}
\item The procedure in question is a system call but uses an unusal way of passing parameters or returning values.  For example, on most platforms, \Procedure{pipe} uses two register to return its values.  The \Keyword{syscall} mechanism will fail here, so the \Keyword{static} or \Keyword{dynamic} method should be used.
\begin{verbatim}
int pipe( int *fds ) dynamic;
\end{verbatim}
\item The procedure in question is not a system call at all.  For example, \Keyword{isupper} is a standard procedure but involves no system call.
\begin{verbatim}
int isupper( char ch ) static;
\end{verbatim}
\item The procedure in question is not even a standard library call.  For example, Bypass could be used to generate stubs for a completely new procedure called \Procedure{get\_info}.  No local version of this procedure exists, so it should be declared \Keyword{plain}.
\begin{verbatim}
int get_info( in "_POSIX_PATH_MAX" char *filename) plain;
\end{verbatim}
\item Sometimes, a procedure call comes from an unusual library.  For example, on Solaris, \Procedure{socket} is in \Code{libsocket} instead of \Code{libc}:
\begin{verbatim}
int socket( int domain, int type, int protocol ) dynamic "/lib/libsocket.so";
\end{verbatim}
\end{itemize}

\Notice{
When using the \Keyword{dynamic} and \Keyword{static} options, Bypass will make a reasonable guess as to the name of your standard library.  (Probably \Code{/usr/lib/libc.a} or \Code{/usr/lib/libc.so}.)  However, library names vary widely between UNIX systems, so it is best to explicitly specify the intended library on the command line using the \Opt{-dynamiclibrary} or \Opt{-staticlibrary} options.
}

\subsubsection{Variable Arguments}

In general, Bypass does not support procedures with a variable number of arguments.  Occasionally, it is convenient to define a procedure with variable argument syntax when the intent is to simply make one last argument optional.  This is often the case with \Procedure{open}, \Procedure{fcntl}, and the like.

A trailing argument enclosed in brackets indicates that the switch should be declared with variable arguments, but the last argument should be immediately extracted and used like a normal argument over the network.

\subsubsection{Supported Data Types}

Bypass does not go to the trouble to support every last possible combination of C++ type keywords.  The following syntax for types is supported:

\begin{verbatim}
type      : [unsigned] [const] [struct] <type-name> <star-list>
star-list : <nothing> | '*' <star-list>
\end{verbatim}

\subsubsection{Call Numbers}

For every remote procedure, Bypass assigns a unique number and records it in \File{bypass\_global.h}.  To keep things simple, each procedure is assigned an increasing number, based on the order in the input file.

\Notice{
Changing the input file may cause will cause the newly generated code to be incompatible with previously generated code.
}

If you want to change the input file, but keep compatibility with previously generated code, you must observe these rules:

\begin{enumerate}
\item Never re-order declarations.
\item Never remove a declaration.
\item Only add new declarations to the end of the file.
\end{enumerate}

\subsubsection{Built-In Utilities}

For most purposes, the program to be instrumented need not be aware of Bypass.  You can simply link in the Bypass code to get the needed functionality.  If you {\em do} wish to modify your program when using Bypass, the following procedures are available:

\begin{verbatim}
int bypass_client_init( char *hostname, int port );
\end{verbatim}

By default, the client will connect to the server given in the environment at the first use of a remote procedure call.  If you wish to modify your program to connect to a particular host, add this call to your \Procedure{main} procedure before any system calls are performed.
p
\begin{verbatim}
int bypass_mode_set( int mode );
int bypass_mode_get();
\end{verbatim}

Bypass operates in one of two modes: \Keyword{BYPASS\_MODE\_LOCAL} or
\Keyword{BYPASS\_MODE\_REMOTE}.  Local mode indicates that calls to a replaced
procedure should cause the original procedure to be invoked.  Remote mode
indicates that calls to a replaced procedure should cause the 
\Keyword{client\_action} or remote procedure to be invoked.  Unless otherwise
modified, user code runs in remote mode.

To force Bypass into a particular mode, call \Procedure{bypass\_mode\_set} with
pthe appropriate mode constant.  The previous mode will be returned, and
can be used to set the mode back in a later call to \Procedure{bypass\_mode\_set}.

Code in \Keyword{client\_action} blocks is automatically executed in local
mode, so that references to the replaced procedure results in calls to the
original procedure.

\begin{verbatim}
int bypass_remote_*( ... );
\end{verbatim}

For each procedure declaration, Bypass defines a procedure which actually
performs the remote operation.  This remote procedure bears the name of
the replaced procedure, prefixed with \Code{bypass\_remote\_}.  For example, to
invoke a remote \Procedure{open}, without regard to the call mode or
the \Keyword{client\_action}, invoke \Procedure{bypass\_remote\_open} with the
same arguments as \Procedure{open}.

\subsubsection{Interface Definition Syntax}

An ID file consists of an optional client prologue block, an optional server prologue block, and zero or more procedure declarations.

A procedure declaration looks like a simple C prototype, with additional keywords modifying the parameter types and preceding the final semicolon.

The valid keywords are:
\begin{description}
\item[\Keyword{client\_action \{\{ code-fragment \}\}}] Execute this code at the client when in remote mode.
\item[\Keyword{client\_prologue \{\{ code-fragment \}\}}] Place this code before any bypassed procedure definitions.
\item[\Keyword{dynamic \oOpt{"library"} }] When in local mode, execute this procedure by opening the named dynamic library.  If none is given, use the value from the \Keyword{-dynamiclibrary} command-line option.  If that is not given, use \Code{/usr/lib/libc.so}.
\item[\Keyword{file\_table}] Route this call through the Condor OpenFileTable when MappingFileDescriptors is in effect.
\item[\Keyword{file\_table\_name ( name )}] Use this name for OpenFileTable calls.  Implies \Keyword{file\_table}
\item[\Keyword{in \oOpt{"length"}}] This pointer data should be copied to the remote procedure.  If \Code{length} is given, copy that many bytes, otherwise copy one object.
\item[\Keyword{in out \oOpt{"length"}}] This pointer data should be copied to and from the remote procedure.  If \Code{length} is given, copy that many bytes, otherwise copy one object.
\item[\Keyword{kill}] Emit a macro definition which will prevent any static definitions, inline definitions, or prototypes by this name.
\item[\Keyword{local\_name ( name )}] Use this name when invoking a procedure in local mode.
\item[\Keyword{no\_receiver}] Do not generate a receiver.
\item[\Keyword{no\_sender}] Do not generate a sender.
\item[\Keyword{no\_switch}] Do not generate a switch.
\item[\Keyword{not\_supported}] Do not generate a receiver.
\item[\Keyword{out \oOpt{"length"}}] This pointer data should be copied from the remote procedure.  If \Code{length} is given, copy that many bytes, otherwise copy one object.
\item[\Keyword{plain}] If this procedure is called in local mode, cause an error and return -1.
\item[\Keyword{sender\_name ( name )}]  When performing a remote call, invoke this sender.
\item[\Keyword{server\_action \{\{ code-fragment \}\}}] Execute this call at the server when a remote call is received.
\item[\Keyword{server\_prologue \{\{ code-fragment \}\}}] Place this code in the server before any receiver declarations. 
\item[\Keyword{static \oOpt{"library"}}] When in local mode, execute this procedure by calling a statically linked function.  At build time, extract this function from given library.  If no library is named, use the value from the \Keyword{-staticlibrary} command-line option.  If that is not given, use \Code{/usr/lib/libc.a}.
\item[\Keyword{syscall}] When in local mode, execute this procedure by making a system call.
\item[\Keyword{switch\_code \{\{ code-fragment \}\}}]  Do not automatically generate switch code.  Use this code instead.
\item[\Keyword{receiver\_code \{\{ code-fragment \}\}}]  Do not automatically generate receiver code.  Use this instead.
\end{description}






