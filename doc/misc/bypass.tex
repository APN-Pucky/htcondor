
\subsection{Introduction}

Bypass is a tool for replacing UNIX system calls and library procedures with new code.

Bypass reads an interface description (ID) that describes what procedures are to be replaced and what code is to be inserted.  The output is a C++ module that may be compiled and then linked with an arbitray program.  A C++ compiler is required to build the code created by Bypass, but the resulting code works effectively with any language using C calling conventions.  On most platforms, this includes C, C++, and Fortran.

Bypass can also generate RPC stubs and a simple RPC server according to the ID.  With this feature, a program can be transparently instrumented to send any or all of its library calls to another process for execution.   To use this feature, you must link with the Condor External Data Representation (CEDAR) library.

Bypass is used to implement a portion of the Condor distributed batch system.  A number of the more esoteric features of Bypass exist soley for this purpose.

This chapter consists of a cookbook and a reference.  The cookbook gives several examples of ID files.  The reference section enumerates all the various and sundry options of Bypass.

\subsection{Cookbook}

\subsubsection{Getting Started}

Bypass is a standalone program that is packaged with the Condor distributed batch sytem.  To compile code produced by Bypass, you will need to do several things:

\begin{enumerate}
\item Unpack the Condor distribution into a directory.
\item Add the \File{bin} sub-directory to your path.
\item Add the \File{include} sub-directory to your compiler include path.
\item Add the \File{lib} sub-directory to your linker search path.
\item Set the environment variable \Env{BYPASS\_LIBRARY\_DIR} to the \File{lib} sub-directory.
\end{enumerate}

The \File{examples} sub-directory contains a simple program named \Prog{display.c} and several examples of instrumenting the program with Bypass code.

By itself, \Prog{display} simply opens up a file named on the command
line, and then displays the first five lines of the file.  Here's some example output:

\begin{verbatim}
>>> ./display /etc/passwd
0: root:x:0:1:System Administration:/:/sbin/sh
1: operator:X:5:5:System Backups:/u/o/p/operator:/bin/tcsh
2: troot:x:0:1:System Administration:/:/bin/tcsh
3: smtp:x:0:0:mail daemon user:/:
4: daemon:x:1:1:System Administration:/:
\end{verbatim}

Bypass can be used to instrument this program as either a standalone client or a client and server. A standalone client simply uses Bypass to augment its procedure calls with additional code.  A client and server use Bypass to augment code with remote procedure calls that are executed by the server program.

\subsubsection{A Standalone Client}

An ID file consists of a prologue and a declaration for every procedure that will be replaced.

Example ID file \File{measure.bypass} instruments the system calls \Procedure{read}, \Procedure{write}, and \Procedure{exit} in order to report the amount of data transferred by a program:

\begin{verbatim}
client_prologue
{{
        #include <stdio.h>

        static int bytes_read=0;
        static int bytes_written=0;
}}

ssize_t read( int fd, void *data, size_t nbytes )
        client_action
        {{
                result = read(fd,data,nbytes);
                if(result>0) bytes_read += result;
        }};

ssize_t write( int fd, const void *data, size_t nbytes )
        client_action
        {{
                result = write(fd,data,nbytes);
                if(result>0) bytes_written += result;
        }};

void exit( int status )
        client_action
        {{
                printf("NOTICE: %d bytes read, %d bytes written.\n",
                        bytes_read, bytes_written );
                exit(status);
        }};
\end{verbatim}

The prologue section is optional, and contains any header code required by the user-written code that follows.

Each procedure declaration looks very much like a C function declaration.   The return value, name, and formal parameters are given, followed by some keywords, a code block, and a semicolon.  The formal parameters must match whatever library definition already exists.  Bypass does not check this condition for you -- you will encounter compiler errors if there is a mismatch.  The code block is delimited by double braces, and may contain any arbitrary C++ fragment.  You may define symbols, use the procedure arguments, and assign a value to \Code{result}, which is used as the return value of the function.

\Notice{
Do not perform a \Code{return} statement in the code block.  Bypass needs to clean up some state after the \Keyword{client\_action} has completed.  Assign your return value to \Code{result}.
}

To build a standalone client, run Bypass with the \Keyword{-local} flag on the ID file.  This will produce a C++ file, \File{bypass\_client.C}.  Compile this file, then link it with your existing program.

\begin{verbatim}
>>> bypass -local < measure.bypass
>>> g++ -c bypass_client.C -o bypass_client.o
>>> g++ display.o bypass_client.o -o display
\end{verbatim}

\Notice{
Some platforms may require the \Prog{dl} library to make use of the Bypass code.  If your linker complains about the symbols \Procedure{dlopen} and \Procedure{dlsym}, try linking with the \Opt{-ldl} flag.
}

Here is the output of \Prog{display} after it is instrumented with \File{measure.bypass}:

\begin{verbatim}
>>> ./display /etc/passwd
0: root:x:0:1:System Administration:/:/sbin/sh
1: operator:X:5:5:System Backups:/u/o/p/operator:/bin/tcsh
2: troot:x:0:1:System Administration:/:/bin/tcsh
3: smtp:x:0:0:mail daemon user:/:
4: daemon:x:1:1:System Administration:/:
NOTICE: 8192 bytes read, 230 bytes written.
\end{verbatim}

\subsubsection{A Client and Server}

Bypass may also be used to generate a client and server that perform remote procedure calls.

Example ID file \File{io.bypass} replaces all of the standard UNIX I/O system calls with remote procedure calls:

\begin{verbatim}
int open( in "_POSIX_PATH_MAX" const char *path, int flags, [int mode] );
int close( int fd );
int read( int fd, out "length" void *data, size_t length );
int write( int fd, in "length" const void *data, size_t length );
off_t lseek( int fd, off_t where, int whence );
\end{verbatim}

Notice that some annotations have been made to the parameters of open,
read, and write.  These three procedures have pointer arguments.  Pointers
are a bit tricky because they refer to some large, variable size amount of 
data.  Bypass must be informed of what direction pointer data must move,
and how much data is to be transferred.

The parameter \Code{name} is given to \Procedure{open} to determine what
file to open.  We know that open will not send back any data when it completes,
so we determine that the \Code{name} data only flows \Keyword{in} to
the procedure.  Furthermore, the maximum amount of data that \Procedure{open}
would be interested in is given by a POSIX constant, \Code{\_POSIX\_PATH\_MAX}.

Every pointer argument must be prefixed with \Keyword{in}, \Keyword{out}, or
\Keyword{in out}, to describe which way data flows.  Following may be a 
quoted C++ expression which tells how many bytes are to be transferred.
If no expression is given, it is assumed one object is to be transferred.

Notice also that no \Keyword{client\_action} or \Keyword{server\_action} is
given for each procedure.  When no client action is given, the default
is to simply transmit the call to the server.  When no server action is
given, the default is to simply execute the call with no change.

To build this program, run \Prog{bypass} with the \Opt{-remote} flag.  This time, three files will be written: \File{bypass\_client.C}, \File{bypass\_server.C}, and \File{bypass\_global.h}.  The client code should be built as before, and then linked with the CEDAR library:

\begin{verbatim}
>>> bypass -remote < io.bypass
>>> g++ -I (condor-include-dir) -c bypass_client.C -o bypass_client.o
>>> g++ -L (condor-library-dir) display.o bypass_client.o -lcedar -o display
\end{verbatim}

The server consists only of \File{bypass\_server.C}.  It should also be linked with the CEDAR library.

\begin{verbatim}
>>> g++ -I (condor-include-dir) -c bypass_server.C -o bypass_server.o
>>> g++ -L (condor-library-dir) bypass_server.o -lcedar -o display-server
\end{verbatim}

To execute the program, the server must be started, and then the client must be instructed where to find the server.

First, run the server with no arguments.  It will display a message indicating
the host and port it is running on, and then it will wait for a client
to connect:

\begin{verbatim}
>>> ./display-server
setenv BYPASS_SERVER_HOST 128.105.175.116
setenv BYPASS_SERVER_PORT 3314
bypass_server: Waiting for connection...
\end{verbatim}

The client must be told the host and port number of the server it is
to connect to.  These are passed by way of environment variables.
Handily, the server has printed them out in a format which is convenient
for cutting and pasting.  Paste these into another window, and then
run the client as you normally would.

\begin{verbatim}
>>> setenv BYPASS_SERVER_HOST 128.105.175.116
>>> setenv BYPASS_SERVER_PORT 3314
>>> ./display /etc/passwd
bypass_client: Getting configuration from environment...
bypass_client: Connecting to 128.105.175.116 port 33134...
bypass_client: Connection made.
\end{verbatim}

All the input and output for the program will be conducted in the {\em server} window:

\begin{verbatim}
>>> ./display-server
setenv BYPASS_SERVER_HOST 128.105.175.116
setenv BYPASS_SERVER_PORT 3314
bypass_server: Waiting for connection...
0: root:x:0:1:System Administration:/:/sbin/sh
1: operator:X:5:5:System Backups:/u/o/p/operator:/bin/tcsh
2: troot:x:0:1:System Administration:/:/bin/tcsh
3: smtp:x:0:0:mail daemon user:/:
4: daemon:x:1:1:System Administration:/:
\end{verbatim}

\subsubsection{Combining Client and Server Actions}

Each procedure call may involve an action on either (or both) the client and server programs.  Simply specify a \Keyword{client\_action} or \Keyword{server\_action} block to invoke code.  When no \Keyword{client\_action} is given, the default is to invoke a remote procedure call.  When no \Keyword{server\_action} is given, the default is to invoke the function of the same name.  For example, an ID declaration of 

\begin{verbatim}
off_t lseek( int fd, off_t where, int whence );
\end{verbatim}

implies these actions:

\begin{verbatim}
        client_action
        {{
                result = rpd_remote_lseek( fd, where, whence );
        }}
        server_action
        {{
                result = lseek( fd, where, whence );
        }};
\end{verbatim}

We can use these action blocks to create some very powerful code.  For example, let's modify \Procedure{open} so that some invocations are passed to the server, and some are executed by the client.

\begin{verbatim}
int open( in "_POSIX_PATH_MAX" const char *path, int flags, int mode )
        client_action
        {{
                if(!strncmp(path,"/lib",4)) {
                        printf("Opening %s on the client...\n",path);
                        result = open(path,flags,mode);
                } else {
                        printf("Asking server to open %s\n",path);
                        result = rpd_remote_open(path,flags,mode);
                }
        }}
        server_action
        {{
                printf("Client asked me to open %s...\n");
                result = open(path,flags,mode);
        }};
\end{verbatim}

\subsubsection{Complex Types and CEDAR}

Bypass makes use of CEDAR to transmit the various data types used by
the remote procedures.  CEDAR hides binary data details such as
endianness and integer size so that applications on different platforms
may communicate regardless of these issues.
CEDAR also understands how to pack and unpack
various system structures, such as \Code{struct stat} and
\Code{struct utsname}.

However, CEDAR must be informed of new data types that you create.
Complete documentation for this may be found in the CEDAR manual.
Here is a brief example.

Suppose that you define two procedures which manipulate a patient record:

\begin{verbatim}
client_prologue
{{
        struct patient {
                int id;
                int age;
        };        
}}

int write_patient( int which, in struct patient *p );
int read_patient( int which, out struct patient *p );
\end{verbatim}

\File{stream.h} needs two entries added:
\begin{verbatim}
int code(struct patient &x);
int code(struct patient *x) { return code(*x); }
\end{verbatim}

\File{stream.C} needs a method which describes how to pack and unpack a patient:
\begin{verbatim}
int Stream::code( struct patient &x )
{
        if(!code(x.id) return 0;
        if(!code(x.age) return 0;
        return 1;
}
\end{verbatim}

\subsection{Reference}

\subsubsection{How It Works}

Bypass provides a new definition of each procedure you wish to replace.  Because the Bypass code is linked before the standard library, the Bypass definition is used in favor of the standard definition.

There are several complicating factors:
\begin{enumerate}
\item Bypass must find a way to invoke the original function.  The default is to invoke a system call by the same name, although there are other methods for situations where this doesn't work.  More on this below.
\item Header files often include inline definitions or macros that have the same name as the function you are attempting to replace.  Bypass produces macros which rename these definitions before the Bypass definitions are processed.
\item Library procedures often have several definitions: \Procedure{open} often calls \Procedure{\_open} or \Procedure{\_\_open}.  Bypass produces a number of these definitions with similar names.
\end{enumerate}

Bypass creates several pieces of code for each procedure declaration:

A \Term{switch} is a procedure with the same name as the input declaration. The job of the switch is to examine the call mode (local or remote) and perform the \Keyword{client\_action} if necessary.

A \Term{sender} has the name of the input declaration with \Code{bypass\_remote\_} prepended.  The job of the sender is to marshall the procedure arguments, send the procedure call to the server, and then wait for the results.

A \Term{receiver} is a \Code{case} statement in the server.  After the system call number has been identified, the job of the receiver is to collect the procedure arguments, perform the server action, and to send the results back to the client.

When building a standalone client, only the switches are built.
When building a client and server, the switches and senders become part of the client, while the receivers become part of the server.

\subsubsection{Explicit Link Control}

Bypass knows of three mechansims for invoking a procedure.  A specific mechanism can be selected by adding one of the four keywords below to a procedure declaration.  If no keyword is given, the default is taken from the command line.  If no option is given on the command line, the default is \Keyword{syscall}.

\begin{enumerate}
\item[\Keyword{syscall}] Invoke the original procedure by making a system call.  The procedure in question must actually be a system call and must have the appropriate \Code{SYS\_} constant defined in filename{sys/syscall.h}.
\item[\Keyword{dynamic} \[\"library\"\]] Invoke the original procedure by dynamically linking to at runtime.  This option only works if the client program is dynamically linked.
\item[\Keyword{static} \[\"library\"\]] Invoke the original procedure by extracting a copy of the procedure from the library at build time.  All the extracted procedures are put into a file named \File{bypass\_extract.o}, which must be linked with the client program.
\item[\Keyword{plain}] Do not create any code for invoking the original procedure.
\end{enumerate}

Generally, the \Keyword{syscall} method is the most reliable.  However, there are several reasons you might pick one of the others:
\begin{itemize}
\item The procedure in question is a system call but uses an unusal way of passing parameters or returning values.  For example, on most platforms, \Procedure{pipe} uses two register to return its values.  The \Keyword{syscall} mechanism will fail here, so the \Keyword{static} or \Keyword{dynamic} method should be used.
\begin{verbatim}
int pipe( int *fds ) dynamic;
\end{verbatim}
\item The procedure in question is not a system call at all.  For example, \Keyword{isupper} is a standard procedure but involves no system call.
\begin{verbatim}
int isupper( char ch ) static;
\end{verbatim}
\item The procedure in question is not even a standard library call.  For example, Bypass could be used to generate stubs for a completely new procedure called \Procedure{get\_info}.  No local version of this procedure exists, so it should be declared \Keyword{plain}.
\begin{verbatim}
int get_info( in "_POSIX_PATH_MAX" char *filename) plain;
\end{verbatim}
\item Sometimes, a procedure call comes from an unusual library.  For example, on Solaris, \Procedure{socket} is in \Code{libsocket} instead of \Code{libc}:
\begin{verbatim}
int socket( int domain, int type, int protocol ) dynamic "/lib/libsocket.so";
\end{verbatim}
\end{itemize}

\Notice{
When using the \Keyword{dynamic} and \Keyword{static} options, Bypass will make a reasonable guess as to the name of your standard library.  (Probably \Code{/usr/lib/libc.a} or \Code{/usr/lib/libc.so}.)  However, library names vary widely between UNIX systems, so it is best to explicitly specify the intended library on the command line using the \Opt{-dynamiclibrary} or \Opt{-staticlibrary} options.
}

\subsubsection{Dataflow}

Each parameter to a procedure may have an optional control modifier.  The modifiers are:
\begin{description}
\item[\Keyword{in}] Before invoking the procedure, copy this parameter from the caller's space into the procedure's space.
\item[\Keyword{out}] After invoking the procedure, copy this paramter from the procedure's space into the caller's space.
\item[\Keyword{in out}] Do both of the above.
\end{description}

Following the control modifier may be a C++ expression in quotes.  If this expression is provided, it is interpreted as the number of bytes to be copied.  If it is ommitted, one object of the given type is transferred.

The expression may contain any of the symbols defined in the parameter list or the symbol \Keyword{result}, which represents the return value of the procedure.

\subsubsection{Variable Arguments}

In general, Bypass does not support procedures with a variable number of arguments.  Occasionally, it is convenient to define a procedure with variable argument syntax when the intent is to simply make one last argument optional.  This is often the case with \Procedure{open}, \Procedure{fcntl}, and the like.

A trailing argument enclosed in brackets indicates that the switch should be declared with variable arguments, but the last argument should be immediately extracted and used like a normal argument over the network.

\subsubsection{Supported Data Types}

Bypass does not go to the trouble to support every last possible combination of C++ type keywords.  The following syntax for types is supported:

\begin{verbatim}
type      : [unsigned] [const] [struct] <type-name> <star-list>
star_list : <nothing> | '*' <star-list>
\end{verbatim}

\subsubsection{Call Numbers}

For every remote procedure, Bypass assigns a unique number and records it in \File{bypass\_global.h}.  To keep things simple, each procedure is assigned an increasing number, based on the order in the input file.

\Notice{
Changing the input file may cause will cause the newly generated code to be incompatible with previously generated code.
}

If you want to change the input file, but keep compatibility with previously generated code, you must observe these rules:

\begin{enumerate}
\item Never re-order declarations.
\item Never remove a declaration.
\item Only add new declarations to the end of the file.
\end{enumerate}

\subsubsection{Built-In Utilities}

For most purposes, the program to be instrumented need not be aware of Bypass.  You can simply link in the Bypass code to get the needed functionality.  If you {\em do} wish to modify your program when using Bypass, the following procedures are available:

\begin{verbatim}
int bypass_client_init( char *hostname, int port );
\end{verbatim}

By default, the client will connect to the server given in the environment at the first use of a remote procedure call.  If you wish to modify your program to connect to a particular host, add this call to your \Procedure{main} procedure before any system calls are performed.
p
\begin{verbatim}
int bypass_mode_set( int mode );
int bypass_mode_get();
\end{verbatim}

Bypass operates in one of two modes: \Keyword{BYPASS\_MODE\_LOCAL} or
\Keyword{BYPASS\_MODE\_REMOTE}.  Local mode indicates that calls to a replaced
procedure should cause the original procedure to be invoked.  Remote mode
indicates that calls to a replaced procedure should cause the 
\Keyword{client\_action} or remote procedure to be invoked.  Unless otherwise
modified, user code runs in remote mode.

To force Bypass into a particular mode, call \Procedure{bypass\_mode\_set} with
pthe appropriate mode constant.  The previous mode will be returned, and
can be used to set the mode back in a later call to \Procedure{bypass\_mode\_set}.

Code in \Keyword{client\_action} blocks is automatically executed in local
mode, so that references to the replaced procedure results in calls to the
original procedure.

\begin{verbatim}
int bypass_remote_*( ... );
\end{verbatim}

For each procedure declaration, Bypass defines a procedure which actually
performs the remote operation.  This remote procedure bears the name of
the replaced procedure, prefixed with \Code{bypass\_remote\_}.  For example, to
invoke a remote \Procedure{open}, without regard to the call mode or
the \Keyword{client\_action}, invoke \Procedure{bypass\_remote\_open} with the
same arguments as \Procedure{open}.

\subsubsection{Special Code (Condor Feature)}

For some unusual procedures, special code is required that Bypass is unable to create automatically.  Six keywords are provided that allow a fine-grained control over code generation.

The keywords \Keyword{no\_switch}, \Keyword{no\_sender}, and \Keyword{no\_receiver} placed after a prototype indicate that no code at all is to be created for the named part.  you can use this feature to simply remove unecessary code, or you can provide a special version of the named part in another module.

The keywords \Keyword{switch\_code}, \Keyword{sender\_code}, and \Keyword{receiver\_code} allow you to specify replacement code in the input file itself.  The replacement code can be any C++ code fragment placed inside double braces, omitting any procedure headers or brackets.

The keyword \Keyword{not\_supported} is equivalent to \Keyword{no\_receiver}.
If the server does not know how to receive the call, it reports back \Code{BYPASS\_ERROR\_NOT\_HANDLED}, which causes the switch to return -1.

Example:

\begin{quote}
\begin{verbatim}
void sync()
        switch {{
                /* Always do a local sync */
                sync();

                /* Do a remote sync if in remote mode */
                if(bypass_mode_get()==BYPASS_MODE_REMOTE)
                        bypass_remote_sync();
        }}
\end{verbatim}
\end{quote}
 
\subsubsection{Call Names (Condor Feature)}

By default, a switch only invokes related procedures with the same name.  For example, a switch named \Code{x} invokes a sender named \Code{bypass\_remote\_x}, a static local call of \Code{X}, and so on.  It is sometimes necessary to connect multiple components with different names.  The keywords \Keyword{sender\_name}, \Keyword{local\_name}, and \Keyword{file\_table\_name} allow a switch to invoke components with different names from the switch.

Suppose that we want to provide a switch for several related operations, but have them share the same implementation at the server.  This code directs three switches to invoke the same sender:

\begin{quote}
\begin{verbatim}
int fsync( int fd );
int fdsync( int fd ) sender_name( fsync );
int fdatasync( int fd ) sender_name( fsync );
\end{verbatim}
\end{quote}

\subsubsection{File Table (Condor Feature)}
\label{file-table}

For the purposes of Condor, procedure calls which affect files must pass through an object which tracks the state of the open file table.  This only happens when file descriptor mapping is in effect.  To force a procedure to be dispatched through the file table, use the keyword \Keyword{file\_table}.  The keyword \Keyword{file\_table\_name} also implies this action.

Code created using this option won't even compile unless you are using the full Condor machinery.





