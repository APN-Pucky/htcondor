#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use JSON;
use Data::Dumper;

use constant TRUE => 1;
use constant FALSE => 0;

#
# At some point, the singleton ASG we're fiddling with will become a
# project-specific, rather than central manager -specific, entity.  At
# that point, we'll want to have split the template up into two stacks
# anyway, so we'll still have a unique stack -- its name will just have
# to include the project name as well as the central manager.
#

#
# Argument handling.
#

my( $projectID, $stackName, $setSize, $duration, $keypairName, $centralManager, $passwordFile, $passwordLocation, $help );

GetOptions(
    'project-id=s'		=> \$projectID,
	'stack-name=s'		=> \$stackName,
	'set-size=s'		=> \$setSize,
	'duration=s'		=> \$duration,
	'keypair=s'			=> \$keypairName,
	'central-manager=s'	=> \$centralManager,
	'password-file=s'	=> \$passwordFile,
	'password-url=s'	=> \$passwordLocation,
	'help'				=> \$help
	);

if( defined( $help ) ) {
	print( "Usage: $0 --set-size <size> [options]\n" );
	print( "\n" );
	print( "Adjusts the size of an annex, creating it if necessary.  " );
	print( "It returns when the annex has reached the specified size.  " );
	print( "To create an annex, you must specify a keypair.  " );
	print( "You may only specify a lease duration when creating an annex.\n" );
	print( "\n" );
	print( "Required:\n" );
	print( "\t--set-size         How big (instances) should the annex be?\n" );
	print( "\t--project-id		 To whom will this annex belong?\n" );
	print( "Options:\n" );
	print( "\t--keypair          Which keypair to use (same for all instances).\n" );
	print( "\t--duration         Maximum number of minutes the annex should exist.\n" );
	print( "\t--help             Print this help.\n" );
	print( "Expert options:\n" );
	print( "\t--password-url     An S3 URL pointing to the pool password file.\n" );
	print( "\t--password-file    Specify the pool password file.\n" );
	print( "\t--central-manager  Specify the annex's central manager.\n" );
	print( "\t--stack-name       Name the stack (annex).\n" );
	exit( 0 );
}

if(! defined( $setSize )) {
	die( "You must specify --set-size.\n" );
}

unless( $setSize =~ /\d+/ ) {
	die( "Size must be a positive integer.\n" );
}

if(! defined( $projectID )) {
	die( "You must specify --project-id.\n" );
}

#
# We need to know if the stack exists before we can correctly parse the
# rest of the command-line options.
#

if(! defined( $centralManager ) ) {
	$centralManager = `condor_config_val COLLECTOR_HOST`;
	chomp( $centralManager );
	print( "The annex will report to '${centralManager}'.\n" );
}

my $safeCM = $centralManager;
$safeCM =~ s/:.*$//g;
$safeCM =~ s/\./-/g;

if(! defined( $stackName )) {
	$stackName = "htcondor-annex-${safeCM}-${projectID}";
	print( "The annex will be named '${stackName}'.\n" );
} else {
	unless( $stackName =~ /[a-zA-Z][-a-zA-Z0-9]+/ ) {
		die( "The annex's name must start with an alphabetic character and contain only alphanumeric characters and hypens.\n" );
	}
}

print( "Checking to see if annex already exists...\n" );
my $stackExists = stackExists( $stackName );

# Parse the rest of the command-line options.
if((! $stackExists) && (! defined( $keypairName )) ) {
	print( "You must specify --keypair when creating a new stack.\n" );
	exit( 1 );
}

if(! $stackExists) {
	if(! defined( $duration )) {
		$duration = 24 * 60;
		print( "Lease duration will be one day.\n" );
	} else {
		unless( $duration =~ /\d+/ ) {
			die( "Duration must be a whole number of minutes.\n" );
		}
	}
} else {
	if( defined( $duration ) ) {
		print( "Setting the duration of an existing annex is not yet supported.\n" );
		print( "Setting size of annex as specified anyway.\n" );
	}
}


# It would be nice to skip uploading and then deleting the credentials
# if we're only shrinking the pool (that is, $setSize < $desiredCapacity).
my $didS3Upload = FALSE;
my $s3Bucket = "htcondor-annex-${safeCM}-${projectID}";
if(! defined( $passwordLocation )) {
	if(! defined( $passwordFile )) {
		$passwordFile = `condor_config_val SEC_PASSWORD_FILE`;
		chomp( $passwordFile );
		if( (! defined( $passwordFile )) || $passwordFile eq '' ) {
			die( "Your pool must be configured to use a pool password.\n" );
		}
		print( "Using password file '${passwordFile}'.\n" );
	}

	unless( -e $passwordFile ) {
			die( "The specified password file (${passwordFile}) does not exist.\n" );
	}

	# FIXME: Before we create a bucket, we should set a LAST
	# block to delete it.

	# Securely upload the password file to S3, then set $passwordLocation
	# accordingly.
	my @s3BucketCommand = ( 'aws', 's3api', 'create-bucket',
		'--acl', 'private',
		'--bucket', $s3Bucket );
	my( $rv, $log ) = capture( @s3BucketCommand );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to create (private) S3 bucket $s3Bucket ($rv), aborting.\n" );
		exit( 2 );
	}

	# FIXME: Before we upload the password file, we should set a LAST
	# block to delete it.
	$passwordLocation = "${s3Bucket}/brussel-sprouts";
	my @s3CopyCommand = ( 'aws', 's3', 'cp',
		$passwordFile, "s3://${passwordLocation}" );
	($rv, $log) = capture( @s3CopyCommand );

	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to copy password file to private S3 bucket ($rv), aborting.\n" );
		$rv = system( 'aws', 's3api', 'delete-bucket', '--bucket', $s3Bucket );
		if( $rv != 0 ) {
			print( "Unable to delete (private) S3 bucket $s3Bucket ($rv)!  Sorry, you'll have to clean up after us.\n" );
		}
		exit( 3 );
	}

	$didS3Upload = TRUE;
}


if( ! $stackExists ) {
	print( "Creating annex...\n" );
	createStack( $stackName, $centralManager, $keypairName, $duration, $setSize, $passwordLocation );
}

# If the stack already exists, we still need to wait for its AutoScaling
# Group to be created and obtain the name before we can adjust the size.
my $asgName = waitForAutoScalingGroupCreation( $stackName );

# If the stack didn't exist, it won't hurt it to set the ASG's size.
setAutoScalingGroupDesiredSize( $asgName, $setSize );

# Wait for the ASG's size to change.
my $asgSize = waitForAutoScalingGroupSize( $asgName );
if( $asgSize != $setSize ) {
	print( "... annex is now its desired size, but that's not what you asked for.  Not sure what's going on here.\n" );
}

# FIXME: Wait for the ASG nodes to show up in the pool.

# Remove the pool password and private bucket.
if( $didS3Upload ) { s3Cleanup(); }

exit( 0 );

# -----------------------------------------------------------------------------

sub capture {
	my @command = @_;

	my $childFD;
	my $childPID = open( $childFD, "-|" );
	if(! defined( $childFD )) {
		print( "Unable to execute fork to execute '" . join( ' ', @command ) . "'.\n" );
		return ( -1, undef );
	}

	if( $childPID ) {
		my $size = 0;
		my $log = undef;
		my $read = 0;
		while( ($read = read( $childFD, $log, 1024, $size )) != 0 ) { $size += $read; }

		waitpid( $childPID, 0 );
		my $rv = $?;

		return ($rv, $log);
	} else {
		open( STDERR, '>&STDOUT' );
		exec( @command );
	}
}

sub captureCommand {
	my @command = @_;

	my $childFD;
	my $childPID = open( $childFD, '-|', @command );
	if( $childPID == 0 ) {
		print( "Unable to execute '" . join( ' ', @command ) . "', aborting.\n" );
		s3Cleanup();
		exit( 6 );
	}

	my $size = 0;
	my $output = undef;
	my $read = 0;
	while( ($read = read( $childFD, $output, 1024, $size )) != 0 ) { $size += $read; }

	waitpid( $childPID, 0 );
	if( $? != 0 ) {
		print( "Command '" . join( ' ', @command ) . "' failed ($?), aborting.\n" );
		s3Cleanup();
		exit( 7 );
	}
	close( $childFD );

	return $output;
}

sub stackExists {
	my( $stackName ) = @_;

	my @command = ( 'aws', 'cloudformation', 'describe-stacks' );
	my $output = captureCommand( @command );
	my $reply = decode_json( $output );

	my $stacks = $reply->{ 'Stacks' };
	foreach my $stack (@{$stacks}) {
		if( $stackName eq $stack->{ 'StackName' } ) { return TRUE; }
	}

	return FALSE;
}

sub createStack {
	my( $stackName, $centralManager, $keypairName, $duration, $size, $passwordLocation ) = @_;

	my @command = (
		'aws', 'cloudformation', 'create-stack',
		'--template-url', 'https://s3.amazonaws.com/htcondor-leased-autoscalinggroup/template-1',
		'--stack-name', $stackName,
    	'--capabilities', 'CAPABILITY_IAM',
		'--parameters', '[
            {
                "ParameterKey" : "CentralManager",
                "ParameterValue" : "' . $centralManager . '"
            },
            {
                "ParameterKey" : "SSHKeypairName",
                "ParameterValue" : "' . $keypairName . '"
            },
            {
                "ParameterKey" : "LeaseDuration",
                "ParameterValue" : "' . $duration . '"
            },
            {
                "ParameterKey" : "Size",
                "ParameterValue" : "' . $size . '"
            },
            {
            "ParameterKey" : "S3PoolPassword",
            "ParameterValue" : "' . $passwordLocation . '"
            },
            {
            "ParameterKey" : "ProjectID",
            "ParameterValue" : "' . $projectID . '"
			}
        ]' );

	my( $rv, $log ) = capture( @command );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to create CloudFormation stack ($rv), aborting.\n" );
		exit( 1 );
	}
}

sub waitForAutoScalingGroupCreation {
	my( $stackName ) = @_;

	my $asgName = undef;
	while( 1 ) {
		my @command = ( 'aws', 'cloudformation', 'describe-stack-resources',
			'--stack-name', $stackName );

		my $output = captureCommand( @command );

		my $reply = decode_json( $output );
		my $stackResources = $reply->{ 'StackResources' };
		foreach my $resource (@{$stackResources}) {
			if( $resource->{ 'ResourceType' } eq "AWS::AutoScaling::AutoScalingGroup" ) {
				if( $resource->{ 'ResourceStatus' } eq "CREATE_COMPLETE" ) {
					$asgName = $resource->{ 'PhysicalResourceId' };
					last;
				}
			}
		}

		if( defined( $asgName ) ) {
			print( "... annex created.\n" );
			last;
		} else {
			print( "... waiting five seconds for annex to be created...\n" );
			sleep( 5 );
			next;
		}
	}

	return $asgName;
}

sub setAutoScalingGroupDesiredSize {
	my( $asgName, $size ) = @_;

	my @command = ( 'aws', 'autoscaling', 'update-auto-scaling-group',
		'--auto-scaling-group-name', $asgName,
		'--max-size', $size,
		'--desired-capacity', $size );
	my( $rv, $log ) = capture( @command );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to set annex to requested size, aborting.\n" );
		s3Cleanup();
		exit( 9 );
	}
}

sub waitForAutoScalingGroupSize {
	my( $asgName ) = @_;

	my $instanceCount = undef;

	while( 1 ) {
		# Does the extant ASG have all the instances it should?  Use the returned
		# value of DesiredCapacity rather than $size in case it changes during
		# the wait for some reason.  (Print out both at the end.)
		my @describeASGCommand = ( 'aws', 'autoscaling', 'describe-auto-scaling-groups',
			'--auto-scaling-group-names', $asgName );

		my $childFD;
		my $childPID = open( $childFD, '-|', @describeASGCommand );
		if( $childPID == 0 ) {
			print( "Unable to execute '" . join( ' ', @describeASGCommand ) . "', aborting.\n" );
			s3Cleanup();
			exit( 7 );
		}

		my $size = 0;
		my $output = undef;
		my $read = 0;
		while( ($read = read( $childFD, $output, 1024, $size )) != 0 ) { $size += $read; }

		waitpid( $childPID, 0 );
		if( $? != 0 ) {
			print( "Failed to describe the auto-scaling group ($?), aborting.\n" );
			s3Cleanup();
			exit( 8 );
		}
		close( $childFD );

		my $desiredCapacity = undef;
		my $reply = decode_json( $output );
		my $autoScalingGroups = $reply->{ 'AutoScalingGroups' };
		foreach my $autoScalingGroup (@{$autoScalingGroups}) {
			if( $autoScalingGroup->{ 'AutoScalingGroupName' } eq $asgName ) {
				$desiredCapacity = $autoScalingGroup->{ 'DesiredCapacity' };
				my $instances = $autoScalingGroup->{ 'Instances' };
				$instanceCount = scalar( @{$instances} );
				last;
			}
		}

		if( $instanceCount == $desiredCapacity ) {
			print( "... annex now has $instanceCount out of $desiredCapacity instances.\n" );
			last;
		}

		print( "... found $instanceCount out of $desiredCapacity instances in the annex.\n" );
		sleep( 5 );
	}

	return $instanceCount;
}

sub s3Cleanup {
	# $passwordLocation and $s3Bucket are globals.
	my @s3DeleteKeyCommand = ( 'aws', 's3', 'rm', "s3://${passwordLocation}" );
	my( $rv, $log ) = capture( @s3DeleteKeyCommand );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Failed to delete password file (s3://${passwordLocation}) from S3 ($rv).  Sorry, you'll have to clean up after us.\n" );
		exit( 4 );
	}

	($rv, $log) = capture( 'aws', 's3api', 'delete-bucket', '--bucket', $s3Bucket );
	if( $rv != 0 ) {
		print( $log );
		print( "\n" );
		print( "Unable to delete (private) S3 bucket $s3Bucket ($rv)!  Sorry, you'll have to clean up after us.\n" );
		exit( 5 );
	}
}
